{
    "version": "https://jsonfeed.org/version/1",
    "title": "Squirre17 Blog • All posts by \"afl\" tag",
    "description": "introvert",
    "home_page_url": "https://Squirre17.github.io",
    "items": [
        {
            "id": "https://squirre17.github.io/2022/11/03/afl-forkserver-maneuver/",
            "url": "https://squirre17.github.io/2022/11/03/afl-forkserver-maneuver/",
            "title": "afl-forkserver-maneuver",
            "date_published": "2022-11-03T11:12:15.000Z",
            "content_html": "<h1 id=\"forkserver的目的\"><a class=\"markdownIt-Anchor\" href=\"#forkserver的目的\">#</a> forkserver 的目的</h1>\n<p>参见 <a href=\"https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html\">lcamtuf.blogspot</a><br>\n 如果每次由 fuzzer 来进行 fork-execve 那么每次目标程序都得进装载器链接器和动态加载库打一套 十分浪费时间。<br>\n但是 如果我们劫持了目标程序的_start 让目标程序一开始执行我们写入的 forkserver 代码，这样就能在装载之后通过 COW 实现低成本的 fork。<br>\n也就是 forkserver 本身就注入到目标程序里面去了，作为目标程序的起始点不断的进行 fork。<br>\n<img src=\"/2022/11/03/afl-forkserver-maneuver/mechanism.png\" alt></p>\n<h1 id=\"trampoline\"><a class=\"markdownIt-Anchor\" href=\"#trampoline\">#</a> trampoline</h1>\n<p>这个被插桩到每个基本块之前</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> u8* trampoline_fmt_64 =</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;.align 4\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;leaq -(128+24)(%%rsp), %%rsp\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq %%rdx,  0(%%rsp)\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq %%rcx,  8(%%rsp)\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq %%rax, 16(%%rsp)\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq $0x%08x, %%rcx\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;call __afl_maybe_log\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq 16(%%rsp), %%rax\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq  8(%%rsp), %%rcx\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq  0(%%rsp), %%rdx\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;leaq (128+24)(%%rsp), %%rsp\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;/* --- END --- */\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将当前 rsp 下降 (128+24)</li>\n<li>rdx rcx rax 分别保存在 rsp 上面一丢丢</li>\n<li>将 <code>R(MAP_SIZE)</code>  这个随机数 (0-65535) 给到 rcx 调用__afl_maybe_log (这个随机数是基本块标号，编译时确定)</li>\n</ol>\n<h1 id=\"main_payload_64\"><a class=\"markdownIt-Anchor\" href=\"#main_payload_64\">#</a> main_payload_64</h1>\n<p>这个主要是注入大量函数逻辑</p>\n<h2 id=\"__afl_maybe_log\"><a class=\"markdownIt-Anchor\" href=\"#__afl_maybe_log\">#</a> __afl_maybe_log</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;__afl_maybe_log:\\n&quot;</span><br><span class=\"line\">&quot;  lahf\\n&quot;</span><br><span class=\"line\">&quot;  seto  %al\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq  __afl_area_ptr(%rip), %rdx\\n&quot;</span><br><span class=\"line\">&quot;  testq %rdx, %rdx\\n&quot;</span><br><span class=\"line\">&quot;  je    __afl_setup\\n&quot;</span><br><span class=\"line\">&quot;__afl_store:\\n&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>lahf : load to ah from eflags</li>\n<li>seto : set to 1 if target byte overflow</li>\n<li>如果 <code>__afl_area_ptr</code>  里没有东西 就跳转到 <code>__afl_setup</code>  (setup 属于共享内存没被初始化的情况，第一次 if 才会走到里面去)</li>\n<li>否则就进行 <code>__afl_store</code> <br>\n 其中 <code>__afl_area_ptr</code>  是共享内存的指针 attach 上 fuzzer 创建的。</li>\n</ul>\n<h2 id=\"__afl_store\"><a class=\"markdownIt-Anchor\" href=\"#__afl_store\">#</a> __afl_store</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;__afl_store:\\n&quot;</span><br><span class=\"line\">&quot;  xorq __afl_prev_loc(%rip), %rcx\\n&quot;</span><br><span class=\"line\">&quot;  xorq %rcx, __afl_prev_loc(%rip)\\n&quot;</span><br><span class=\"line\">&quot;  shrq $1, __afl_prev_loc(%rip)\\n&quot;</span><br><span class=\"line\">&quot;  incb (%rdx, %rcx, 1)\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;__afl_return:\\n&quot;</span><br><span class=\"line\">&quot;  addb $127, %al\\n&quot;</span><br><span class=\"line\">&quot;  sahf\\n&quot;</span><br><span class=\"line\">&quot;  ret\\n&quot;</span><br></pre></td></tr></table></figure>\n<p>为了验证这个原理，上 gdb 调试一下，随便编译一个函数 打断点在 log 那 然后由于通信建立不起来 需要改 prev loc 的内存</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  set &#123;int&#125;&amp;__afl_area_ptr=1</span><br><span class=\"line\">gef➤  x/4gx &amp;__afl_area_ptr</span><br><span class=\"line\">0x4040a0 &lt;__afl_area_ptr&gt;:      0x0000000000000001      0x0000000000000001</span><br><span class=\"line\">0x4040b0 &lt;__afl_fork_pid&gt;:      0x0000000000000000      0x0000000000000001</span><br></pre></td></tr></table></figure>\n<p>然后</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">→   0x4017a0 &lt;__afl_store+0&gt;  xor    rcx, QWORD PTR [rip+0x2901]        # 0x4040a8 &lt;__afl_prev_loc&gt;</span><br><span class=\"line\">    0x4017a7 &lt;__afl_store+7&gt;  xor    QWORD PTR [rip+0x28fa], rcx        # 0x4040a8 &lt;__afl_prev_loc&gt;</span><br><span class=\"line\">    0x4017ae &lt;__afl_store+14&gt; shr    QWORD PTR [rip+0x28f3], 1        # 0x4040a8 &lt;__afl_prev_loc&gt;</span><br><span class=\"line\">    0x4017b5 &lt;__afl_store+21&gt; inc    BYTE PTR [rdx+rcx*1]</span><br></pre></td></tr></table></figure>\n<p>其实就是  <code>__afl_prev_loc = __afl_prev_loc ^ rcx ^ __afl_prev_loc = rcx</code>  就是一个赋值的 trick<br>\nrcx 是这一块地址的标号 在操作之后变成了 上一块地址标号 ^ 当前本块地址标号、<br>\n上一块地址标号变成了 本块地址标号 &gt;&gt; 1。<br>\nrdx  <code>__afl_area_ptr(%rip), %rdx</code>  就是共享内存指针了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class=\"line\">shared_mem[cur_location ^ prev_location]++; </span><br><span class=\"line\">prev_location = cur_location &gt;&gt; <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>右移是为了区分 A -&gt; B or B -&gt; A or X -&gt; X.</p>\n<h2 id=\"__afl_setup\"><a class=\"markdownIt-Anchor\" href=\"#__afl_setup\">#</a> __afl_setup</h2>\n<p>最重要的部分就是这个 shmat 的调用，attach 到 fuzzer 里 setup 的 shm<br>\n 共享内存指针保存在 <code>__afl_area_ptr</code>  中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;\\n&quot;</span><br><span class=\"line\">&quot;  xorq %rdx, %rdx   /* shmat flags    */\\n&quot;</span><br><span class=\"line\">&quot;  xorq %rsi, %rsi   /* requested addr */\\n&quot;</span><br><span class=\"line\">&quot;  movq %rax, %rdi   /* SHM ID         */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;shmat&quot;)</span><br><span class=\"line\">&quot;\\n&quot;</span><br><span class=\"line\">&quot;  cmpq $-1, %rax\\n&quot;</span><br><span class=\"line\">&quot;  je   __afl_setup_abort\\n&quot;</span><br><span class=\"line\">&quot;\\n&quot;</span><br><span class=\"line\">&quot;  /* Store the address of the SHM region. */\\n&quot;</span><br><span class=\"line\">&quot;\\n&quot;</span><br><span class=\"line\">&quot;  movq %rax, %rdx\\n&quot;</span><br><span class=\"line\">&quot;  movq %rax, __afl_area_ptr(%rip)\\n&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"__afl_forkserver\"><a class=\"markdownIt-Anchor\" href=\"#__afl_forkserver\">#</a> __afl_forkserver</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;__afl_forkserver:\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  pushq %rdx\\n&quot;</span><br><span class=\"line\">&quot;  pushq %rdx\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq $4, %rdx               /* length    */\\n&quot;</span><br><span class=\"line\">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\\n&quot;</span><br><span class=\"line\">&quot;  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi       /* file desc */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;write&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  cmpq $4, %rax\\n&quot;</span><br><span class=\"line\">&quot;  jne  __afl_fork_resume\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;__afl_fork_wait_loop:\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq $4, %rdx               /* length    */\\n&quot;</span><br><span class=\"line\">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\\n&quot;</span><br><span class=\"line\">&quot;  movq $&quot; STRINGIFY(FORKSRV_FD) &quot;, %rdi             /* file desc */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;read&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  cmpq $4, %rax\\n&quot;</span><br><span class=\"line\">&quot;  jne  __afl_die\\n&quot;</span><br><span class=\"line\">&quot;\\n&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>存入两次 <code>__afl_area_ptr</code>  的指针</li>\n<li>STRINGIFY ((FORKSRV_FD + 1)) 就是 # stringify</li>\n<li>先写信息给 fuzzer 中去（写什么应该关系不大 就代表着来信息了）</li>\n<li>然后从 forkserver 中读取 fuzzer 传输来的控制信息到 <code>__afl_temp</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CALL_L64(&quot;fork&quot;)</span><br><span class=\"line\">&quot;  cmpq $0, %rax\\n&quot;</span><br><span class=\"line\">&quot;  jl   __afl_die\\n&quot;</span><br><span class=\"line\">&quot;  je   __afl_fork_resume\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movl %eax, __afl_fork_pid(%rip)\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq $4, %rdx                   /* length    */\\n&quot;</span><br><span class=\"line\">&quot;  leaq __afl_fork_pid(%rip), %rsi /* data      */\\n&quot;</span><br><span class=\"line\">&quot;  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi             /* file desc */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;write&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq $0, %rdx                   /* no flags  */\\n&quot;</span><br><span class=\"line\">&quot;  leaq __afl_temp(%rip), %rsi     /* status    */\\n&quot;</span><br><span class=\"line\">&quot;  movq __afl_fork_pid(%rip), %rdi /* PID       */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;waitpid&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  cmpq $0, %rax\\n&quot;</span><br><span class=\"line\">&quot;  jle  __afl_die\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq $4, %rdx               /* length    */\\n&quot;</span><br><span class=\"line\">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\\n&quot;</span><br><span class=\"line\">&quot;  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi         /* file desc */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;write&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  jmp  __afl_fork_wait_loop\\n&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fork 出目标程序的子进程 跳转到 <code>__afl_fork_resume</code></li>\n<li>对于 forkserver 本 f，保存子进程 pid 到 <code>__afl_fork_pid</code></li>\n<li>然后写给 fuzzer</li>\n<li>waitpid 等待子进程结束</li>\n<li>结束后吧 status 写回给 fuzzer，跳转回 <code>__afl_fork_wait_loop</code></li>\n</ul>\n<h2 id=\"__afl_fork_resume\"><a class=\"markdownIt-Anchor\" href=\"#__afl_fork_resume\">#</a> __afl_fork_resume</h2>\n<p>这里主要是 由 forkserver fork 出来的 child 是要执行目标进程的，就需要恢复由于执行 forkserver 而压入的上下文以及关掉两个通信的文件描述符。<br>\n所以这里就是简单的恢复上下文，关闭，执行正常逻辑代码。</p>\n<h1 id=\"summary\"><a class=\"markdownIt-Anchor\" href=\"#summary\">#</a> summary</h1>\n<p>个人画的总结图，还可以吧？<br>\n<img src=\"/2022/11/03/afl-forkserver-maneuver/mydraw.png\" alt></p>\n",
            "tags": [
                "afl"
            ]
        }
    ]
}