{
    "version": "https://jsonfeed.org/version/1",
    "title": "Squirre17 Blog • All posts by \"static analysis\" category",
    "description": "introvert",
    "home_page_url": "https://Squirre17.github.io",
    "items": [
        {
            "id": "https://squirre17.github.io/2022/11/03/afl-forkserver-maneuver/",
            "url": "https://squirre17.github.io/2022/11/03/afl-forkserver-maneuver/",
            "title": "afl-forkserver-maneuver",
            "date_published": "2022-11-03T11:12:15.000Z",
            "content_html": "<h1 id=\"forkserver的目的\"><a class=\"markdownIt-Anchor\" href=\"#forkserver的目的\">#</a> forkserver 的目的</h1>\n<p>参见 <a href=\"https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html\">lcamtuf.blogspot</a><br>\n 如果每次由 fuzzer 来进行 fork-execve 那么每次目标程序都得进装载器链接器和动态加载库打一套 十分浪费时间。<br>\n但是 如果我们劫持了目标程序的_start 让目标程序一开始执行我们写入的 forkserver 代码，这样就能在装载之后通过 COW 实现低成本的 fork。<br>\n也就是 forkserver 本身就注入到目标程序里面去了，作为目标程序的起始点不断的进行 fork。<br>\n<img src=\"/2022/11/03/afl-forkserver-maneuver/mechanism.png\" alt></p>\n<h1 id=\"trampoline\"><a class=\"markdownIt-Anchor\" href=\"#trampoline\">#</a> trampoline</h1>\n<p>这个被插桩到每个基本块之前</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> u8* trampoline_fmt_64 =</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;/* --- AFL TRAMPOLINE (64-BIT) --- */\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;.align 4\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;leaq -(128+24)(%%rsp), %%rsp\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq %%rdx,  0(%%rsp)\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq %%rcx,  8(%%rsp)\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq %%rax, 16(%%rsp)\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq $0x%08x, %%rcx\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;call __afl_maybe_log\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq 16(%%rsp), %%rax\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq  8(%%rsp), %%rcx\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;movq  0(%%rsp), %%rdx\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;leaq (128+24)(%%rsp), %%rsp\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;/* --- END --- */\\n&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;\\n&quot;</span>;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>将当前 rsp 下降 (128+24)</li>\n<li>rdx rcx rax 分别保存在 rsp 上面一丢丢</li>\n<li>将 <code>R(MAP_SIZE)</code>  这个随机数 (0-65535) 给到 rcx 调用__afl_maybe_log (这个随机数是基本块标号，编译时确定)</li>\n</ol>\n<h1 id=\"main_payload_64\"><a class=\"markdownIt-Anchor\" href=\"#main_payload_64\">#</a> main_payload_64</h1>\n<p>这个主要是注入大量函数逻辑</p>\n<h2 id=\"__afl_maybe_log\"><a class=\"markdownIt-Anchor\" href=\"#__afl_maybe_log\">#</a> __afl_maybe_log</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;__afl_maybe_log:\\n&quot;</span><br><span class=\"line\">&quot;  lahf\\n&quot;</span><br><span class=\"line\">&quot;  seto  %al\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq  __afl_area_ptr(%rip), %rdx\\n&quot;</span><br><span class=\"line\">&quot;  testq %rdx, %rdx\\n&quot;</span><br><span class=\"line\">&quot;  je    __afl_setup\\n&quot;</span><br><span class=\"line\">&quot;__afl_store:\\n&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>lahf : load to ah from eflags</li>\n<li>seto : set to 1 if target byte overflow</li>\n<li>如果 <code>__afl_area_ptr</code>  里没有东西 就跳转到 <code>__afl_setup</code>  (setup 属于共享内存没被初始化的情况，第一次 if 才会走到里面去)</li>\n<li>否则就进行 <code>__afl_store</code> <br>\n 其中 <code>__afl_area_ptr</code>  是共享内存的指针 attach 上 fuzzer 创建的。</li>\n</ul>\n<h2 id=\"__afl_store\"><a class=\"markdownIt-Anchor\" href=\"#__afl_store\">#</a> __afl_store</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;__afl_store:\\n&quot;</span><br><span class=\"line\">&quot;  xorq __afl_prev_loc(%rip), %rcx\\n&quot;</span><br><span class=\"line\">&quot;  xorq %rcx, __afl_prev_loc(%rip)\\n&quot;</span><br><span class=\"line\">&quot;  shrq $1, __afl_prev_loc(%rip)\\n&quot;</span><br><span class=\"line\">&quot;  incb (%rdx, %rcx, 1)\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;__afl_return:\\n&quot;</span><br><span class=\"line\">&quot;  addb $127, %al\\n&quot;</span><br><span class=\"line\">&quot;  sahf\\n&quot;</span><br><span class=\"line\">&quot;  ret\\n&quot;</span><br></pre></td></tr></table></figure>\n<p>为了验证这个原理，上 gdb 调试一下，随便编译一个函数 打断点在 log 那 然后由于通信建立不起来 需要改 prev loc 的内存</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  set &#123;int&#125;&amp;__afl_area_ptr=1</span><br><span class=\"line\">gef➤  x/4gx &amp;__afl_area_ptr</span><br><span class=\"line\">0x4040a0 &lt;__afl_area_ptr&gt;:      0x0000000000000001      0x0000000000000001</span><br><span class=\"line\">0x4040b0 &lt;__afl_fork_pid&gt;:      0x0000000000000000      0x0000000000000001</span><br></pre></td></tr></table></figure>\n<p>然后</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">→   0x4017a0 &lt;__afl_store+0&gt;  xor    rcx, QWORD PTR [rip+0x2901]        # 0x4040a8 &lt;__afl_prev_loc&gt;</span><br><span class=\"line\">    0x4017a7 &lt;__afl_store+7&gt;  xor    QWORD PTR [rip+0x28fa], rcx        # 0x4040a8 &lt;__afl_prev_loc&gt;</span><br><span class=\"line\">    0x4017ae &lt;__afl_store+14&gt; shr    QWORD PTR [rip+0x28f3], 1        # 0x4040a8 &lt;__afl_prev_loc&gt;</span><br><span class=\"line\">    0x4017b5 &lt;__afl_store+21&gt; inc    BYTE PTR [rdx+rcx*1]</span><br></pre></td></tr></table></figure>\n<p>其实就是  <code>__afl_prev_loc = __afl_prev_loc ^ rcx ^ __afl_prev_loc = rcx</code>  就是一个赋值的 trick<br>\nrcx 是这一块地址的标号 在操作之后变成了 上一块地址标号 ^ 当前本块地址标号、<br>\n上一块地址标号变成了 本块地址标号 &gt;&gt; 1。<br>\nrdx  <code>__afl_area_ptr(%rip), %rdx</code>  就是共享内存指针了。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class=\"line\">shared_mem[cur_location ^ prev_location]++; </span><br><span class=\"line\">prev_location = cur_location &gt;&gt; <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>右移是为了区分 A -&gt; B or B -&gt; A or X -&gt; X.</p>\n<h2 id=\"__afl_setup\"><a class=\"markdownIt-Anchor\" href=\"#__afl_setup\">#</a> __afl_setup</h2>\n<p>最重要的部分就是这个 shmat 的调用，attach 到 fuzzer 里 setup 的 shm<br>\n 共享内存指针保存在 <code>__afl_area_ptr</code>  中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;\\n&quot;</span><br><span class=\"line\">&quot;  xorq %rdx, %rdx   /* shmat flags    */\\n&quot;</span><br><span class=\"line\">&quot;  xorq %rsi, %rsi   /* requested addr */\\n&quot;</span><br><span class=\"line\">&quot;  movq %rax, %rdi   /* SHM ID         */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;shmat&quot;)</span><br><span class=\"line\">&quot;\\n&quot;</span><br><span class=\"line\">&quot;  cmpq $-1, %rax\\n&quot;</span><br><span class=\"line\">&quot;  je   __afl_setup_abort\\n&quot;</span><br><span class=\"line\">&quot;\\n&quot;</span><br><span class=\"line\">&quot;  /* Store the address of the SHM region. */\\n&quot;</span><br><span class=\"line\">&quot;\\n&quot;</span><br><span class=\"line\">&quot;  movq %rax, %rdx\\n&quot;</span><br><span class=\"line\">&quot;  movq %rax, __afl_area_ptr(%rip)\\n&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"__afl_forkserver\"><a class=\"markdownIt-Anchor\" href=\"#__afl_forkserver\">#</a> __afl_forkserver</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;__afl_forkserver:\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  pushq %rdx\\n&quot;</span><br><span class=\"line\">&quot;  pushq %rdx\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq $4, %rdx               /* length    */\\n&quot;</span><br><span class=\"line\">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\\n&quot;</span><br><span class=\"line\">&quot;  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi       /* file desc */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;write&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  cmpq $4, %rax\\n&quot;</span><br><span class=\"line\">&quot;  jne  __afl_fork_resume\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;__afl_fork_wait_loop:\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq $4, %rdx               /* length    */\\n&quot;</span><br><span class=\"line\">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\\n&quot;</span><br><span class=\"line\">&quot;  movq $&quot; STRINGIFY(FORKSRV_FD) &quot;, %rdi             /* file desc */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;read&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  cmpq $4, %rax\\n&quot;</span><br><span class=\"line\">&quot;  jne  __afl_die\\n&quot;</span><br><span class=\"line\">&quot;\\n&quot;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>存入两次 <code>__afl_area_ptr</code>  的指针</li>\n<li>STRINGIFY ((FORKSRV_FD + 1)) 就是 # stringify</li>\n<li>先写信息给 fuzzer 中去（写什么应该关系不大 就代表着来信息了）</li>\n<li>然后从 forkserver 中读取 fuzzer 传输来的控制信息到 <code>__afl_temp</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CALL_L64(&quot;fork&quot;)</span><br><span class=\"line\">&quot;  cmpq $0, %rax\\n&quot;</span><br><span class=\"line\">&quot;  jl   __afl_die\\n&quot;</span><br><span class=\"line\">&quot;  je   __afl_fork_resume\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movl %eax, __afl_fork_pid(%rip)\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq $4, %rdx                   /* length    */\\n&quot;</span><br><span class=\"line\">&quot;  leaq __afl_fork_pid(%rip), %rsi /* data      */\\n&quot;</span><br><span class=\"line\">&quot;  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi             /* file desc */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;write&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq $0, %rdx                   /* no flags  */\\n&quot;</span><br><span class=\"line\">&quot;  leaq __afl_temp(%rip), %rsi     /* status    */\\n&quot;</span><br><span class=\"line\">&quot;  movq __afl_fork_pid(%rip), %rdi /* PID       */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;waitpid&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  cmpq $0, %rax\\n&quot;</span><br><span class=\"line\">&quot;  jle  __afl_die\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  movq $4, %rdx               /* length    */\\n&quot;</span><br><span class=\"line\">&quot;  leaq __afl_temp(%rip), %rsi /* data      */\\n&quot;</span><br><span class=\"line\">&quot;  movq $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;, %rdi         /* file desc */\\n&quot;</span><br><span class=\"line\">CALL_L64(&quot;write&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;  jmp  __afl_fork_wait_loop\\n&quot;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>fork 出目标程序的子进程 跳转到 <code>__afl_fork_resume</code></li>\n<li>对于 forkserver 本 f，保存子进程 pid 到 <code>__afl_fork_pid</code></li>\n<li>然后写给 fuzzer</li>\n<li>waitpid 等待子进程结束</li>\n<li>结束后吧 status 写回给 fuzzer，跳转回 <code>__afl_fork_wait_loop</code></li>\n</ul>\n<h2 id=\"__afl_fork_resume\"><a class=\"markdownIt-Anchor\" href=\"#__afl_fork_resume\">#</a> __afl_fork_resume</h2>\n<p>这里主要是 由 forkserver fork 出来的 child 是要执行目标进程的，就需要恢复由于执行 forkserver 而压入的上下文以及关掉两个通信的文件描述符。<br>\n所以这里就是简单的恢复上下文，关闭，执行正常逻辑代码。</p>\n<h1 id=\"summary\"><a class=\"markdownIt-Anchor\" href=\"#summary\">#</a> summary</h1>\n<p>个人画的总结图，还可以吧？<br>\n<img src=\"/2022/11/03/afl-forkserver-maneuver/mydraw.png\" alt></p>\n",
            "tags": [
                "afl"
            ]
        },
        {
            "id": "https://squirre17.github.io/2022/10/26/Ghidra-INDIRECT-explanation/",
            "url": "https://squirre17.github.io/2022/10/26/Ghidra-INDIRECT-explanation/",
            "title": "Ghidra-INDIRECT-explanation",
            "date_published": "2022-10-26T10:05:02.000Z",
            "content_html": "<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">undefined4 <span class=\"title function_\">FUN_000114b8</span><span class=\"params\">(<span class=\"type\">void</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  undefined4 in_r3;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s(%d)\\n&quot;</span>,<span class=\"string\">&quot;part_data_end&quot;</span>,<span class=\"number\">0x7d</span>,in_r3,in_r3);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>output result as following (pcode-refined)</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(ram, 0x114d4, 4) INDIRECT (ram, 0x114d4, 4) , (const, 0x15, 4)</span><br><span class=\"line\">(ram, 0x114d8, 4) INDIRECT (ram, 0x114d8, 4) , (const, 0x15, 4)</span><br><span class=\"line\"> ---  CALL (ram, 0x10ba4, 8) , (ram, 0x114d8, 4) , (ram, 0x114d4, 4) , (const, 0x7d, 4) , (register, 0x2c, 4) , (register, 0x2c, 4)</span><br><span class=\"line\"></span><br><span class=\"line\">(register, 0x20, 4) COPY (const, 0x0, 4)</span><br><span class=\"line\">(ram, 0x114d4, 4) COPY (ram, 0x114d4, 4)</span><br><span class=\"line\">(ram, 0x114d8, 4) COPY (ram, 0x114d8, 4)</span><br><span class=\"line\"></span><br><span class=\"line\"> ---  RETURN (const, 0x0, 4) , (register, 0x20, 4)</span><br></pre></td></tr></table></figure>\n<p>M4rsuri’s explanation(<a href=\"https://github.com/NationalSecurityAgency/ghidra/issues/2744\">INDIRECT pcode op, input1 misunderstood · Issue #2744 · NationalSecurityAgency/ghidra · GitHub</a>)</p>\n<pre><code>I think that INDIRECT just indicates the varnode in output can be affected by the pcode indicated by it's input1.So it's impossible for a varnode to be affected when it's both not the output of an instruction and it's not associated with the instruction through an INDIRECT.\nIn other words, the varnodes being the output of all INDIRECTs associated with an instruction is the over-approximation of all varnodes that may be affected by the execution of this instruction. Only CALL/CALLIND instructions can have side affects because we need to take the execution of their corresponding subroutines into consideration. So INDIRECT instructions only appear before CALL/CALLIND instructions.\nI wonder if my understanding is proper.\nThank you.\n</code></pre>\n<p>INDIRECT pass input0 to output, but output be affected by some pcode indicated by input1 possibly.<br>\nAffect means “be changed” and so on in a narrow sense.<br>\nbecause we don’t know what the subroutine indicated by subsequent CALL pcode that take out our parameter’s address will do .Isn’t it? Maybe it can modify the content in the corresponding address. So it’s value is indirected when machine is executed to the next COPY pcode and pass it to other varnode.(so INDIRECT meaning - varnode passed through other subroutine before reaching its destination)<br>\n <code>A special address space indicates input1's use as an internal reference encoding</code>  simply means the Seqnum which indicates the sequence number of anyone pcode.</p>\n<p>if u print out above CALL pcode’s seqnum, u will find it exactly is  <code>0x15</code>  (const, 0x15, 4).</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(ram, <span class=\"number\">0x114c8</span>, <span class=\"number\">67</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">(ram, <span class=\"number\">0x114d4</span>, <span class=\"number\">4</span>) INDIRECT (ram, <span class=\"number\">0x114d4</span>, <span class=\"number\">4</span>) , (<span class=\"type\">const</span>, <span class=\"number\">0x15</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">(ram, <span class=\"number\">0x114c8</span>, <span class=\"number\">69</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">(ram, <span class=\"number\">0x114d8</span>, <span class=\"number\">4</span>) INDIRECT (ram, <span class=\"number\">0x114d8</span>, <span class=\"number\">4</span>) , (<span class=\"type\">const</span>, <span class=\"number\">0x15</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">(ram, <span class=\"number\">0x114c8</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>)                                             &lt;&lt;- <span class=\"number\">21</span> = <span class=\"number\">0x15</span></span><br><span class=\"line\"> ---  CALL (ram, <span class=\"number\">0x10ba4</span>, <span class=\"number\">8</span>) , (ram, <span class=\"number\">0x114d8</span>, <span class=\"number\">4</span>) , (ram, <span class=\"number\">0x114d4</span>, <span class=\"number\">4</span>) , (<span class=\"type\">const</span>, <span class=\"number\">0x7d</span>, <span class=\"number\">4</span>) , (<span class=\"keyword\">register</span>, <span class=\"number\">0x2c</span>, <span class=\"number\">4</span>) , (<span class=\"keyword\">register</span>, <span class=\"number\">0x2c</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">(ram, <span class=\"number\">0x114cc</span>, <span class=\"number\">29</span>, <span class=\"number\">3</span>) </span><br><span class=\"line\">(<span class=\"keyword\">register</span>, <span class=\"number\">0x20</span>, <span class=\"number\">4</span>) COPY (<span class=\"type\">const</span>, <span class=\"number\">0x0</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">(ram, <span class=\"number\">0x114d0</span>, <span class=\"number\">68</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">(ram, <span class=\"number\">0x114d4</span>, <span class=\"number\">4</span>) COPY (ram, <span class=\"number\">0x114d4</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">(ram, <span class=\"number\">0x114d0</span>, <span class=\"number\">70</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">(ram, <span class=\"number\">0x114d8</span>, <span class=\"number\">4</span>) COPY (ram, <span class=\"number\">0x114d8</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">(ram, <span class=\"number\">0x114d0</span>, <span class=\"number\">44</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"> ---  RETURN (<span class=\"type\">const</span>, <span class=\"number\">0x0</span>, <span class=\"number\">4</span>) , (<span class=\"keyword\">register</span>, <span class=\"number\">0x20</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p>Thanks M4tsuri for his help.</p>\n",
            "tags": [
                "Ghidra"
            ]
        },
        {
            "id": "https://squirre17.github.io/2022/10/18/llvm-init/",
            "url": "https://squirre17.github.io/2022/10/18/llvm-init/",
            "title": "llvm-init",
            "date_published": "2022-10-18T02:27:10.000Z",
            "content_html": "<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install lld-12</span><br><span class=\"line\">sudo ln -s /lib/llvm-9/bin/llc /bin/llc</span><br><span class=\"line\">sudo ln -s /lib/llvm-9/bin/opt /bin/opt</span><br></pre></td></tr></table></figure>\n<p>官方文档：<a href=\"https://llvm.org/docs/LangRef.html\">LLVM Language Reference Manual — LLVM 16.0.0git documentation</a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -Xclang -ast-dump -fsyntax-only test.c</span><br></pre></td></tr></table></figure>\n<p>生成 AST</p>\n<ul>\n<li>-S                      Only run preprocess and compilation steps</li>\n<li>-emit-llvm         Use the LLVM representation for assembler and object files</li>\n<li>-c                      Only run preprocess, compile, and assemble steps （生成字节码的 bc 文件）</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -S -emit-llvm test.c </span><br></pre></td></tr></table></figure>\n<p>生成的 ir 中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define dso_local i32 @main() #<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">  %<span class=\"number\">1</span> = alloca i32, align <span class=\"number\">4</span></span><br><span class=\"line\">  store i32 <span class=\"number\">0</span>, i32* %<span class=\"number\">1</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  ret i32 <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果开启优化</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -S -emit-llvm -O3 test.c</span><br></pre></td></tr></table></figure>\n<p>会直接变成</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define dso_local i32 @main() local_unnamed_addr #<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">  ret i32 <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后用 llc 生成汇编</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">llc test.ll</span><br></pre></td></tr></table></figure>\n<p>ll 到 bc 文件可以用 llvm-as<br>\n 反过来用 llvm-dis<br>\n 注意，ll 和 bc 和内存中的形式是等价的。</p>\n<p><code>dso_local</code>  是一个 Runtime Preemption 说明符，表明该函数会在同一个链接单元（即该函数所在的文件以及包含的头文件）内解析符号。</p>\n<p>对于</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.c</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">foo</span><span class=\"params\">(<span class=\"type\">int</span> first, <span class=\"type\">int</span> second)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first + second;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> b = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo(a, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>生成</p>\n<ul>\n<li>alloca 就是在栈中分配空间</li>\n<li>先把传入的值放入栈中再拿出来（嫩麻烦</li>\n<li>nsw : no signed wrap</li>\n<li>所有的全局变量都以 @ 为前缀</li>\n<li>这里 <code>#0</code>  与之后的 <code>attributes #0</code>  相对应</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">; ModuleID = <span class=\"string\">&#x27;main.c&#x27;</span></span><br><span class=\"line\">source_filename = <span class=\"string\">&quot;main.c&quot;</span></span><br><span class=\"line\">target datalayout = <span class=\"string\">&quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class=\"line\">target triple = <span class=\"string\">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@a = dso_local global i32 <span class=\"number\">5</span>, align <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class=\"line\">define dso_local i32 @foo(i32, i32) #<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">  %<span class=\"number\">3</span> = alloca i32, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">4</span> = alloca i32, align <span class=\"number\">4</span></span><br><span class=\"line\">  store i32 %<span class=\"number\">0</span>, i32* %<span class=\"number\">3</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  store i32 %<span class=\"number\">1</span>, i32* %<span class=\"number\">4</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">5</span> = load i32, i32* %<span class=\"number\">3</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">6</span> = load i32, i32* %<span class=\"number\">4</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">7</span> = add nsw i32 %<span class=\"number\">5</span>, %<span class=\"number\">6</span></span><br><span class=\"line\">  ret i32 %<span class=\"number\">7</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class=\"line\">define dso_local i32 @main() #<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">  %<span class=\"number\">1</span> = alloca i32, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">2</span> = alloca i32, align <span class=\"number\">4</span></span><br><span class=\"line\">  store i32 <span class=\"number\">0</span>, i32* %<span class=\"number\">1</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  store i32 <span class=\"number\">4</span>, i32* %<span class=\"number\">2</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">3</span> = load i32, i32* @a, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">4</span> = load i32, i32* %<span class=\"number\">2</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">5</span> = call i32 @foo(i32 %<span class=\"number\">3</span>, i32 %<span class=\"number\">4</span>)</span><br><span class=\"line\">  ret i32 %<span class=\"number\">5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">attributes #<span class=\"number\">0</span> = &#123; noinline nounwind optnone uwtable <span class=\"string\">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"string\">&quot;disable-tail-calls&quot;</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"string\">&quot;less-precise-fpmad&quot;</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"string\">&quot;min-legal-vector-width&quot;</span>=<span class=\"string\">&quot;0&quot;</span> <span class=\"string\">&quot;no-frame-pointer-elim&quot;</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"string\">&quot;no-frame-pointer-elim-non-leaf&quot;</span> <span class=\"string\">&quot;no-infs-fp-math&quot;</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"string\">&quot;no-jump-tables&quot;</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"string\">&quot;no-nans-fp-math&quot;</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"string\">&quot;no-signed-zeros-fp-math&quot;</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"string\">&quot;no-trapping-math&quot;</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"string\">&quot;stack-protector-buffer-size&quot;</span>=<span class=\"string\">&quot;8&quot;</span> <span class=\"string\">&quot;target-cpu&quot;</span>=<span class=\"string\">&quot;x86-64&quot;</span> <span class=\"string\">&quot;target-features&quot;</span>=<span class=\"string\">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class=\"string\">&quot;unsafe-fp-math&quot;</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"string\">&quot;use-soft-float&quot;</span>=<span class=\"string\">&quot;false&quot;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">!llvm.module.flags = !&#123;!<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">!llvm.ident = !&#123;!<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">!<span class=\"number\">0</span> = !&#123;i32 <span class=\"number\">1</span>, !<span class=\"string\">&quot;wchar_size&quot;</span>, i32 <span class=\"number\">4</span>&#125;</span><br><span class=\"line\">!<span class=\"number\">1</span> = !&#123;!<span class=\"string\">&quot;clang version 9.0.1-12 &quot;</span>&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>对于库外函数 要使用就需要 declare 这个函数的签名</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare i32 @getint()</span><br></pre></td></tr></table></figure>\n<h2 id=\"条件分支\"><a class=\"markdownIt-Anchor\" href=\"#条件分支\">#</a> 条件分支</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//if.c</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = getint();</span><br><span class=\"line\">    <span class=\"type\">int</span> b = getint();</span><br><span class=\"line\">    <span class=\"type\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a == b) &#123;</span><br><span class=\"line\">        c = <span class=\"number\">5</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        c = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    putint(c);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define dso_local i32 @main() #<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">  %<span class=\"number\">1</span> = alloca i32, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">2</span> = alloca i32, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">3</span> = alloca i32, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">4</span> = alloca i32, align <span class=\"number\">4</span></span><br><span class=\"line\">  store i32 <span class=\"number\">0</span>, i32* %<span class=\"number\">1</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">5</span> = call i32 (...) @getint()</span><br><span class=\"line\">  store i32 %<span class=\"number\">5</span>, i32* %<span class=\"number\">2</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">6</span> = call i32 (...) @getint()</span><br><span class=\"line\">  store i32 %<span class=\"number\">6</span>, i32* %<span class=\"number\">3</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  store i32 <span class=\"number\">0</span>, i32* %<span class=\"number\">4</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">7</span> = load i32, i32* %<span class=\"number\">2</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">8</span> = load i32, i32* %<span class=\"number\">3</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">9</span> = icmp eq i32 %<span class=\"number\">7</span>, %<span class=\"number\">8</span></span><br><span class=\"line\">  br i1 %<span class=\"number\">9</span>, label %<span class=\"number\">10</span>, label %<span class=\"number\">11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">10</span>:                                               ; preds = %<span class=\"number\">0</span></span><br><span class=\"line\">  store i32 <span class=\"number\">5</span>, i32* %<span class=\"number\">4</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  br label %<span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">11</span>:                                               ; preds = %<span class=\"number\">0</span></span><br><span class=\"line\">  store i32 <span class=\"number\">10</span>, i32* %<span class=\"number\">4</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  br label %<span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">12</span>:                                               ; preds = %<span class=\"number\">11</span>, %<span class=\"number\">10</span></span><br><span class=\"line\">  %<span class=\"number\">13</span> = load i32, i32* %<span class=\"number\">4</span>, align <span class=\"number\">4</span></span><br><span class=\"line\">  %<span class=\"number\">14</span> = call i32 (i32, ...) bitcast (i32 (...)* @putint to i32 (i32, ...)*)(i32 %<span class=\"number\">13</span>)</span><br><span class=\"line\">  ret i32 <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>语法 <code>br + 标志位 + truelabel + falselabel</code></p>\n<h1 id=\"cfg图\"><a class=\"markdownIt-Anchor\" href=\"#cfg图\">#</a> cfg 图</h1>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a &gt; b) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> max(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>opt -dot-cfg test.ll</code>  生成</p>\n<p>为了可视化</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install -y graphviz-doc libgraphviz-dev graphviz</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dot .max.dot  -Tpng -o max.png</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2022/10/18/llvm-init/image-20221018103046162.png\" alt=\"image-20221018103046162\"><br>\n 如果在 clang 的时候用 O3 编译<br>\n这里就变成了选择函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define dso_local i32 @max(i32, i32) local_unnamed_addr #<span class=\"number\">0</span> &#123;</span><br><span class=\"line\">  %<span class=\"number\">3</span> = icmp sgt i32 %<span class=\"number\">0</span>, %<span class=\"number\">1</span></span><br><span class=\"line\">  %<span class=\"number\">4</span> = select i1 %<span class=\"number\">3</span>, i32 %<span class=\"number\">0</span>, i32 %<span class=\"number\">1</span></span><br><span class=\"line\">  ret i32 %<span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>sgt: signed greater than (<a href=\"https://releases.llvm.org/2.7/docs/LangRef.html\">LLVM Assembly Language Reference Manual</a>)</li>\n<li>The ‘select’ instruction is used to choose one value based on a condition, without branching.</li>\n</ul>\n<h1 id=\"ssa-phi-node\"><a class=\"markdownIt-Anchor\" href=\"#ssa-phi-node\">#</a> SSA &amp; phi node</h1>\n<p>这个概念在 ghidra，南大静态分析，各种文章里都看过了。。<br>\nSSA form enables and simplifies a vast number of compiler optimizations, and is the de-facto standard for intermediate representations in compilers of imperative programming languages.<br>\n 看这个就行 <a href=\"https://carstein.github.io/2020/10/22/ssa-explained.html\">SSA Explained</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define i32 @max(i32 %a, i32 %b) &#123;</span><br><span class=\"line\">entry:</span><br><span class=\"line\">  %<span class=\"number\">0</span> = icmp sgt i32 %a, %b</span><br><span class=\"line\">  br i1 %<span class=\"number\">0</span>, label %btrue, label %bfalse</span><br><span class=\"line\"></span><br><span class=\"line\">btrue:                                      ; preds = %<span class=\"number\">2</span></span><br><span class=\"line\">  br label %end</span><br><span class=\"line\"></span><br><span class=\"line\">bfalse:                                     ; preds = %<span class=\"number\">2</span></span><br><span class=\"line\">  br label %end</span><br><span class=\"line\"></span><br><span class=\"line\">end:                                     ; preds = %btrue, %bfalse</span><br><span class=\"line\">  %retval = phi i32 [%a, %btrue], [%b, %bfalse]</span><br><span class=\"line\">  ret i32 %retval</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>依据控制流分支选择变量。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">llc -O0 -filetype=asm test.ll</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># %bb<span class=\"number\">.0</span>:                                # %entry</span><br><span class=\"line\">\tcmpl\t%esi, %edi</span><br><span class=\"line\">\tmovl\t%edi, <span class=\"number\">-4</span>(%rsp)          # <span class=\"number\">4</span>-byte Spill</span><br><span class=\"line\">\tmovl\t%esi, <span class=\"number\">-8</span>(%rsp)          # <span class=\"number\">4</span>-byte Spill</span><br><span class=\"line\">\tjle\t.LBB0_2</span><br><span class=\"line\"># %bb<span class=\"number\">.1</span>:                                # %btrue</span><br><span class=\"line\">\tmovl\t<span class=\"number\">-4</span>(%rsp), %eax          # <span class=\"number\">4</span>-byte Reload</span><br><span class=\"line\">\tmovl\t%eax, <span class=\"number\">-12</span>(%rsp)         # <span class=\"number\">4</span>-byte Spill</span><br><span class=\"line\">\tjmp\t.LBB0_3</span><br><span class=\"line\">.LBB0_2:                                # %bfalse</span><br><span class=\"line\">\tmovl\t<span class=\"number\">-8</span>(%rsp), %eax          # <span class=\"number\">4</span>-byte Reload</span><br><span class=\"line\">\tmovl\t%eax, <span class=\"number\">-12</span>(%rsp)         # <span class=\"number\">4</span>-byte Spill</span><br><span class=\"line\">\tjmp\t.LBB0_3</span><br><span class=\"line\">.LBB0_3:                                # %end</span><br><span class=\"line\">\tmovl\t<span class=\"number\">-12</span>(%rsp), %eax         # <span class=\"number\">4</span>-byte Reload</span><br><span class=\"line\">\tretq</span><br></pre></td></tr></table></figure>\n<p>汇编里是实现就是每一条分支都往 <code>-12(%rsp)</code>  上放置数据，然后 end 分支读取。</p>\n",
            "tags": [
                "llvm"
            ]
        }
    ]
}